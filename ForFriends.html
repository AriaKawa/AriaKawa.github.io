<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Know Your Friends</title>
  <style>
    :root { --bg:#0b1220; --panel:#121b2e; --ink:#e6edf6; --muted:#9fb2d1; --accent:#6ea8fe; --ok:#2ecc71; --warn:#f39c12; --danger:#e74c3c; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:radial-gradient(1200px 800px at 20% -10%,#17233e 0,#0b1220 60%),var(--bg);color:var(--ink);min-height:100vh}
    header{padding:18px 20px;border-bottom:1px solid #22304f;background:#0e1730cc;backdrop-filter: blur(4px);position:sticky;top:0}
    .wrap{max-width:980px;margin:0 auto;padding:24px}
    .card{background:var(--panel);border:1px solid #1c2740;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.25)}
    .pad{padding:20px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    input,button,select,textarea{background:#0e1526;border:1px solid #243455;color:var(--ink);padding:10px 12px;border-radius:12px}
    input,select,textarea{flex:1}
    button{cursor:pointer}
    button.primary{background:var(--accent);border-color:#3f6cd8;color:#06102b;font-weight:700}
    button.ghost{background:transparent}
    button:disabled{opacity:.6;cursor:not-allowed}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #22304f;background:#0d162b;color:var(--muted);font-size:.9rem}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:14px}
    .list{display:flex;flex-wrap:wrap;gap:10px}
    .muted{color:var(--muted)}
    .center{text-align:center}
    .hidden{display:none !important}
    .big{font-size:1.2rem}
    .code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0a101f;padding:4px 8px;border-radius:8px;border:1px solid #1c2740}
    .score{font-weight:700;color:var(--ok)}
    .hr{height:1px;background:#213152;margin:12px 0}
    .answer-reveal{display:grid;grid-template-columns:1.2fr .8fr;gap:10px}
    table{width:100%;border-collapse:collapse}
    td,th{padding:10px;border-bottom:1px solid #22304f;text-align:left}
    .pill{padding:4px 8px;border-radius:999px;border:1px solid #22304f}

    /* Entry lobby overlay */
    .entry-lobby{position:fixed;inset:0;z-index:20;display:flex;align-items:center;justify-content:center;padding:1.5rem;background:rgba(9,15,28,.78);backdrop-filter:blur(22px)}
    .entry-card{background:rgba(14,23,48,.9);border:1px solid rgba(255,255,255,.08);border-radius:26px;box-shadow:0 18px 36px rgba(0,0,0,.4);padding:clamp(1.6rem,4vw,2.6rem);width:min(420px,94vw);display:grid;gap:1.1rem;text-align:center}
    .entry-card h2{font-size:1.8rem;margin:0;letter-spacing:.04em}
    .entry-card p{margin:0;opacity:.85;line-height:1.45}
    .entry-actions{display:grid;gap:.8rem}
    .entry-lobby .ghost{background:rgba(255,255,255,.08);color:var(--ink);border:1px solid rgba(255,255,255,.18);box-shadow:none}
    .entry-lobby .ghost:hover{background:rgba(255,255,255,.16)}
    .entry-lobby .secondary{background:rgba(0,0,0,.35);color:var(--ink);border:1px solid rgba(255,255,255,.15);box-shadow:none}
    .entry-lobby .secondary:hover{background:rgba(0,0,0,.5)}
    .entry-lobby input{appearance:none;border-radius:16px;border:1px solid rgba(255,255,255,.18);padding:.85rem 1rem;background:rgba(0,0,0,.35);color:var(--ink);font-size:1.05rem;text-transform:none;letter-spacing:.02em;text-align:left}
    .entry-lobby input:focus{outline:2px solid rgba(110,168,254,.6);outline-offset:3px}
    .entry-lobby details{background:rgba(0,0,0,.25);border-radius:18px;padding:1rem;text-align:left;border:1px solid rgba(255,255,255,.08)}
    .entry-lobby summary{cursor:pointer;font-weight:600}
    .entry-lobby .back-action{font-size:.9rem;font-weight:600;padding:.6rem .9rem;justify-self:center}
    @media (max-width:520px){.entry-card{gap:1rem;padding:1.4rem;width:100%}}
  </style>
</head>
<body>
  <div class="entry-lobby" id="entryLobby">
    <div class="entry-card" id="entryMain">
      <h2>Know Your Friends</h2>
      <p>Select how you'd like to play.</p>
      <div class="entry-actions">
        <button class="primary" id="entryBtnSingle">Singleplayer</button>
        <button class="ghost" id="entryBtnMultiplayer">Multiplayer</button>
      </div>
    </div>
    <div class="entry-card hidden" id="entrySoloCard">
      <h2>Solo Mode</h2>
      <p>Know Your Friends shines with a group! Gather a friend and hop into Multiplayer.</p>
      <button class="secondary back-action" data-target="entryMain">Back</button>
    </div>
    <div class="entry-card hidden" id="entryMultiplayerCard">
      <h2>Multiplayer</h2>
      <p>Invite friends to a shared room.</p>
      <div class="entry-actions">
        <button class="primary" id="entryBtnHost">Host</button>
        <button class="ghost" id="entryBtnJoin">Join</button>
      </div>
      <button class="secondary back-action" data-target="entryMain">Back</button>
    </div>
    <div class="entry-card hidden" id="entryHostCard">
      <h2>Host a Room</h2>
      <p>Pick a display name to create a new room and share the code.</p>
      <input id="createName" placeholder="Your display name" />
      <button id="createBtn" class="primary">Host New Room</button>
      <details>
        <summary>Firebase setup (click if needed)</summary>
        <p class="muted">Paste your Firebase project config in the <span class="code">firebaseConfig</span> object below. This uses Firestore &amp; Anonymous Auth over CDN.</p>
      </details>
      <button class="secondary back-action" data-target="entryMultiplayerCard">Back</button>
    </div>
    <div class="entry-card hidden" id="entryJoinCard">
      <h2>Join a Room</h2>
      <p>Enter the name you'll display to friends and the invite code.</p>
      <input id="joinName" placeholder="Your display name" />
      <input id="joinCode" placeholder="Room code (e.g. 5‚Äëletter)" />
      <button id="joinBtn" class="primary">Join</button>
      <button class="secondary back-action" data-target="entryMultiplayerCard">Back</button>
    </div>
  </div>
  <header>
    <div class="wrap row" style="justify-content:space-between">
      <div class="row" style="gap:10px">
        <strong>Know Your Friends</strong>
        <span class="tag">Firebase ¬∑ Multiplayer</span>
        <span id="youTag" class="tag hidden">You: <span id="youName"></span></span>
        <span id="roomTag" class="tag hidden">Room: <span id="roomCode"></span></span>
      </div>
      <div class="row">
        <button id="copyRoomBtn" class="ghost hidden">Copy Invite</button>
        <button id="leaveBtn" class="ghost hidden">Leave</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Lobby -->
    <section id="lobby" class="card pad hidden">
      <div class="row" style="justify-content:space-between">
        <h2 class="big">Lobby</h2>
        <span id="hostBadge" class="pill hidden">You are the host</span>
      </div>
      <p>Share room code <span class="code" id="roomCode2"></span> or send the invite link.</p>
      <div class="grid" id="playersList"></div>
      <div class="hr"></div>
      <div class="row">
        <button id="startBtn" class="primary hidden">Start Game</button>
        <span class="muted">All players answer the same 3 questions.</span>
      </div>
    </section>

    <!-- Phase: Collect self answers -->
    <section id="collect" class="card pad hidden">
      <h2 class="big">Your Answers</h2>
      <p class="muted">Everyone answers the same questions about themselves.</p>
      <form id="collectForm" class="grid"></form>
      <div class="row">
        <button id="submitSelfBtn" class="primary">Submit My Answers</button>
      </div>
      <p id="collectWaiting" class="muted hidden">Submitted! Waiting for others‚Ä¶</p>
    </section>

    <!-- Phase: Guessing -->
    <section id="guess" class="card pad hidden">
      <div class="row" style="justify-content:space-between">
        <h2 class="big">Guess the Friend</h2>
        <span id="roundTag" class="tag"></span>
      </div>
      <p class="muted">Guess what <b id="targetName"></b> answered.</p>
      <div id="questionBlock" class="card pad" style="margin:8px 0 14px">
        <div id="questionText" class="big"></div>
        <div class="row" style="margin-top:10px">
          <input id="guessInput" placeholder="Your guess" />
          <button id="submitGuessBtn" class="primary">Submit Guess</button>
        </div>
        <p id="guessWaiting" class="muted hidden">Waiting for others‚Ä¶</p>
      </div>

      <div id="revealBlock" class="card pad hidden">
        <div class="answer-reveal">
          <div>
            <div class="muted">Correct answer</div>
            <div id="correctAnswer" class="big"></div>
          </div>
          <div>
            <div class="muted">Your guess</div>
            <div id="yourGuess" class="big"></div>
          </div>
        </div>
        <div class="hr"></div>
        <div>
          <div class="muted">Everyone's guesses</div>
          <div id="allGuesses" class="list"></div>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="nextBtn" class="primary hidden">Next</button>
        </div>
      </div>
    </section>

    <!-- Results -->
    <section id="results" class="card pad hidden">
      <h2 class="big">Final Scores</h2>
      <table id="scoreTable"></table>
      <div class="row" style="margin-top:12px">
        <button id="playAgainBtn" class="primary">Play Again (same room)</button>
      </div>
    </section>
  </main>

  <!-- Firebase SDKs -->
  <script type="module">
    // =====================
    //  Firebase bootstrap
    // =====================
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      // TODO: Replace with your config
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_PROJECT.firebaseapp.com",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_PROJECT.appspot.com",
      messagingSenderId: "YOUR_SENDER_ID",
      appId: "YOUR_APP_ID"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // ===============
    //  DOM helpers
    // ===============
    const $ = (sel)=>document.querySelector(sel);
    const $$ = (sel)=>document.querySelectorAll(sel);
    const show = (id, on=true)=>{ const el = (typeof id==="string")?$(id):id; if(!el) return; el.classList.toggle("hidden", !on); };

    // Elements
    const gate = '#entryLobby', lobby = '#lobby', collect = '#collect', guess = '#guess', results = '#results';

    const ui = {
      entryLobby: $('#entryLobby'),
      entryCards: Array.from($$('.entry-card')),
      entryBtnSingle: $('#entryBtnSingle'),
      entryBtnMultiplayer: $('#entryBtnMultiplayer'),
      entryBtnHost: $('#entryBtnHost'),
      entryBtnJoin: $('#entryBtnJoin'),
      entryBackButtons: Array.from($$('.entry-lobby .back-action')),
      createName: $('#createName'), createBtn: $('#createBtn'),
      joinName: $('#joinName'), joinCode: $('#joinCode'), joinBtn: $('#joinBtn'),
      youTag: $('#youTag'), youName: $('#youName'), roomTag: $('#roomTag'), roomCode: $('#roomCode'), roomCode2: $('#roomCode2'),
      copyRoomBtn: $('#copyRoomBtn'), leaveBtn: $('#leaveBtn'), playersList: $('#playersList'),
      startBtn: $('#startBtn'), hostBadge: $('#hostBadge'),
      collectForm: $('#collectForm'), submitSelfBtn: $('#submitSelfBtn'), collectWaiting: $('#collectWaiting'),
      roundTag: $('#roundTag'), targetName: $('#targetName'), questionText: $('#questionText'), guessInput: $('#guessInput'), submitGuessBtn: $('#submitGuessBtn'), guessWaiting: $('#guessWaiting'),
      revealBlock: $('#revealBlock'), questionBlock: $('#questionBlock'), correctAnswer: $('#correctAnswer'), yourGuess: $('#yourGuess'), allGuesses: $('#allGuesses'), nextBtn: $('#nextBtn'),
      scoreTable: $('#scoreTable'), playAgainBtn: $('#playAgainBtn')
    };

    function switchEntryCard(id){
      ui.entryCards.forEach(card=>card.classList.add('hidden'));
      const el = document.getElementById(id);
      if(el){ el.classList.remove('hidden'); }
    }

    ui.entryBtnSingle?.addEventListener('click', ()=>switchEntryCard('entrySoloCard'));
    ui.entryBtnMultiplayer?.addEventListener('click', ()=>switchEntryCard('entryMultiplayerCard'));
    ui.entryBtnHost?.addEventListener('click', ()=>switchEntryCard('entryHostCard'));
    ui.entryBtnJoin?.addEventListener('click', ()=>switchEntryCard('entryJoinCard'));
    ui.entryBackButtons.forEach(btn=>btn.addEventListener('click', (event)=>{
      const target = event.currentTarget.dataset.target;
      if(target){ switchEntryCard(target); }
    }));

    // =====================
    //  Game constants/state
    // =====================
    const SHARED_QUESTIONS = [
      "What‚Äôs your go‚Äëto comfort food?",
      "Which city would you most love to visit next?",
      "What‚Äôs a movie you can rewatch forever?"
    ];

    const STATE = { lobby: 'lobby', collect: 'collect', guess: 'guess', results: 'results' };

    let me = { uid:null, name:null, room:null, isHost:false };
    let gameDocUnsub = null; let playersUnsub = null; let guessesUnsub = null;
    let playersCache = [];
    let currentGameState = null;
    let currentRoundData = null;
    let currentRoundRef = null;
    let lastRoundKey = null;

    // ===============
    //  Utilities
    // ===============
    const randomCode = (len=5)=> Array.from(crypto.getRandomValues(new Uint8Array(len))).map(n=>"abcdefghijklmnopqrstuvwxyz"[n%26]).join('').toUpperCase();
    const norm = (s)=> (s||'').trim().toLowerCase();
    const displayText = (val)=>{
      const raw = (val ?? '').toString().trim();
      return raw || '‚Äî';
    };

    const roomRef = (code)=> doc(db,'games', code);
    const playerRef = (code, uid)=> doc(db,'games', code, 'players', uid);
    const guessesCol = (code)=> collection(db,'games', code, 'guesses'); // one doc per (round)

    // =====================
    //  Auth lifecycle
    // =====================
    onAuthStateChanged(auth, async (user)=>{
      if(!user){ await signInAnonymously(auth); return; }
      me.uid = user.uid;
    });

    // =====================
    //  Room flow
    // =====================
    ui.createBtn.onclick = async ()=>{
      const name = ui.createName.value.trim(); if(!name) return alert('Enter a name');
      me.name = name; const code = randomCode(5);
      const ref = roomRef(code);
      await setDoc(ref, {
        createdAt: serverTimestamp(),
        state: STATE.lobby,
        hostId: me.uid,
        code,
        questions: SHARED_QUESTIONS,
        currentTargetIndex: 0,
        currentQuestionIndex: 0,
        reveal: false // whether to show answers for current step
      });
      await setDoc(playerRef(code, me.uid), { name, joinedAt: serverTimestamp(), score: 0, isHost:true, submitted:false, answers:{} });
      me.room = code; me.isHost = true;
      postJoin();
    };

    ui.joinBtn.onclick = async ()=>{
      const name = ui.joinName.value.trim(); const code = ui.joinCode.value.trim().toUpperCase();
      if(!name || !code) return alert('Enter name & room code');
      const ref = roomRef(code); const snap = await getDoc(ref);
      if(!snap.exists()) return alert('Room not found');
      const data = snap.data(); if(data.state!==STATE.lobby) return alert('Game already started');
      me.name = name; me.room = code; me.isHost = (data.hostId===me.uid);
      await setDoc(playerRef(code, me.uid), { name, joinedAt: serverTimestamp(), score:0, isHost: me.isHost, submitted:false, answers:{} });
      postJoin();
    };

    async function leaveRoom(){
      if(!me.room) return;
      const code = me.room;
      try { await deleteDoc(playerRef(code, me.uid)); } catch(e){}
      cleanupListeners();
      me = { uid: me.uid, name:null, room:null, isHost:false };
      switchEntryCard('entryMain');
      show(gate,true); show(lobby,false); show(collect,false); show(guess,false); show(results,false);
      show(ui.roomTag,false); show(ui.youTag,false); show(ui.copyRoomBtn,false); show(ui.leaveBtn,false);
    }

    ui.leaveBtn.onclick = leaveRoom;

    function postJoin(){
      // header tags
      ui.youName.textContent = me.name; ui.roomCode.textContent = me.room; ui.roomCode2.textContent = me.room;
      show(ui.youTag,true); show(ui.roomTag,true); show(ui.copyRoomBtn,true); show(ui.leaveBtn,true);
      // screen
      switchEntryCard('entryMain');
      show(gate,false); show(lobby,true);
      if(me.isHost) { show(ui.startBtn,true); show(ui.hostBadge,true); }
      else { show(ui.startBtn,false); show(ui.hostBadge,false); }
      // listeners
      attachGameListeners();
    }

    ui.copyRoomBtn.onclick = async ()=>{
      const url = `${location.origin}${location.pathname}?room=${me.room}`;
      await navigator.clipboard.writeText(url);
      ui.copyRoomBtn.textContent = 'Copied!'; setTimeout(()=>ui.copyRoomBtn.textContent='Copy Invite',1200);
    };

    // =====================
    //  Listeners
    // =====================
    async function attachGameListeners(){
      const gref = roomRef(me.room);
      gameDocUnsub = onSnapshot(gref, (snap)=>{
        if(!snap.exists()) return;
        const g = snap.data();
        currentGameState = { ...g, code: me.room };
        // phase routing
        if(g.state===STATE.lobby){
          currentRoundData = null; currentRoundRef = null; lastRoundKey = null;
          show(lobby,true); show(collect,false); show(guess,false); show(results,false);
        }
        if(g.state===STATE.collect){
          currentRoundData = null; currentRoundRef = null; lastRoundKey = null;
          renderCollect(g);
        }
        if(g.state===STATE.guess){ renderGuess(g); }
        if(g.state===STATE.results){ renderResults(); }
      });

      const pref = collection(db,'games', me.room, 'players');
      playersUnsub = onSnapshot(pref, (qs)=>{
        const players = [];
        qs.forEach(d=>players.push({id:d.id, ...d.data()}));
        players.sort((a,b)=> (a.joinedAt?.seconds||0)-(b.joinedAt?.seconds||0));
        playersCache = players;
        renderPlayers(players);
        if(currentGameState?.state===STATE.guess){ updateGuessUI(); }
      });
    }

    function cleanupListeners(){ gameDocUnsub && gameDocUnsub(); playersUnsub && playersUnsub(); guessesUnsub && guessesUnsub(); }

    // =====================
    //  Lobby & Start
    // =====================
    function renderPlayers(players){
      ui.playersList.innerHTML = '';
      players.forEach(p=>{
        const el = document.createElement('div'); el.className='card pad';
        el.innerHTML = `<div class="row" style="justify-content:space-between"><div><b>${p.name}</b></div><span class="muted">${p.isHost?'Host':'Player'}</span></div>`;
        ui.playersList.appendChild(el);
      });
      // host start enabled only if 2+ players
      if(me.isHost){ ui.startBtn.disabled = players.length<2; }
    }

    ui.startBtn.onclick = async ()=>{
      if(!me.isHost) return;
      // move to collect phase & clear prior
      await updateDoc(roomRef(me.room), { state: STATE.collect, currentTargetIndex:0, currentQuestionIndex:0, reveal:false });
      // reset players
      const pref = collection(db,'games', me.room, 'players');
      const qs = await getDocs(pref);
      for(const d of qs.docs){ await updateDoc(d.ref, { score:0, submitted:false, answers:{} }); }
      // wipe guesses
      const gcol = guessesCol(me.room); const gqs = await getDocs(gcol); for(const d of gqs.docs){ await deleteDoc(d.ref); }
    };

    // =====================
    //  Phase: Collect
    // =====================
    function renderCollect(game){
      show(lobby,false); show(collect,true); show(guess,false); show(results,false);
      show(ui.collectWaiting,false); ui.submitSelfBtn.disabled = false;
      // build form once
      if(!ui.collectForm.dataset.ready){
        ui.collectForm.innerHTML = '';
        game.questions.forEach((q,i)=>{
          const w = document.createElement('div'); w.className='card pad';
          w.innerHTML = `<label class="muted">Q${i+1}</label><div style="margin:6px 0 8px" class="big">${q}</div><input data-q="${i}" placeholder="Your answer" />`;
          ui.collectForm.appendChild(w);
        });
        ui.collectForm.dataset.ready = '1';
      } else {
        ui.collectForm.querySelectorAll('input[data-q]').forEach(inp=> inp.value='');
      }
    }

    ui.submitSelfBtn.onclick = async ()=>{
      const inputs = [...ui.collectForm.querySelectorAll('input[data-q]')];
      const answers = {}; inputs.forEach(inp=> answers[inp.dataset.q] = inp.value.trim());
      // simple validate
      for(let i=0;i<inputs.length;i++){ if(!answers[i]) return alert('Please answer all questions'); }
      await updateDoc(playerRef(me.room, me.uid), { answers, submitted:true });
      show(ui.collectWaiting,true);
      ui.submitSelfBtn.disabled = true;
      // if host ‚Äì check if all submitted then move forward
      maybeAdvanceFromCollect();
    };

    async function maybeAdvanceFromCollect(){
      if(!me.isHost) return;
      const pref = collection(db,'games', me.room, 'players');
      const qs = await getDocs(pref); let all = true; qs.forEach(d=>{ if(!d.data().submitted) all=false; });
      if(all){ await updateDoc(roomRef(me.room), { state: STATE.guess, currentTargetIndex:0, currentQuestionIndex:0, reveal:false }); }
    }

    // =====================
    //  Phase: Guess
    // =====================
    function docIdForRound(targetId, qIndex){ return `${targetId}__Q${qIndex}`; }

    function assignGuessesListener(code, targetId, qIndex){
      guessesUnsub && guessesUnsub();
      currentRoundRef = doc(db,'games', code, 'guesses', docIdForRound(targetId, qIndex));
      currentRoundData = null;
      guessesUnsub = onSnapshot(currentRoundRef, (snap)=>{
        currentRoundData = snap.data() || { targetId, qIndex, guesses:{} };
        updateGuessUI();
      });
    }

    async function submitGuess(code, targetId, qIndex, guess){
      const roundRef = doc(db,'games', code, 'guesses', docIdForRound(targetId,qIndex));
      const roundSnap = await getDoc(roundRef);
      const payload = { createdAt: serverTimestamp(), targetId, qIndex };
      const field = `guesses.${me.uid}`;
      if(roundSnap.exists()){
        await updateDoc(roundRef, { [field]: guess, ...payload });
      } else {
        await setDoc(roundRef, { [field]: guess, ...payload });
      }
    }

    async function nextStep(game, players){
      if(!me.isHost) return;
      const totalTargets = players.length;
      let t = game.currentTargetIndex, q = game.currentQuestionIndex, reveal=false;
      // advance question index; then target; end -> results
      if(q < (game.questions.length-1)){ q++; }
      else { q = 0; t++; }

      if(t >= totalTargets){
        currentRoundData = null; currentRoundRef = null;
        await updateDoc(roomRef(game.code), { state: STATE.results, reveal:false });
        return;
      }
      currentRoundData = null; currentRoundRef = null;
      await updateDoc(roomRef(game.code), { currentTargetIndex:t, currentQuestionIndex:q, reveal:false });
    }

    async function renderGuess(game){
      show(lobby,false); show(collect,false); show(guess,true); show(results,false);
      show(ui.guessWaiting,false);
      if(!playersCache.length){
        const pref = collection(db,'games', game.code, 'players');
        const qs = await getDocs(pref);
        playersCache = qs.docs.map(d=>({id:d.id, ...d.data()})).sort((a,b)=> (a.joinedAt?.seconds||0)-(b.joinedAt?.seconds||0));
        if(playersCache.length){ renderPlayers(playersCache); }
      }
      const target = playersCache[game.currentTargetIndex];
      if(!target) return;

      const roundKey = `${target.id}:${game.currentQuestionIndex}`;
      if(lastRoundKey !== roundKey){
        lastRoundKey = roundKey;
        ui.guessInput.value = '';
        show(ui.guessWaiting,false);
      }

      assignGuessesListener(game.code, target.id, game.currentQuestionIndex);

      ui.submitGuessBtn.onclick = async ()=>{
        if(target.id === me.uid || game.reveal) return;
        const val = ui.guessInput.value.trim();
        if(!val) return alert('Enter a guess');
        await submitGuess(game.code, target.id, game.currentQuestionIndex, val);
        ui.guessInput.value='';
        show(ui.guessWaiting,true);
      };

      ui.nextBtn.onclick = async ()=>{
        if(!me.isHost) return;
        if(!currentGameState) return;
        if(!currentGameState.reveal){ await updateDoc(roomRef(currentGameState.code), { reveal:true }); }
        else { await nextStep(currentGameState, playersCache); }
      };

      updateGuessUI();
    }

    async function ensureAwards(round, targetId, correct){
      if(!me.isHost || !currentRoundRef) return;
      const awards = {};
      Object.entries(round.guesses || {}).forEach(([uid, text])=>{
        if(uid!==targetId && norm(text)===norm(correct)){ awards[uid] = 1; }
      });
      const existing = round.awards || {};
      const sameSize = Object.keys(awards).length === Object.keys(existing).length;
      let identical = sameSize;
      if(identical){
        for(const [uid,val] of Object.entries(awards)){
          if(existing[uid] !== val){ identical = false; break; }
        }
        if(identical){
          for(const uid of Object.keys(existing)){
            if(!(uid in awards)){ identical = false; break; }
          }
        }
      }
      if(!identical){ await updateDoc(currentRoundRef, { awards }); }
    }

    function updateGuessUI(){
      if(currentGameState?.state !== STATE.guess) return;
      const game = currentGameState;
      const players = playersCache;
      if(!players.length) return;
      const target = players[game.currentTargetIndex];
      if(!target) return;

      const question = game.questions[game.currentQuestionIndex];
      ui.roundTag.textContent = `Target ${game.currentTargetIndex+1}/${players.length} ¬∑ Q${game.currentQuestionIndex+1}/${game.questions.length}`;
      ui.targetName.textContent = target.name || '‚Äî';
      ui.questionText.textContent = question;

      const round = currentRoundData || { guesses:{} };
      const correct = (target.answers||{})[game.currentQuestionIndex] || '';
      const amTarget = target.id === me.uid;
      const myGuess = round.guesses?.[me.uid];

      const waiting = !!myGuess && !game.reveal && !amTarget;
      show(ui.guessWaiting, waiting);

      ui.guessInput.disabled = amTarget || game.reveal;
      ui.submitGuessBtn.disabled = amTarget || game.reveal;

      show(ui.nextBtn, me.isHost);
      ui.nextBtn.textContent = game.reveal ? 'Next' : 'Reveal';

      if(game.reveal){
        show(ui.revealBlock,true); show(ui.questionBlock,false);
        ui.correctAnswer.textContent = displayText(correct);
        ui.yourGuess.textContent = displayText(myGuess);
        ui.allGuesses.innerHTML = '';
        const order = new Map(players.map((p,i)=>[p.id,i]));
        Object.entries(round.guesses || {})
          .sort((a,b)=> (order.get(a[0]) ?? 999) - (order.get(b[0]) ?? 999))
          .forEach(([uid, text])=>{
            const who = players.find(p=>p.id===uid);
            const isRight = uid!==target.id && norm(text)===norm(correct);
            const item = document.createElement('div'); item.className='tag';
            item.innerHTML = `<b>${who?.name||'?'}</b> ‚Äî ${displayText(text)} ${isRight?'<span class="score">(+1)</span>':''}`;
            ui.allGuesses.appendChild(item);
          });
        ensureAwards(round, target.id, correct).catch((err)=>console.error('Failed to persist awards', err));
      } else {
        show(ui.revealBlock,false); show(ui.questionBlock,true);
        ui.allGuesses.innerHTML = '';
      }
    }

    // =====================
    //  Results
    // =====================
    async function renderResults(){
      show(lobby,false); show(collect,false); show(guess,false); show(results,true);
      lastRoundKey = null;
      const pref = collection(db,'games', me.room, 'players');
      const qs = await getDocs(pref);
      const players = qs.docs.map(d=>({id:d.id,...d.data()}));

      // recompute final totals from awards in all rounds for canonical score
      let totals = Object.fromEntries(players.map(p=>[p.id,0]));
      const gqs = await getDocs(guessesCol(me.room));
      gqs.forEach(d=>{ const aw = d.data().awards||{}; Object.entries(aw).forEach(([uid,pt])=>{ totals[uid] = (totals[uid]||0) + (pt||0); }); });

      // render
      const rows = players
        .map(p=> ({ name:p.name, score: totals[p.id]||0 }))
        .sort((a,b)=> b.score - a.score)
        .map((p,i)=> `<tr><td>${i===0?'üèÜ':''}</td><td><b>${p.name}</b></td><td class="score">${p.score}</td></tr>`)
        .join('');
      ui.scoreTable.innerHTML = `<thead><tr><th></th><th>Player</th><th>Points</th></tr></thead><tbody>${rows}</tbody>`;
    }

    // =====================
    //  Play again (same room)
    // =====================
    ui.playAgainBtn.onclick = async ()=>{
      if(!me.isHost) { alert('Ask the host to start a new round.'); return; }
      await updateDoc(roomRef(me.room), { state: STATE.lobby, currentTargetIndex:0, currentQuestionIndex:0, reveal:false });
      // clear transient collections
      const gqs = await getDocs(guessesCol(me.room)); for(const d of gqs.docs){ await deleteDoc(d.ref); }
    };

    // =====================
    //  URL Join helper
    // =====================
    (function hydrateFromURL(){
      const u = new URL(location.href); const r = (u.searchParams.get('room')||'').toUpperCase();
      if(r) ui.joinCode.value = r;
    })();

    // Expose leave for safety
    window.addEventListener('beforeunload', ()=>{ /* lightweight; server cleanup is best-effort */ });
  </script>
</body>
</html>
