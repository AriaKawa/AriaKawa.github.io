<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blackjack — Aria & Friends Hub</title>
<style>
  :root{
    --felt:#0e4d37;            /* table background */
    --felt-dark:#0a3a2a;
    --line:#154f40;
    --card:#fff;
    --shadow:0 14px 30px rgba(0,0,0,.35);
    --accent:#ffd13b;          /* primary button */
    --accent-2:#161a24;        /* secondary button */
    --text:#e9f1ee;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--text); background:#0b1020; display:grid; place-items:center;
  }
  .table{
    position:relative; width:min(1100px, 96vw); aspect-ratio: 16/9;
    background: radial-gradient(120% 90% at 50% -15%, #208b6e 0, var(--felt) 32%, var(--felt-dark) 95%);
    border-radius:28px; box-shadow: var(--shadow);
    overflow:hidden; border:6px solid #0c3024;
  }
  .table::after{
    content:""; position:absolute; inset:20px;
    border:2px dashed rgba(255,255,255,.15); border-radius:22px; pointer-events:none;
  }
  header{
    position:absolute; top:14px; left:18px; right:18px; display:flex; align-items:center; gap:.75rem;
    z-index:3;
  }
  .brand{font-weight:800; letter-spacing:.08em; opacity:.9}
  .spacer{flex:1}
  .chip{
    font-variant-numeric:tabular-nums;
    background:linear-gradient(#ffe07a, #e3b312);
    color:#2a2100; font-weight:800; padding:.45rem .7rem; border-radius:999px; box-shadow: var(--shadow);
  }

  /* Lanes */
  .lane{ position:absolute; left:50%; transform:translateX(-50%); width:80%; }
  .dealer.lane{ top:10%; }
  .player.lane{ bottom:12%; }

  /* Card */
  .card{
    width:96px; height:136px; border-radius:12px; background:var(--card);
    box-shadow: var(--shadow); position:absolute; transition: transform .4s ease, top .4s ease, left .4s ease, opacity .3s ease;
    display:grid; place-items:center; overflow:hidden;
  }
  @media (max-width:720px){
    .card{ width:78px; height:112px; border-radius:10px; }
  }
  .card .svg{ width:94%; height:94%; }
  .back{
    background:repeating-linear-gradient(45deg, #1d2740, #1d2740 10px, #2b3a66 10px, #2b3a66 20px);
    border:3px solid #e5e9f6; position:absolute; inset:0; border-radius:12px;
  }

  /* Spots where cards settle */
  .spot{ position:relative; height:150px; }
  @media (max-width:720px){ .spot{ height:120px; } }

  .players-area{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:7%; width:86%; display:flex; justify-content:center;
    gap:1.8rem; flex-wrap:wrap;
  }
  .player-seat{
    position:relative; display:flex; flex-direction:column; align-items:center;
    min-width:160px;
  }
  .player-seat .spot{ width:160px; }
  .player-meta{
    margin-top:.55rem; text-align:center; text-shadow:0 2px 8px rgba(0,0,0,.5);
  }
  .player-name{ font-weight:700; letter-spacing:.04em; }
  .player-total{ font-size:.95rem; opacity:.9; margin-top:.2rem; }
  .player-seat.me .player-name{ color:var(--accent); }
  .player-seat.active .player-name,
  .player-seat.active .player-total{ color:var(--accent); }
  @media (max-width:720px){
    .players-area{ bottom:6%; gap:1.2rem; }
    .player-seat{ min-width:130px; }
    .player-seat .spot{ width:130px; }
  }

  /* Labels */
  .label{
    position:absolute; left:50%; transform:translateX(-50%);
    text-align:center; text-shadow:0 2px 8px rgba(0,0,0,.5);
  }
  .label.dealer{ top:4%; font-weight:700; opacity:.9 }
  .total{ font-size:1.05rem; opacity:.9 }

  /* Controls */
  .controls{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:3%; display:flex; gap:.6rem; z-index:3; flex-wrap:wrap; justify-content:center;
  }
  button{
    appearance:none; border:0; border-radius:14px; padding:.9rem 1.2rem;
    font-weight:800; box-shadow: var(--shadow); cursor:pointer; transition: transform .05s ease, filter .2s ease, opacity .2s ease;
  }
  button:active{ transform:translateY(1px) scale(.99) }
  button:disabled{ opacity:.45; pointer-events:none; }
  .primary{ background:var(--accent); color:#1a1400 }
  .ghost{ background:var(--accent-2); color:#e9ecf5; border:1px solid rgba(255,255,255,.1) }
  .muted{ opacity:.6; pointer-events:none }

  /* Toast / status */
  .status{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:1.6rem; font-weight:800; letter-spacing:.02em; text-align:center;
    text-shadow:0 3px 30px rgba(0,0,0,.55); opacity:0; transition:opacity .2s ease;
    pointer-events:none; max-width:80%;
  }
  .status.show{ opacity:1 }

  /* Exit link */
  .back-link{
    position:absolute; top:16px; right:20px; z-index:4; display:inline-flex; align-items:center;
    gap:.4rem; font-size:.95rem; text-decoration:none; font-weight:600; color:var(--text);
    background:rgba(0,0,0,.35); padding:.45rem .8rem; border-radius:999px; transition:background .2s ease, transform .2s ease;
  }
  .back-link:hover{ background:rgba(0,0,0,.55); transform:translateY(-1px); }

  .hidden{ display:none !important; }

  .lobby{
    position:fixed; inset:0; z-index:10; display:flex; align-items:center; justify-content:center;
    background:rgba(6,12,24,.8); backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
    padding:1.5rem;
  }
  .lobby-card{
    background:rgba(13,27,44,.92); border:1px solid rgba(255,255,255,.08); border-radius:26px;
    box-shadow:var(--shadow); padding:clamp(1.6rem,4vw,2.6rem); width:min(420px,94vw);
    display:grid; gap:1.1rem; text-align:center;
  }
  .lobby-card h2{ font-size:1.8rem; margin:0; letter-spacing:.04em; }
  .lobby-card p{ margin:0; opacity:.85; line-height:1.4; }
  .name-field{ display:grid; gap:.45rem; text-align:left; }
  .name-field label{ font-weight:600; font-size:.95rem; opacity:.85; }
  .lobby-actions{ display:grid; gap:.8rem; }
  .lobby .ghost{ background:rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.18); box-shadow:none; }
  .lobby .ghost:hover{ background:rgba(255,255,255,.14); }
  .lobby .secondary{ background:rgba(0,0,0,.35); color:var(--text); border:1px solid rgba(255,255,255,.15); box-shadow:none; }
  .lobby .secondary:hover{ background:rgba(0,0,0,.5); }
  .lobby .back-action{ font-size:.9rem; font-weight:600; padding:.6rem .9rem; justify-self:center; }
  .code-display{
    font-size:2rem; letter-spacing:.24em; font-weight:800; text-transform:uppercase;
    padding:.8rem 1.2rem; border-radius:22px; background:rgba(0,0,0,.38); border:1px solid rgba(255,255,255,.18);
  }
  .lobby input{
    appearance:none; border-radius:16px; border:1px solid rgba(255,255,255,.18);
    padding:.85rem 1rem; background:rgba(0,0,0,.35); color:var(--text); font-size:1.05rem;
  }
  .lobby input:focus{ outline:2px solid rgba(255,209,59,.55); outline-offset:3px; }
  .lobby input.code-input{ text-transform:uppercase; text-align:center; letter-spacing:.18em; }
  .lobby input.name-input{ text-transform:none; letter-spacing:.04em; text-align:left; }
</style>
</head>
<body>
  <a class="back-link" href="index.html">← Back to the friend hub</a>
  <div class="lobby" id="lobby">
    <div class="lobby-card" id="lobbyMain">
      <h2>Blackjack Lounge</h2>
      <p>Pick a display name and choose how you'd like to play.</p>
      <div class="name-field">
        <label for="playerNameInput">Display name</label>
        <input type="text" id="playerNameInput" class="name-input" maxlength="16" autocomplete="off" placeholder="Enter your name" />
      </div>
      <div class="lobby-actions">
        <button class="primary" id="btnSingleplayer">Singleplayer</button>
        <button class="ghost" id="btnMultiplayer">Multiplayer</button>
      </div>
    </div>
    <div class="lobby-card hidden" id="multiplayerCard">
      <h2>Multiplayer</h2>
      <p>Invite friends with a shared table code.</p>
      <div class="lobby-actions">
        <button class="primary" id="btnHost">Host</button>
        <button class="ghost" id="btnJoin">Join</button>
      </div>
      <button class="secondary back-action" data-target="lobbyMain">Back</button>
    </div>
    <div class="lobby-card hidden" id="hostCard">
      <h2>Host a Table</h2>
      <p>Share this code with friends so they can join.</p>
      <div class="code-display" id="hostCode">----</div>
      <button class="primary" id="btnHostStart">Enter Table</button>
      <button class="secondary back-action" data-target="multiplayerCard">Back</button>
    </div>
    <div class="lobby-card hidden" id="joinCard">
      <h2>Join a Table</h2>
      <p>Enter the code from your host.</p>
      <input type="text" id="joinCodeInput" class="code-input" maxlength="12" autocomplete="off" placeholder="CODE" />
      <div class="lobby-actions">
        <button class="primary" id="btnJoinConfirm">Join Table</button>
        <button class="secondary back-action" data-target="multiplayerCard">Back</button>
      </div>
    </div>
  </div>
  <div class="table" id="table">
    <header>
      <div class="brand">BLACKJACK • FRIENDS LOUNGE</div>
      <div class="spacer"></div>
      <div class="chip">Bank: <span id="bank">1000</span></div>
    </header>

    <div class="label dealer">Dealer • <span class="total" id="dealerTotal">0</span></div>
    <div class="lane dealer">
      <div class="spot" id="dealerSpot"></div>
    </div>

    <div class="players-area" id="playersArea"></div>

    <div class="status" id="status"></div>

    <div class="controls" id="controls">
      <button class="primary" id="btnDeal">Deal</button>
      <button class="primary muted" id="btnHit">Hit</button>
      <button class="ghost muted" id="btnStand">Stand</button>
      <button class="ghost" id="btnNew">New Shoe</button>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
  import { getAnalytics, isSupported } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
  import { getDatabase, ref, onValue, update, onDisconnect, get } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

  /* ---------- Card + Deck ---------- */
  const SUITS = ["♠","♥","♦","♣"];      // Spade, Heart, Diamond, Club
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];

  function buildShoe(decks=6){
    const shoe=[];
    for(let d=0; d<decks; d++){
      for(const s of SUITS){
        for(const r of RANKS){
          shoe.push({suit:s, rank:r});
        }
      }
    }
    for(let i=shoe.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [shoe[i], shoe[j]]=[shoe[j], shoe[i]];
    }
    return shoe;
  }

  /* ---------- Values ---------- */
  function cardValue(card){
    if(!card) return 0;
    if(card.rank==="A") return 11;
    if(["K","Q","J"].includes(card.rank)) return 10;
    return parseInt(card.rank,10);
  }
  function handValue(cards){
    let sum = 0, aces = 0;
    for(const c of cards){
      sum += cardValue(c);
      if(c.rank==="A") aces++;
    }
    while(sum>21 && aces>0){ sum -= 10; aces--; }
    return sum;
  }

  /* ---------- SVG Renderer ---------- */
  function suitColor(s){ return (s==="♥"||s==="♦") ? "#d64545" : "#1f2a44"; }
  function renderSVG(card){
    const s = suitColor(card.suit);
    const rank = card.rank;
    return `
    <svg class="svg" viewBox="0 0 250 350" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="${rank} ${card.suit}">
      <defs>
        <filter id="innerShadow" x="-50%" y="-50%" width="200%" height="200%">
          <feOffset dx="0" dy="2" />
          <feGaussianBlur stdDeviation="2" result="offblur"/>
          <feComposite in="SourceGraphic" in2="offblur" operator="arithmetic" k2="-1" k3="1"/>
        </filter>
      </defs>
      <rect x="4" y="4" rx="22" ry="22" width="242" height="342" fill="#ffffff" filter="url(#innerShadow)"/>
      <rect x="8" y="8" rx="18" ry="18" width="234" height="334" fill="#ffffff"/>
      <g fill="${s}">
        <text x="22" y="40" font-size="44" font-family="ui-monospace, Menlo, Consolas, monospace">${rank}</text>
        <text x="22" y="76" font-size="44">${card.suit}</text>
        <text x="228" y="340" font-size="44" text-anchor="end" transform="rotate(180,228,340)">${rank}</text>
        <text x="228" y="304" font-size="44" text-anchor="end" transform="rotate(180,228,304)">${card.suit}</text>
        <text x="125" y="205" font-size="120" text-anchor="middle" dominant-baseline="middle" opacity=".9">${card.suit}</text>
      </g>
    </svg>`;
  }

  /* ---------- DOM helpers ---------- */
  const dealerSpot = document.getElementById('dealerSpot');
  const dealerTotal = document.getElementById('dealerTotal');
  const playersArea = document.getElementById('playersArea');
  const statusEl = document.getElementById('status');
  const btnDeal = document.getElementById('btnDeal');
  const btnHit = document.getElementById('btnHit');
  const btnStand = document.getElementById('btnStand');
  const btnNew = document.getElementById('btnNew');
  const bankEl = document.getElementById('bank');
  const lobby = document.getElementById('lobby');
  const lobbyMain = document.getElementById('lobbyMain');
  const multiplayerCard = document.getElementById('multiplayerCard');
  const hostCard = document.getElementById('hostCard');
  const joinCard = document.getElementById('joinCard');
  const playerNameInput = document.getElementById('playerNameInput');
  const hostCodeEl = document.getElementById('hostCode');
  const joinCodeInput = document.getElementById('joinCodeInput');
  const btnSingle = document.getElementById('btnSingleplayer');
  const btnMultiplayer = document.getElementById('btnMultiplayer');
  const btnHost = document.getElementById('btnHost');
  const btnJoin = document.getElementById('btnJoin');
  const btnHostStart = document.getElementById('btnHostStart');
  const btnJoinConfirm = document.getElementById('btnJoinConfirm');

  function setButtons(state){
    const on = (el, ok)=> el.classList.toggle('muted', !ok);
    switch(state){
      case 'deal': on(btnDeal,true); on(btnHit,false); on(btnStand,false); break;
      case 'player': on(btnDeal,false); on(btnHit,true); on(btnStand,true); break;
      default: on(btnDeal,false); on(btnHit,false); on(btnStand,false); break;
    }
  }

  function updateLobbyButtons(){
    const ready = !!nameIsValid;
    if(btnHost) btnHost.disabled = !ready;
    if(btnJoin) btnJoin.disabled = !ready;
    if(btnHostStart) btnHostStart.disabled = !ready;
    if(btnJoinConfirm) btnJoinConfirm.disabled = !ready;
  }

  function setPlayerDisplayName(raw){
    const sanitized = sanitizePlayerName(raw);
    nameIsValid = !!sanitized;
    playerName = sanitized || fallbackName;
    if(playerNameInput && playerNameInput.value !== sanitized){
      playerNameInput.value = sanitized;
    }
    if(nameIsValid && typeof localStorage !== 'undefined'){
      try{ localStorage.setItem('blackjackPlayerName', playerName); }
      catch(err){ console.warn('Failed to store name', err); }
    }
    const me = tableState.players[clientId];
    if(me){
      me.name = playerName;
    }
    updateLobbyButtons();
    renderTable();
    if(isMultiplayer && tablePath){
      commitRound({ includeDealer:false, includePlayer:true, includeShoe:false });
    }
  }

  let transientStatus = null;
  function showStatus(msg, ms=1100){
    transientStatus = { message: msg, until: Date.now() + ms };
    statusEl.textContent = msg;
    statusEl.classList.add('show');
    setTimeout(()=>{
      if(transientStatus && Date.now() >= transientStatus.until){
        transientStatus = null;
        statusEl.classList.remove('show');
        renderTable();
      }
    }, ms);
  }

  function normalizeCards(list){
    if(Array.isArray(list)){
      return list.filter(Boolean).map(card=>({suit:card.suit, rank:card.rank}));
    }
    if(!list || typeof list !== 'object') return [];
    return Object.keys(list)
      .map(Number)
      .sort((a,b)=>a-b)
      .map(key=>list[key])
      .filter(Boolean)
      .map(card=>({suit:card.suit, rank:card.rank}));
  }

  function renderHand(hand, spot, {hideHole=false}={}){
    spot.innerHTML='';
    hand.forEach((card, idx)=>{
      const el = document.createElement('div');
      el.className='card';
      const faceDown = hideHole && idx===1;
      el.innerHTML = faceDown ? '<div class="back"></div>' : renderSVG(card);
      el.style.left = `${20 + idx*28}px`;
      el.style.top = `${6 + idx*2}px`;
      el.style.transform = `translate(0,0) rotate(${[-3,-1,1,3][idx%4]}deg)`;
      spot.appendChild(el);
    });
  }

  /* ---------- Firebase ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyDRniZatGeylxphjHQadYjucOcirNBRIdk",
    authDomain: "multiplayer-640ec.firebaseapp.com",
    databaseURL: "https://multiplayer-640ec-default-rtdb.firebaseio.com",
    projectId: "multiplayer-640ec",
    storageBucket: "multiplayer-640ec.firebasestorage.app",
    messagingSenderId: "94914236381",
    appId: "1:94914236381:web:55ab00cc690140180cf034",
    measurementId: "G-V43J1S8RGF"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const rootRef = ref(db);

  const MAX_PLAYERS = 4;
  const clientId = (crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
  const fallbackName = `Player ${clientId.slice(0,4).toUpperCase()}`;
  let playerName = fallbackName;
  let nameIsValid = true;

  if(typeof localStorage !== 'undefined'){
    try{
      const storedName = localStorage.getItem('blackjackPlayerName');
      const sanitized = sanitizePlayerName(storedName);
      if(sanitized){
        playerName = sanitized;
      }
    }catch(err){
      console.warn('Could not load stored name', err);
    }
  }

  let roomId = null;
  let isMultiplayer = false;
  let tablePath = '';
  let shoeRef = null;
  let dealerRef = null;
  let playersRef = null;
  let stateRef = null;
  let presenceRef = null;
  let unsubscribers = [];
  let knownPlayers = new Set();

  const defaultState = {
    phase: 'waiting',
    activePlayer: null,
    hideDealerHole: false,
    banks: {},
    status: '',
    statusUntil: 0
  };

  const tableState = {
    shoe: [],
    dealer: [],
    players: {},
    state: { ...defaultState }
  };

  function cloneCards(cards){
    return (cards || []).map(card=>({suit:card.suit, rank:card.rank}));
  }

  function commitRound({includeDealer=true, includePlayer=true, includeShoe=true}={}){
    if(!isMultiplayer || !tablePath){
      renderTable();
      return Promise.resolve();
    }
    const now = Date.now();
    const updates = {};
    if(includeShoe){
      updates[`${tablePath}/shoe`] = {
        cards: cloneCards(tableState.shoe),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includeDealer){
      updates[`${tablePath}/dealer`] = {
        hand: cloneCards(tableState.dealer),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includePlayer && tableState.players[clientId]){
      updates[`${tablePath}/players/${clientId}`] = {
        ...tableState.players[clientId],
        hand: cloneCards(tableState.players[clientId].hand),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    updates[`${tablePath}/state`] = {
      ...tableState.state,
      updatedBy: clientId,
      updatedAt: now
    };
    return update(rootRef, updates);
  }

  function ensureShoe(){
    if(!Array.isArray(tableState.shoe) || tableState.shoe.length === 0){
      tableState.shoe = buildShoe(6);
      return;
    }
    if(tableState.shoe.length < 40){
      showStatus('Shuffling…', 800);
      tableState.shoe = buildShoe(6);
    }
  }

  function drawFromShoe(){
    ensureShoe();
    const shoe = tableState.shoe;
    const card = shoe.pop();
    tableState.shoe = shoe;
    return card;
  }

  function getPlayerEntry(){
    if(!tableState.players[clientId]){
      tableState.players[clientId] = {
        name: playerName,
        bank: tableState.state.banks?.[clientId] ?? 1000,
        hand: [],
        status: 'online'
      };
    }
    tableState.players[clientId].name = playerName;
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    if(typeof tableState.state.banks[clientId] !== 'number'){
      tableState.state.banks[clientId] = tableState.players[clientId].bank ?? 1000;
    }
    return tableState.players[clientId];
  }

  function isMyTurn(){
    const { phase, activePlayer } = tableState.state;
    if(phase === 'waiting') return true;
    if(activePlayer && activePlayer !== clientId) return false;
    return true;
  }

  function renderTable(){
    const state = tableState.state || defaultState;
    const me = getPlayerEntry();
    const dealerHand = Array.isArray(tableState.dealer) ? tableState.dealer : [];

    renderHand(dealerHand, dealerSpot, { hideHole: !!state.hideDealerHole });

    if(playersArea){
      playersArea.innerHTML = '';
      const entries = Object.entries(tableState.players || {});
      if(!entries.some(([id]) => id === clientId)){
        entries.unshift([clientId, me]);
      }
      entries.sort((a, b)=>{
        if(a[0] === clientId) return -1;
        if(b[0] === clientId) return 1;
        const nameA = sanitizePlayerName(a[1]?.name) || '';
        const nameB = sanitizePlayerName(b[1]?.name) || '';
        return nameA.localeCompare(nameB);
      });
      const limited = entries.slice(0, MAX_PLAYERS);
      limited.forEach(([id, info])=>{
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        if(id === clientId) seat.classList.add('me');
        if(state.phase === 'player' && state.activePlayer === id){
          seat.classList.add('active');
        }
        const spot = document.createElement('div');
        spot.className = 'spot';
        const hand = Array.isArray(info?.hand) ? info.hand : [];
        renderHand(hand, spot);
        seat.appendChild(spot);

        const meta = document.createElement('div');
        meta.className = 'player-meta';
        const fallbackLabel = `Player ${String(id).slice(0,4).toUpperCase()}`;
        const displayName = sanitizePlayerName(info?.name) || (id === clientId ? playerName : fallbackLabel);
        const nameEl = document.createElement('div');
        nameEl.className = 'player-name';
        nameEl.textContent = displayName;
        const totalEl = document.createElement('div');
        totalEl.className = 'player-total';
        const totalValue = hand.length ? handValue(hand) : '—';
        totalEl.textContent = `Total: ${totalValue}`;
        meta.appendChild(nameEl);
        meta.appendChild(totalEl);
        seat.appendChild(meta);
        playersArea.appendChild(seat);
      });
    }

    dealerTotal.textContent = state.hideDealerHole && dealerHand.length
      ? `${cardValue(dealerHand[0])} +`
      : handValue(dealerHand);

    const bankValue = typeof state.banks?.[clientId] === 'number'
      ? state.banks[clientId]
      : (typeof me.bank === 'number' ? me.bank : 1000);
    bankEl.textContent = bankValue;

    if(transientStatus && Date.now() < transientStatus.until){
      statusEl.textContent = transientStatus.message;
      statusEl.classList.add('show');
    }else if(state.status){
      const visible = !state.statusUntil || state.statusUntil > Date.now();
      statusEl.textContent = state.status;
      statusEl.classList.toggle('show', visible);
    }else{
      statusEl.classList.remove('show');
    }

    if(state.phase === 'waiting'){
      setButtons('deal');
    }else if(state.phase === 'player' && state.activePlayer === clientId){
      setButtons('player');
    }else{
      setButtons('lock');
    }
  }

  function shareStatus(msg, duration=1400){
    tableState.state.status = msg;
    tableState.state.statusUntil = Date.now() + duration;
  }

  function handleBlackjack(playerHand, dealerHand){
    const pv = handValue(playerHand);
    const dv = handValue(dealerHand);
    if(pv !== 21) return false;
    const me = getPlayerEntry();
    let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
    if(dv === 21){
      shareStatus('Push — both Blackjack', 1500);
    }else{
      bank += 150;
      shareStatus('Blackjack! +150', 1500);
    }
    tableState.state.phase = 'waiting';
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.banks[clientId] = bank;
    me.bank = bank;
    return true;
  }

  function resolveRound(){
    const me = getPlayerEntry();
    const playerHand = me.hand || [];
    const dealerHand = tableState.dealer || [];
    const pv = handValue(playerHand);
    const dv = handValue(dealerHand);
    let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
    let msg = '';
    if(dv>21){ bank += 100; msg = 'Dealer busts — You win +100'; }
    else if(pv>dv){ bank += 100; msg = 'You win +100'; }
    else if(pv<dv){ bank -= 100; msg = 'You lose -100'; }
    else { msg = 'Push'; }
    tableState.state.phase = 'waiting';
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.banks[clientId] = bank;
    me.bank = bank;
    shareStatus(msg, 1500);
    commitRound();
    renderTable();
  }

  function dealerPlay(){
    const draw = ()=>{
      const dealerHand = tableState.dealer || [];
      const dv = handValue(dealerHand);
      const hasAce = dealerHand.some(c=>c.rank === 'A');
      const shouldHit = dv < 17 || (dv === 17 && hasAce && handValue(dealerHand) === 17);
      if(shouldHit){
        setTimeout(()=>{
          tableState.dealer = [...dealerHand, drawFromShoe()];
          commitRound();
          renderTable();
          draw();
        }, 420);
      }else{
        resolveRound();
      }
    };
    draw();
  }

  function startDeal(){
    if(tableState.state.phase !== 'waiting' || !isMyTurn()) return;
    const me = getPlayerEntry();
    me.hand = [];
    tableState.dealer = [];

    ensureShoe();
    tableState.dealer = [drawFromShoe(), drawFromShoe()];
    me.hand = [drawFromShoe(), drawFromShoe()];

    tableState.state.phase = 'player';
    tableState.state.activePlayer = clientId;
    tableState.state.hideDealerHole = true;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;

    if(handleBlackjack(me.hand, tableState.dealer)){
      commitRound();
      renderTable();
      return;
    }

    commitRound();
    renderTable();
  }

  function playerHit(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    me.hand = [...(me.hand||[]), drawFromShoe()];
    tableState.state.status = '';
    tableState.state.statusUntil = 0;

    const total = handValue(me.hand);
    if(total > 21){
      let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
      bank -= 100;
      tableState.state.banks[clientId] = bank;
      me.bank = bank;
      tableState.state.phase = 'waiting';
      tableState.state.activePlayer = null;
      tableState.state.hideDealerHole = false;
      shareStatus('Bust!', 1500);
    }
    commitRound();
    renderTable();
  }

  function playerStand(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    tableState.state.phase = 'dealer';
    tableState.state.hideDealerHole = false;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    commitRound();
    renderTable();
    dealerPlay();
  }

  function newShoe(){
    tableState.shoe = buildShoe(6);
    shareStatus('New shoe ready', 700);
    commitRound({ includeDealer:false, includePlayer:false, includeShoe:true });
    renderTable();
  }

  function resetLocalTable(){
    tableState.shoe = [];
    tableState.dealer = [];
    tableState.players = {};
    tableState.state = { ...defaultState, banks: {} };
  }

  function detachListeners(){
    unsubscribers.forEach(unsub => {
      try {
        unsub && unsub();
      } catch (err) {
        console.warn('Failed to detach listener', err);
      }
    });
    unsubscribers = [];
  }

  function attachListeners(){
    if(!isMultiplayer) return;
    detachListeners();
    if(!shoeRef || !dealerRef || !playersRef || !stateRef) return;

    unsubscribers.push(onValue(shoeRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      if(data && data.cards){
        tableState.shoe = normalizeCards(data.cards);
      }
      renderTable();
    }));

    unsubscribers.push(onValue(dealerRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.dealer = normalizeCards(data?.hand);
      renderTable();
    }));

    unsubscribers.push(onValue(playersRef, snapshot=>{
      const data = snapshot.val() || {};
      const previousPlayers = { ...tableState.players };
      const currentIds = new Set(Object.keys(data));
      for(const id of currentIds){
        if(!knownPlayers.has(id) && id !== clientId){
          showStatus(`${data[id]?.name || 'Player'} joined`, 1000);
        }
      }
      for(const id of knownPlayers){
        if(!currentIds.has(id) && id !== clientId){
          const name = previousPlayers[id]?.name || 'Player';
          showStatus(`${name} left`, 1000);
        }
      }
      knownPlayers = currentIds;
      const parsed = {};
      for(const [id, info] of Object.entries(data)){
        parsed[id] = {
          ...info,
          hand: normalizeCards(info.hand)
        };
      }
      tableState.players = parsed;
      renderTable();
    }));

    unsubscribers.push(onValue(stateRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.state = { ...defaultState, ...(data || {}) };
      if(!tableState.state.banks) tableState.state.banks = {};
      renderTable();
    }));
  }

  function sanitizePlayerName(value){
    if(!value) return '';
    return String(value)
      .replace(/[^a-zA-Z0-9 _-]/g, '')
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, 16);
  }

  function sanitizeRoomCode(value){
    const cleaned = String(value || '').replace(/[^a-zA-Z0-9]/g, '').slice(0, 12);
    if(!cleaned) return '';
    if(cleaned.length <= 5){
      return cleaned.toUpperCase();
    }
    return cleaned.toLowerCase();
  }

  function generateRoomCode(){
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for(let i=0; i<5; i++){
      code += chars[Math.floor(Math.random()*chars.length)];
    }
    return code;
  }

  function startSingleplayer(){
    const previousPath = tablePath;
    const wasMultiplayer = isMultiplayer;
    detachListeners();
    if(wasMultiplayer && previousPath){
      const cleanup = {};
      cleanup[`${previousPath}/players/${clientId}`] = null;
      cleanup[`${previousPath}/state/banks/${clientId}`] = null;
      update(rootRef, cleanup).catch(()=>{});
    }
    isMultiplayer = false;
    roomId = null;
    tablePath = '';
    shoeRef = dealerRef = playersRef = stateRef = presenceRef = null;
    knownPlayers = new Set();
    resetLocalTable();
    const me = getPlayerEntry();
    me.name = playerName;
    me.bank = 1000;
    me.hand = [];
    me.status = 'solo';
    tableState.state.banks[clientId] = me.bank;
    tableState.state.phase = 'waiting';
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    window.location.hash = '';
    setButtons('deal');
    renderTable();
  }

  async function startMultiplayer(code, { host=false }={}){
    const sanitized = sanitizeRoomCode(code);
    if(!sanitized) return false;
    if(!nameIsValid){
      playerNameInput?.focus();
      return false;
    }
    const previousPath = tablePath;
    const wasMultiplayer = isMultiplayer;
    detachListeners();
    if(wasMultiplayer && previousPath){
      const cleanup = {};
      cleanup[`${previousPath}/players/${clientId}`] = null;
      cleanup[`${previousPath}/state/banks/${clientId}`] = null;
      update(rootRef, cleanup).catch(()=>{});
    }
    resetLocalTable();
    isMultiplayer = true;
    roomId = sanitized;
    tablePath = `tables/${roomId}`;
    shoeRef = ref(db, `${tablePath}/shoe`);
    dealerRef = ref(db, `${tablePath}/dealer`);
    playersRef = ref(db, `${tablePath}/players`);
    stateRef = ref(db, `${tablePath}/state`);
    presenceRef = ref(db, `${tablePath}/players/${clientId}`);
    knownPlayers = new Set();
    window.location.hash = roomId;

    if(host){
      const now = Date.now();
      try{
        await update(rootRef, {
          [`${tablePath}/shoe`]: null,
          [`${tablePath}/dealer`]: null,
          [`${tablePath}/players`]: null,
          [`${tablePath}/state`]: { ...defaultState, updatedBy: clientId, updatedAt: now }
        });
      }catch(err){
        console.warn('Failed to prepare room', err);
      }
    }

    attachListeners();
    renderTable();
    const joined = await joinTable({ skipCapacityCheck: host });
    if(!joined){
      startSingleplayer();
      return false;
    }
    setButtons('deal');
    renderTable();
    return true;
  }

  async function joinTable({ skipCapacityCheck=false }={}){
    if(!isMultiplayer || !tablePath) return true;
    const me = getPlayerEntry();
    me.name = playerName;
    const now = Date.now();
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    tableState.state.banks[clientId] = me.bank ?? 1000;

    if(!skipCapacityCheck && playersRef){
      try{
        const snapshot = await get(playersRef);
        const existing = snapshot.val() || {};
        if(!existing[clientId] && Object.keys(existing).length >= MAX_PLAYERS){
          showStatus('Table is full', 1600);
          return false;
        }
      }catch(err){
        console.warn('Failed to verify table capacity', err);
      }
    }

    const updates = {};
    updates[`${tablePath}/players/${clientId}`] = {
      ...me,
      hand: cloneCards(me.hand),
      updatedBy: clientId,
      updatedAt: now
    };
    updates[`${tablePath}/state/banks/${clientId}`] = tableState.state.banks[clientId];
    updates[`${tablePath}/state/updatedBy`] = clientId;
    updates[`${tablePath}/state/updatedAt`] = now;

    try{
      await update(rootRef, updates);
      onDisconnect(presenceRef).remove().catch(()=>{});
      return true;
    }catch(err){
      console.warn('Failed to join table', err);
      return false;
    }
  }

  const lobbyCards = { lobbyMain, multiplayerCard, hostCard, joinCard };

  function showLobbyCard(id){
    Object.values(lobbyCards).forEach(card => card.classList.add('hidden'));
    const target = lobbyCards[id] || lobbyMain;
    target.classList.remove('hidden');
  }

  function closeLobby(){
    lobby.classList.add('hidden');
  }

  function openLobby(id='lobbyMain'){
    lobby.classList.remove('hidden');
    showLobbyCard(id);
  }

  lobby.querySelectorAll('.back-action').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      showLobbyCard(btn.dataset.target || 'lobbyMain');
    });
  });

  if(playerNameInput){
    const initialValue = sanitizePlayerName(playerName) || playerName;
    playerNameInput.value = initialValue;
    playerNameInput.addEventListener('input', ()=>{
      const sanitized = sanitizePlayerName(playerNameInput.value);
      if(playerNameInput.value !== sanitized){
        playerNameInput.value = sanitized;
      }
      setPlayerDisplayName(sanitized);
    });
    playerNameInput.addEventListener('blur', ()=>{
      setPlayerDisplayName(playerNameInput.value);
    });
  }
  setPlayerDisplayName(playerName);

  btnSingle.addEventListener('click', ()=>{
    startSingleplayer();
    closeLobby();
  });

  btnMultiplayer.addEventListener('click', ()=>{
    showLobbyCard('multiplayerCard');
  });

  btnHost.addEventListener('click', ()=>{
    if(!nameIsValid){
      playerNameInput?.focus();
      return;
    }
    const code = generateRoomCode();
    hostCodeEl.textContent = code;
    hostCodeEl.dataset.code = code;
    showLobbyCard('hostCard');
  });

  btnHostStart.addEventListener('click', async ()=>{
    if(!nameIsValid){
      playerNameInput?.focus();
      return;
    }
    const code = hostCodeEl.dataset.code || hostCodeEl.textContent || '';
    if(!code) return;
    const joined = await startMultiplayer(code, { host: true });
    if(joined){
      closeLobby();
    }else{
      openLobby('hostCard');
    }
  });

  btnJoin.addEventListener('click', ()=>{
    if(!nameIsValid){
      playerNameInput?.focus();
      return;
    }
    joinCodeInput.value = '';
    showLobbyCard('joinCard');
    setTimeout(()=> joinCodeInput.focus(), 50);
  });

  async function requestJoin(){
    const code = sanitizeRoomCode(joinCodeInput.value);
    if(!code){
      joinCodeInput.focus();
      return;
    }
    if(!nameIsValid){
      playerNameInput?.focus();
      return;
    }
    const joined = await startMultiplayer(code);
    if(joined){
      closeLobby();
    }else{
      openLobby('joinCard');
    }
  }

  btnJoinConfirm.addEventListener('click', ()=>{ requestJoin(); });
  joinCodeInput.addEventListener('input', ()=>{
    joinCodeInput.value = sanitizeRoomCode(joinCodeInput.value);
  });
  joinCodeInput.addEventListener('keydown', event=>{
    if(event.key === 'Enter'){
      event.preventDefault();
      requestJoin();
    }
  });

  btnDeal.addEventListener('click', ()=> startDeal());
  btnHit.addEventListener('click', ()=> !btnHit.classList.contains('muted') && playerHit());
  btnStand.addEventListener('click', ()=> !btnStand.classList.contains('muted') && playerStand());
  btnNew.addEventListener('click', ()=> newShoe());

  const initialCode = sanitizeRoomCode(window.location.hash.replace('#',''));
  if(initialCode){
    startMultiplayer(initialCode)
      .then(joined=>{
        if(joined){
          closeLobby();
        }else{
          openLobby('joinCard');
        }
      });
  }else{
    startSingleplayer();
    openLobby('lobbyMain');
  }

  isSupported()
    .then((supported) => {
      if (supported) {
        getAnalytics(app);
      }
    })
    .catch((err) => console.warn('Firebase analytics not supported', err));
</script>
</body>
</html>
