<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blackjack — Aria & Friends Hub</title>
<style>
  :root{
    --felt:#0e4d37;            /* table background */
    --felt-dark:#0a3a2a;
    --line:#154f40;
    --card:#fff;
    --shadow:0 14px 30px rgba(0,0,0,.35);
    --accent:#ffd13b;          /* primary button */
    --accent-2:#161a24;        /* secondary button */
    --text:#e9f1ee;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--text); background:#0b1020; display:grid; place-items:center;
  }
  .back-nav{
    position:fixed; top:18px; right:18px; z-index:10;
  }
  .back-nav__button{
    appearance:none; border:1px solid rgba(233,241,238,.35);
    background:linear-gradient(135deg, rgba(14,23,36,.85), rgba(11,16,30,.92));
    color:var(--text); border-radius:999px; display:inline-flex; align-items:center;
    gap:.4rem; padding:.5rem 1.1rem; font-weight:700; letter-spacing:.04em; cursor:pointer;
    box-shadow:0 18px 32px rgba(0,0,0,.35); transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
  }
  .back-nav__button:hover,
  .back-nav__button:focus-visible{
    transform:translateY(-1px);
    border-color:rgba(255,209,59,.6);
    box-shadow:0 24px 40px rgba(0,0,0,.45);
    outline:none;
  }
  .back-nav__icon{font-size:1.05rem; line-height:1;}
  .table-wrapper{
    width:min(1100px, 96vw);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:clamp(1.4rem, 3vw, 2.2rem);
  }
  .table{
    position:relative; width:100%;
    height:clamp(420px, 58vw, 620px);
    background: radial-gradient(140% 110% at 50% -20%, #2aa784 0, #1b7157 35%, var(--felt) 60%, var(--felt-dark) 98%);
    border-radius:0 0 520px 520px / 0 0 100% 100%;
    box-shadow: var(--shadow);
    overflow:hidden; border:6px solid #0c3024;
  }
  .table::after{
    content:""; position:absolute; inset:20px 32px 26px;
    border:2px dashed rgba(255,255,255,.15);
    border-radius:0 0 480px 480px / 0 0 95% 95%;
    pointer-events:none;
  }
  header{
    position:absolute; top:14px; left:18px; right:18px; display:flex; align-items:center; gap:.75rem;
    z-index:3;
  }
  .brand{font-weight:800; letter-spacing:.08em; opacity:.9}
  .spacer{flex:1}
  .chip{
    font-variant-numeric:tabular-nums;
    background:linear-gradient(#ffe07a, #e3b312);
    color:#2a2100; font-weight:800; padding:.45rem .7rem; border-radius:999px; box-shadow: var(--shadow);
  }
  .turn-indicator{
    background:rgba(0,0,0,.35);
    padding:.45rem .9rem;
    border-radius:999px;
    font-weight:700;
    letter-spacing:.04em;
    text-transform:uppercase;
    font-size:.82rem;
    box-shadow:0 6px 16px rgba(0,0,0,.18);
  }

  /* Lanes */
  .lane{ position:absolute; left:50%; transform:translateX(-50%); width:86%; }
  .dealer.lane{ top:8%; }
  .dealer.lane .spot{
    justify-content:center;
    align-items:flex-start;
  }
  .lane.player-spots{
    position:absolute;
    bottom:22%;
    left:50%;
    transform:translateX(-50%);
    width:82%;
    max-width:820px;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
    gap:clamp(.8rem, 2.6vw, 1.6rem);
    padding:0 clamp(1.2rem, 4vw, 2.4rem);
    pointer-events:none;
  }

  .player-spot{
    position:relative;
    flex:1 1 0;
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:clamp(140px, 20vw, 200px);
    max-width:200px;
    overflow:visible;
  }
  .player-spot::before{
    content:"";
    position:absolute;
    inset:12px 20px 18px;
    border:2px dashed rgba(255,255,255,.18);
    border-radius:46% 46% 54% 54% / 48% 48% 52% 52%;
    opacity:.45;
    pointer-events:none;
    z-index:0;
  }
  .player-spot.empty::before{ opacity:.16; }
  .player-spot.slot-0,
  .player-spot.slot-3{ transform:translateY(26px); }
  .player-spot.slot-1,
  .player-spot.slot-2{ transform:translateY(10px); }

  .bet-tray{
    width:100%;
    background:rgba(11,16,30,.82);
    border:1px solid rgba(255,255,255,.08);
    border-radius:28px;
    box-shadow:0 24px 40px rgba(0,0,0,.4);
    padding:clamp(1.2rem, 3vw, 2rem);
    display:grid;
    grid-template-columns:repeat(4, minmax(160px, 1fr));
    gap:clamp(.9rem, 2.6vw, 1.6rem);
    justify-items:center;
    backdrop-filter:blur(12px);
    -webkit-backdrop-filter:blur(12px);
  }

  .seat-wrapper{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:flex-end;
    min-height:190px;
    width:100%;
    max-width:220px;
  }
  .seat-wrapper.empty{ opacity:.35; }
  .seat-wrapper.slot-0,
  .seat-wrapper.slot-3{ transform:translateY(-6px); }
  .seat-wrapper.slot-1,
  .seat-wrapper.slot-2{ transform:translateY(-14px); }
  .seat-wrapper.slot-0,
  .seat-wrapper.slot-1,
  .seat-wrapper.slot-2,
  .seat-wrapper.slot-3{
    left:auto;
    bottom:auto;
  }

  .player-seat{
    position:relative;
    width:180px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:.4rem;
    padding:.6rem .4rem .8rem;
    border-radius:18px;
    background:rgba(0,0,0,.2);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.07);
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }
  .player-seat.active{
    box-shadow:0 0 18px rgba(255,209,59,.35), inset 0 0 0 2px rgba(255,209,59,.6);
  }
  .player-seat.active .seat-name{
    color:var(--accent);
  }

  .seat-label{
    text-align:center;
    text-shadow:0 2px 8px rgba(0,0,0,.55);
    font-weight:600;
    display:grid;
    gap:.2rem;
  }
  .seat-result{
    font-size:.78rem;
    letter-spacing:.06em;
    text-transform:uppercase;
    font-weight:700;
    opacity:.92;
  }
  .seat-result.win,
  .seat-result.blackjack{
    color:#4ade80;
  }
  .seat-result.bust,
  .seat-result.lose{
    color:#f87171;
  }
  .seat-result.push{
    color:#fbbf24;
  }
  .seat-name{ font-size:1rem; letter-spacing:.02em; }
  .seat-total, .seat-bank{
    font-size:.85rem;
    opacity:.85;
    font-weight:500;
  }
  .seat-bet{
    font-size:.85rem;
    opacity:.85;
    font-weight:600;
  }
  .bet-controls{
    display:flex;
    align-items:center;
    gap:.4rem;
    margin-top:.35rem;
    flex-wrap:wrap;
    justify-content:center;
  }
  .bet-controls .bet-display{
    font-weight:700;
    font-variant-numeric:tabular-nums;
    letter-spacing:.02em;
  }
  .bet-button{
    padding:.35rem .65rem;
    border-radius:12px;
    min-width:0;
    line-height:1;
  }
  .bet-controls .confirm-button{
    flex:1 1 100%;
    margin-top:.1rem;
  }
  .bet-controls .auto-bet-toggle{
    flex:1 1 100%;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:.45rem;
    padding:.35rem .65rem;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.06);
    font-weight:600;
    letter-spacing:.01em;
    cursor:pointer;
    transition:background .18s ease, border-color .18s ease;
  }
  .bet-controls .auto-bet-toggle.active{
    background:rgba(34,197,94,.2);
    border-color:rgba(34,197,94,.45);
  }
  .bet-controls .auto-bet-toggle:not(.active):hover{
    background:rgba(255,255,255,.12);
    border-color:rgba(255,255,255,.28);
  }
  .bet-controls .auto-bet-toggle.active:hover{
    background:rgba(34,197,94,.28);
    border-color:rgba(34,197,94,.55);
  }
  .bet-controls .auto-bet-toggle input{
    width:1.05rem;
    height:1.05rem;
  }
  .bet-controls .auto-bet-toggle .auto-bet-label{
    font-size:.85rem;
  }
  .seat-confirmation{
    font-size:.78rem;
    opacity:.8;
    font-weight:600;
    text-transform:uppercase;
    letter-spacing:.04em;
  }
  .seat-confirmation.ready{
    color:var(--accent);
    opacity:1;
  }

  /* Card */
  .card{
    width:86px; height:124px; border-radius:11px; background:var(--card);
    box-shadow: var(--shadow); position:relative; transition: transform .4s ease, opacity .3s ease;
    display:grid; place-items:center; overflow:hidden; transform-origin:center bottom;
  }
  @media (max-width:720px){
    .card{ width:70px; height:104px; border-radius:9px; }
  }
  .card .svg{ width:96%; height:96%; }
  .back{
    background:repeating-linear-gradient(45deg, #1d2740, #1d2740 10px, #2b3a66 10px, #2b3a66 20px);
    border:3px solid #e5e9f6; position:absolute; inset:0; border-radius:12px;
  }

  /* Spots where cards settle */
  .spot{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    justify-content:flex-end;
    align-items:flex-start;
    padding:12px;
    z-index:1;
  }
  .hand{
    position:relative;
    width:100%;
    min-height:140px;
    display:block;
    overflow:visible;
  }
  .hand .card{
    position:absolute;
    top:0;
    right:0;
    transform:none !important;
  }
  @media (max-width:720px){ .spot{ height:120px; } }

  @media (max-width:720px){
    .lane.player-spots{
      width:90%;
      bottom:24%;
      gap:.8rem;
      padding:0 1rem;
    }
    .player-spot{ min-height:120px; max-width:160px; }
    .bet-tray{ grid-template-columns:repeat(2, minmax(150px, 1fr)); }
    .seat-wrapper{ min-height:150px; max-width:190px; }
    .seat-wrapper.slot-0,
    .seat-wrapper.slot-1,
    .seat-wrapper.slot-2,
    .seat-wrapper.slot-3{ transform:none; }
    .player-spot.slot-0,
    .player-spot.slot-1,
    .player-spot.slot-2,
    .player-spot.slot-3{ transform:none; }
    .spot{ justify-content:center; align-items:center; padding:0; }
    .hand{ min-height:120px; }
    .player-seat{ width:150px; padding:.5rem .35rem .7rem; }
  }

  @media (max-width:520px){
    .lane.player-spots{ bottom:26%; }
    .player-spot{ max-width:140px; }
    .bet-tray{ grid-template-columns:1fr; }
  }

  /* Labels */
  .label{
    position:absolute; left:50%; transform:translateX(-50%);
    text-align:center; text-shadow:0 2px 8px rgba(0,0,0,.5);
  }
  .label.dealer{ top:4%; font-weight:700; opacity:.9 }
  .label.player{ bottom:22%; font-weight:700; opacity:.95 }
  .total{ font-size:1.05rem; opacity:.9 }

  /* Controls */
  .controls{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:6%; display:flex; gap:.6rem; z-index:3; flex-wrap:wrap; justify-content:center;
  }
  button{
    appearance:none; border:0; border-radius:14px; padding:.9rem 1.2rem;
    font-weight:800; box-shadow: var(--shadow); cursor:pointer; transition: transform .05s ease, filter .2s ease, opacity .2s ease;
  }
  button:active{ transform:translateY(1px) scale(.99) }
  .primary{ background:var(--accent); color:#1a1400 }
  .ghost{ background:var(--accent-2); color:#e9ecf5; border:1px solid rgba(255,255,255,.1) }
  .muted{ opacity:.6; pointer-events:none }

  /* Toast / status */
  .status{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:1.6rem; font-weight:800; letter-spacing:.02em; text-align:center;
    text-shadow:0 3px 30px rgba(0,0,0,.55); opacity:0; transition:opacity .2s ease;
    pointer-events:none; max-width:80%;
  }
  .status.show{ opacity:1 }

  .hidden{ display:none !important; }

  .lobby{
    position:fixed; inset:0; z-index:10; display:flex; align-items:center; justify-content:center;
    background:rgba(6,12,24,.8); backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
    padding:1.5rem;
  }
  .lobby-card{
    background:rgba(13,27,44,.92); border:1px solid rgba(255,255,255,.08); border-radius:26px;
    box-shadow:var(--shadow); padding:clamp(1.6rem,4vw,2.6rem); width:min(420px,94vw);
    display:grid; gap:1.1rem; text-align:center;
  }
  .lobby-card h2{ font-size:1.8rem; margin:0; letter-spacing:.04em; }
  .lobby-card p{ margin:0; opacity:.85; line-height:1.4; }
  .lobby-actions{ display:grid; gap:.8rem; }
  .lobby .ghost{ background:rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.18); box-shadow:none; }
  .lobby .ghost:hover{ background:rgba(255,255,255,.14); }
  .lobby .secondary{ background:rgba(0,0,0,.35); color:var(--text); border:1px solid rgba(255,255,255,.15); box-shadow:none; }
  .lobby .secondary:hover{ background:rgba(0,0,0,.5); }
  .lobby .back-action{ font-size:.9rem; font-weight:600; padding:.6rem .9rem; justify-self:center; }
  .code-display{
    font-size:2rem; letter-spacing:.24em; font-weight:800; text-transform:uppercase;
    padding:.8rem 1.2rem; border-radius:22px; background:rgba(0,0,0,.38); border:1px solid rgba(255,255,255,.18);
  }
  .lobby input{
    appearance:none; border-radius:16px; border:1px solid rgba(255,255,255,.18);
    padding:.85rem 1rem; background:rgba(0,0,0,.35); color:var(--text); font-size:1.05rem;
    text-transform:none; letter-spacing:.02em; text-align:left;
  }
  .lobby input.code-input{
    text-transform:uppercase; letter-spacing:.18em; text-align:center;
  }
  .lobby input:focus{ outline:2px solid rgba(255,209,59,.55); outline-offset:3px; }
  .lobby input.invalid{ outline:2px solid rgba(214,69,69,.7); outline-offset:3px; }
</style>
</head>
<body>
  <div class="back-nav" role="navigation" aria-label="Exit to main menu">
    <button type="button" class="back-nav__button" data-home="index.html" onclick="handleBack(event)">
      <span class="back-nav__icon" aria-hidden="true">&#8962;</span>
      <span class="back-nav__text">Exit</span>
    </button>
  </div>
  <div class="lobby" id="lobby">
    <div class="lobby-card" id="lobbyMain">
      <h2>Blackjack Lounge</h2>
      <p>Select how you'd like to play.</p>
      <div class="lobby-actions">
        <button class="primary" id="btnSingleplayer">Singleplayer</button>
        <button class="ghost" id="btnMultiplayer">Multiplayer</button>
      </div>
    </div>
    <div class="lobby-card hidden" id="multiplayerCard">
      <h2>Multiplayer</h2>
      <p>Invite friends with a shared table code.</p>
      <div class="lobby-actions">
        <button class="primary" id="btnHost">Host</button>
        <button class="ghost" id="btnJoin">Join</button>
      </div>
      <button class="secondary back-action" data-target="lobbyMain">Back</button>
    </div>
    <div class="lobby-card hidden" id="hostCard">
      <h2>Host a Table</h2>
      <p>Choose a name and share this code with friends so they can join.</p>
      <input type="text" id="hostNameInput" class="name-input" maxlength="24" autocomplete="name" placeholder="Your name" spellcheck="false" />
      <div class="code-display" id="hostCode">----</div>
      <button class="ghost" id="btnCopyCode">Copy code</button>
      <button class="primary" id="btnHostStart">Enter Table</button>
      <button class="secondary back-action" data-target="multiplayerCard">Back</button>
    </div>
    <div class="lobby-card hidden" id="joinCard">
      <h2>Join a Table</h2>
      <p>Enter your name and the code from your host.</p>
      <input type="text" id="joinNameInput" class="name-input" maxlength="24" autocomplete="name" placeholder="Your name" spellcheck="false" />
      <input type="text" id="joinCodeInput" class="code-input" maxlength="12" autocomplete="off" placeholder="CODE" />
      <div class="lobby-actions">
        <button class="primary" id="btnJoinConfirm">Join Table</button>
        <button class="secondary back-action" data-target="multiplayerCard">Back</button>
      </div>
    </div>
  </div>
  <div class="table-wrapper">
    <div class="table" id="table">
      <header>
        <div class="brand">BLACKJACK • FRIENDS LOUNGE</div>
        <div class="spacer"></div>
        <div class="turn-indicator hidden" id="turnIndicator">Waiting</div>
        <div class="chip">Bank: <span id="bank">1000</span></div>
      </header>

      <div class="label dealer">Dealer • <span class="total" id="dealerTotal">0</span></div>
      <div class="lane dealer">
        <div class="spot" id="dealerSpot"></div>
      </div>

      <div class="lane player-spots" id="playerSpotsLane"></div>

      <div class="status" id="status"></div>

      <div class="controls" id="controls">
        <button class="primary muted" id="btnHit">Hit</button>
        <button class="ghost muted" id="btnStand">Stand</button>
        <button class="primary hidden muted" id="btnNextHand">Next Hand</button>
      </div>
    </div>

    <div class="bet-tray" id="playersLane"></div>
  </div>

  <script>
    function handleBack(event){
      if(event){
        event.preventDefault();
      }

      const home = event?.currentTarget?.dataset?.home || 'index.html';

      const normalizePath = (value) => {
        const url = new URL(value, window.location.origin);
        let path = url.pathname;

        if(path.endsWith('/index.html')){
          path = path.slice(0, -'/index.html'.length) || '/';
        }

        if(path.endsWith('/')){
          path = path.slice(0, -1) || '/';
        }

        return path || '/';
      };

      const currentPath = normalizePath(window.location.pathname || window.location.href);
      const homePath = normalizePath(home);

      if(currentPath === homePath){
        return;
      }

      window.location.href = home;
    }
  </script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
  import { getAnalytics, isSupported } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
  import { getDatabase, ref, onValue, update, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

  /* ---------- Card + Deck ---------- */
  const SUITS = ["♠","♥","♦","♣"];      // Spade, Heart, Diamond, Club
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];

  function buildShoe(decks=6){
    const shoe=[];
    for(let d=0; d<decks; d++){
      for(const s of SUITS){
        for(const r of RANKS){
          shoe.push({suit:s, rank:r});
        }
      }
    }
    for(let i=shoe.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [shoe[i], shoe[j]]=[shoe[j], shoe[i]];
    }
    return shoe;
  }

  /* ---------- Values ---------- */
  function cardValue(card){
    if(!card) return 0;
    if(card.rank==="A") return 11;
    if(["K","Q","J"].includes(card.rank)) return 10;
    return parseInt(card.rank,10);
  }
  function handValue(cards){
    let sum = 0, aces = 0;
    for(const c of cards){
      sum += cardValue(c);
      if(c.rank==="A") aces++;
    }
    while(sum>21 && aces>0){ sum -= 10; aces--; }
    return sum;
  }

  /* ---------- SVG Renderer ---------- */
  function suitColor(s){ return (s==="♥"||s==="♦") ? "#d64545" : "#1f2a44"; }
  function renderSVG(card){
    const s = suitColor(card.suit);
    const rank = card.rank;
    return `
    <svg class="svg" viewBox="0 0 250 350" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="${rank} ${card.suit}">
      <defs>
        <filter id="innerShadow" x="-50%" y="-50%" width="200%" height="200%">
          <feOffset dx="0" dy="2" />
          <feGaussianBlur stdDeviation="2" result="offblur"/>
          <feComposite in="SourceGraphic" in2="offblur" operator="arithmetic" k2="-1" k3="1"/>
        </filter>
      </defs>
      <rect x="4" y="4" rx="22" ry="22" width="242" height="342" fill="#ffffff" filter="url(#innerShadow)"/>
      <rect x="8" y="8" rx="18" ry="18" width="234" height="334" fill="#ffffff"/>
      <g fill="${s}">
        <text x="22" y="40" font-size="44" font-family="ui-monospace, Menlo, Consolas, monospace">${rank}</text>
        <text x="22" y="76" font-size="44">${card.suit}</text>
        <text x="228" y="340" font-size="44" text-anchor="end" transform="rotate(180,228,340)">${rank}</text>
        <text x="228" y="304" font-size="44" text-anchor="end" transform="rotate(180,228,304)">${card.suit}</text>
        <text x="125" y="205" font-size="120" text-anchor="middle" dominant-baseline="middle" opacity=".9">${card.suit}</text>
      </g>
    </svg>`;
  }

  /* ---------- DOM helpers ---------- */
  const dealerSpot = document.getElementById('dealerSpot');
  const playersLane = document.getElementById('playersLane');
  const playerSpotsLane = document.getElementById('playerSpotsLane');
  const dealerTotal = document.getElementById('dealerTotal');
  const statusEl = document.getElementById('status');
  const turnIndicator = document.getElementById('turnIndicator');
  const btnHit = document.getElementById('btnHit');
  const btnStand = document.getElementById('btnStand');
  const btnNextHand = document.getElementById('btnNextHand');
  const bankEl = document.getElementById('bank');
  const lobby = document.getElementById('lobby');
  const lobbyMain = document.getElementById('lobbyMain');
  const multiplayerCard = document.getElementById('multiplayerCard');
  const hostCard = document.getElementById('hostCard');
  const joinCard = document.getElementById('joinCard');
  const hostCodeEl = document.getElementById('hostCode');
  const btnCopyCode = document.getElementById('btnCopyCode');
  const hostNameInput = document.getElementById('hostNameInput');
  const joinCodeInput = document.getElementById('joinCodeInput');
  const joinNameInput = document.getElementById('joinNameInput');
  const btnSingle = document.getElementById('btnSingleplayer');
  const btnMultiplayer = document.getElementById('btnMultiplayer');
  const btnHost = document.getElementById('btnHost');
  const btnJoin = document.getElementById('btnJoin');
  const btnHostStart = document.getElementById('btnHostStart');
  const btnJoinConfirm = document.getElementById('btnJoinConfirm');
  const copyButtonDefaultLabel = btnCopyCode ? btnCopyCode.textContent : '';
  let copyButtonResetTimer = null;

  const MIN_BET = 10;
  const MAX_BET = 90;
  const BET_STEP = 10;
  const ROUND_RESULT_DISPLAY_MS = 3000;
  const TABLE_PHASES = Object.freeze({
    WAITING: 'waiting',
    PLAYER: 'player',
    DEALER: 'dealer',
    SUMMARY: 'summary'
  });
  const LAST_BET_STORAGE_KEY = 'blackjackLastConfirmedBet';
  const AUTO_BET_STORAGE_KEY = 'blackjackAutoBetEnabled';
  let cachedLastConfirmedBet = null;
  let hasLoadedLastConfirmedBet = false;
  let cachedAutoBetEnabled = false;
  let hasLoadedAutoBetPreference = false;

  function sanitizePlayerName(value){
    if(value == null) return '';
    return String(value)
      .replace(/[\r\n\t]+/g, ' ')
      .replace(/\s{2,}/g, ' ')
      .trim()
      .slice(0, 24);
  }

  function rememberPlayerName(name){
    try{
      localStorage.setItem(NAME_STORAGE_KEY, name);
    }catch(err){
      console.debug('Unable to persist player name', err);
    }
  }

  function setPlayerName(name){
    const sanitized = sanitizePlayerName(name);
    if(!sanitized) return false;
    playerName = sanitized;
    rememberPlayerName(playerName);
    if(hostNameInput && document.activeElement !== hostNameInput){
      hostNameInput.value = playerName;
    }
    if(joinNameInput && document.activeElement !== joinNameInput){
      joinNameInput.value = playerName;
    }
    if(tableState.players[clientId]){
      tableState.players[clientId].name = playerName;
    }
    return true;
  }

  function flagInvalidInput(input){
    if(!input) return;
    input.classList.add('invalid');
    setTimeout(()=> input.classList.remove('invalid'), 1600);
  }

  function setButtons(mode){
    const setMuted = (el, ok)=>{
      if(!el) return;
      el.classList.toggle('muted', !ok);
    };
    const setHidden = (el, hidden)=>{
      if(!el) return;
      el.classList.toggle('hidden', hidden);
    };
    switch(mode){
      case 'player':
        setHidden(btnHit, false);
        setHidden(btnStand, false);
        setHidden(btnNextHand, true);
        setMuted(btnHit, true);
        setMuted(btnStand, true);
        setMuted(btnNextHand, false);
        break;
      case 'summary':
        setHidden(btnHit, true);
        setHidden(btnStand, true);
        setHidden(btnNextHand, false);
        setMuted(btnHit, false);
        setMuted(btnStand, false);
        setMuted(btnNextHand, true);
        break;
      default:
        setHidden(btnHit, false);
        setHidden(btnStand, false);
        setHidden(btnNextHand, true);
        setMuted(btnHit, false);
        setMuted(btnStand, false);
        setMuted(btnNextHand, false);
        break;
    }
  }

  let transientStatus = null;
  function showStatus(msg, ms=1100){
    transientStatus = { message: msg, until: Date.now() + ms };
    statusEl.textContent = msg;
    statusEl.classList.add('show');
    setTimeout(()=>{
      if(transientStatus && Date.now() >= transientStatus.until){
        transientStatus = null;
        statusEl.classList.remove('show');
        renderTable();
      }
    }, ms);
  }

  async function copyTextToClipboard(text){
    if(!text) return false;
    if(navigator.clipboard && navigator.clipboard.writeText){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch(err){
        console.warn('Clipboard API failed, falling back', err);
      }
    }
    try{
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      const selection = document.getSelection();
      const previousRange = selection && selection.rangeCount ? selection.getRangeAt(0) : null;
      textarea.select();
      const successful = document.execCommand('copy');
      document.body.removeChild(textarea);
      if(previousRange){
        selection.removeAllRanges();
        selection.addRange(previousRange);
      }
      return successful;
    }catch(err){
      console.warn('Fallback clipboard copy failed', err);
      return false;
    }
  }

  function normalizeCards(list){
    if(Array.isArray(list)){
      return list.filter(Boolean).map(card=>({suit:card.suit, rank:card.rank}));
    }
    if(!list || typeof list !== 'object') return [];
    return Object.keys(list)
      .map(Number)
      .sort((a,b)=>a-b)
      .map(key=>list[key])
      .filter(Boolean)
      .map(card=>({suit:card.suit, rank:card.rank}));
  }

  function renderHand(hand, spot, {hideHole=false}={}){
    spot.innerHTML='';
    const fan = document.createElement('div');
    fan.className = 'hand';
    spot.appendChild(fan);

    if(!hand.length) return;

    let cardWidth = 86;
    let cardHeight = 136;
    let horizontalStep = 28;
    let verticalStep = 20;

    hand.forEach((card, idx)=>{
      const el = document.createElement('div');
      el.className='card';
      const faceDown = hideHole && idx===1;
      el.innerHTML = faceDown ? '<div class="back"></div>' : renderSVG(card);
      fan.appendChild(el);

      if(idx===0){
        const rect = el.getBoundingClientRect();
        if(rect.width) cardWidth = rect.width;
        if(rect.height) cardHeight = rect.height;
        horizontalStep = Math.round(Math.max(20, cardWidth * 0.32));
        verticalStep = Math.round(Math.max(12, cardHeight * 0.18));
      }

      el.style.top = `${idx * verticalStep}px`;
      el.style.right = `${idx * horizontalStep}px`;
      el.style.zIndex = String(100 + idx);
    });

    const stackHeight = cardHeight + (hand.length - 1) * verticalStep;
    const stackWidth = cardWidth + (hand.length - 1) * horizontalStep;
    const isDealer = spot && (spot.id === 'dealerSpot' || spot.classList.contains('dealer-spot'));

    fan.style.minHeight = `${stackHeight}px`;
    fan.style.minWidth = `${stackWidth}px`;

    if(isDealer){
      fan.style.width = `${stackWidth}px`;
      fan.style.margin = '0 auto';
    }else{
      fan.style.removeProperty('width');
      fan.style.removeProperty('margin');
    }
  }

  /* ---------- Firebase ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyDRniZatGeylxphjHQadYjucOcirNBRIdk",
    authDomain: "multiplayer-640ec.firebaseapp.com",
    databaseURL: "https://multiplayer-640ec-default-rtdb.firebaseio.com",
    projectId: "multiplayer-640ec",
    storageBucket: "multiplayer-640ec.firebasestorage.app",
    messagingSenderId: "94914236381",
    appId: "1:94914236381:web:55ab00cc690140180cf034",
    measurementId: "G-V43J1S8RGF"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const rootRef = ref(db);

  const clientId = (crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
  const NAME_STORAGE_KEY = 'blackjackPlayerName';
  const defaultPlayerName = `Player ${clientId.slice(0,4).toUpperCase()}`;
  let playerName = defaultPlayerName;
  try{
    const stored = localStorage.getItem(NAME_STORAGE_KEY);
    const sanitized = sanitizePlayerName(stored);
    if(sanitized){
      playerName = sanitized;
    }
  }catch(err){
    console.debug('Unable to access stored player name', err);
  }

  if(hostNameInput){
    hostNameInput.value = playerName;
  }
  if(joinNameInput){
    joinNameInput.value = playerName;
  }

  let roomId = null;
  let isMultiplayer = false;
  let tablePath = '';
  let shoeRef = null;
  let dealerRef = null;
  let playersRef = null;
  let stateRef = null;
  let presenceRef = null;
  let unsubscribers = [];
  let knownPlayers = new Set();

  const defaultState = {
    phase: TABLE_PHASES.WAITING,
    activePlayer: null,
    hideDealerHole: false,
    banks: {},
    bets: {},
    confirmedBets: {},
    status: '',
    statusUntil: 0,
    turnOrder: [],
    currentTurnIndex: 0
  };

  const tableState = {
    shoe: [],
    dealer: [],
    players: {},
    state: { ...defaultState, banks: {}, bets: {}, confirmedBets: {} }
  };

  function normalizeBet(value){
    const numeric = Number(value);
    if(!Number.isFinite(numeric)) return MIN_BET;
    const stepped = Math.round(numeric / BET_STEP) * BET_STEP;
    return Math.min(MAX_BET, Math.max(MIN_BET, stepped));
  }

  function loadLastConfirmedBet(){
    if(hasLoadedLastConfirmedBet) return cachedLastConfirmedBet;
    hasLoadedLastConfirmedBet = true;
    try{
      const stored = localStorage.getItem(LAST_BET_STORAGE_KEY);
      if(typeof stored === 'string'){
        const trimmed = stored.trim();
        if(trimmed){
          const numeric = Number(trimmed);
          if(Number.isFinite(numeric)){
            cachedLastConfirmedBet = normalizeBet(numeric);
            return cachedLastConfirmedBet;
          }
        }
      }
    }catch(err){
      console.debug('Unable to access stored bet', err);
    }
    cachedLastConfirmedBet = null;
    return cachedLastConfirmedBet;
  }

  function getLastConfirmedBet(){
    return hasLoadedLastConfirmedBet ? cachedLastConfirmedBet : loadLastConfirmedBet();
  }

  function storeLastConfirmedBet(value){
    const normalized = normalizeBet(value);
    cachedLastConfirmedBet = normalized;
    hasLoadedLastConfirmedBet = true;
    try{
      localStorage.setItem(LAST_BET_STORAGE_KEY, String(normalized));
    }catch(err){
      console.debug('Unable to persist last bet', err);
    }
    return normalized;
  }

  function loadAutoBetPreference(){
    if(hasLoadedAutoBetPreference) return cachedAutoBetEnabled;
    hasLoadedAutoBetPreference = true;
    try{
      const stored = localStorage.getItem(AUTO_BET_STORAGE_KEY);
      if(typeof stored === 'string'){
        const trimmed = stored.trim().toLowerCase();
        cachedAutoBetEnabled = trimmed === '1' || trimmed === 'true';
        return cachedAutoBetEnabled;
      }
    }catch(err){
      console.debug('Unable to access auto bet preference', err);
    }
    cachedAutoBetEnabled = false;
    return cachedAutoBetEnabled;
  }

  function isAutoBetEnabled(){
    return hasLoadedAutoBetPreference ? cachedAutoBetEnabled : loadAutoBetPreference();
  }

  function setAutoBetEnabled(value){
    const enabled = !!value;
    cachedAutoBetEnabled = enabled;
    hasLoadedAutoBetPreference = true;
    try{
      localStorage.setItem(AUTO_BET_STORAGE_KEY, enabled ? '1' : '0');
    }catch(err){
      console.debug('Unable to persist auto bet preference', err);
    }
    return enabled;
  }

  function ensureBetsMap(){
    if(!tableState.state.bets){
      tableState.state.bets = {};
    }
    return tableState.state.bets;
  }

  function ensureConfirmedMap(){
    if(!tableState.state.confirmedBets){
      tableState.state.confirmedBets = {};
    }
    return tableState.state.confirmedBets;
  }

  function setBetConfirmed(id, value){
    const map = ensureConfirmedMap();
    if(value){
      map[id] = true;
    }else{
      delete map[id];
    }
    return !!map[id];
  }

  function isBetConfirmed(id){
    return !!tableState.state.confirmedBets && !!tableState.state.confirmedBets[id];
  }

  function setBetForPlayer(id, value){
    const bet = normalizeBet(value);
    ensureBetsMap();
    tableState.state.bets[id] = bet;
    if(tableState.players[id]){
      tableState.players[id].bet = bet;
    }
    return bet;
  }

  function getBetForPlayer(id){
    ensureBetsMap();
    const stored = tableState.state.bets[id];
    if(typeof stored === 'number' && Number.isFinite(stored)){
      const normalized = normalizeBet(stored);
      if(normalized !== stored){
        tableState.state.bets[id] = normalized;
      }
      if(tableState.players[id]){
        tableState.players[id].bet = normalized;
      }
      return normalized;
    }
    const fallback = tableState.players[id]?.bet;
    return setBetForPlayer(id, typeof fallback === 'number' ? fallback : MIN_BET);
  }

  function cloneCards(cards){
    return (cards || []).map(card=>({suit:card.suit, rank:card.rank}));
  }

  function commitRound({includeDealer=true, includePlayer=true, includeShoe=true, includeState=true, extraPlayers=null}={}){
    if(!isMultiplayer || !tablePath){
      renderTable();
      return Promise.resolve();
    }
    const now = Date.now();
    const updates = {};
    if(includeShoe){
      updates[`${tablePath}/shoe`] = {
        cards: cloneCards(tableState.shoe),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includeDealer){
      updates[`${tablePath}/dealer`] = {
        hand: cloneCards(tableState.dealer),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includePlayer && tableState.players[clientId]){
      updates[`${tablePath}/players/${clientId}`] = {
        ...tableState.players[clientId],
        hand: cloneCards(tableState.players[clientId].hand),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(extraPlayers && typeof extraPlayers === 'object'){
      for(const [id, info] of Object.entries(extraPlayers)){
        if(!info) continue;
        if(id === clientId && includePlayer) continue;
        updates[`${tablePath}/players/${id}`] = {
          ...info,
          hand: cloneCards(info.hand),
          updatedBy: clientId,
          updatedAt: now
        };
      }
    }
    if(includeState){
      updates[`${tablePath}/state`] = {
        ...tableState.state,
        updatedBy: clientId,
        updatedAt: now
      };
    }
    return update(rootRef, updates);
  }

  function ensureShoe(){
    if(!Array.isArray(tableState.shoe) || tableState.shoe.length === 0){
      tableState.shoe = buildShoe(6);
      return;
    }
    if(tableState.shoe.length < 40){
      showStatus('Shuffling…', 800);
      tableState.shoe = buildShoe(6);
    }
  }

  function drawFromShoe(){
    ensureShoe();
    const shoe = tableState.shoe;
    const card = shoe.pop();
    tableState.shoe = shoe;
    return card;
  }

  function getPlayerEntry(){
    if(!tableState.players[clientId]){
      tableState.players[clientId] = {
        name: playerName,
        bank: tableState.state.banks?.[clientId] ?? 1000,
        bet: tableState.state.bets?.[clientId] ?? MIN_BET,
        hand: [],
        status: isMultiplayer ? 'online' : 'solo',
        joinedAt: Date.now(),
        roundResult: null
      };
    }else{
      tableState.players[clientId].name = playerName;
      if(!tableState.players[clientId].joinedAt){
        tableState.players[clientId].joinedAt = Date.now();
      }
    }
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    if(typeof tableState.state.banks[clientId] !== 'number'){
      tableState.state.banks[clientId] = tableState.players[clientId].bank ?? 1000;
    }
    setBetForPlayer(clientId, tableState.players[clientId].bet ?? MIN_BET);
    return tableState.players[clientId];
  }

  const SEAT_CLASSES = ['slot-0','slot-1','slot-2','slot-3'];

  function playerEntryComparator([idA, infoA],[idB, infoB]){
    const joinedA = infoA?.joinedAt ?? infoA?.updatedAt ?? 0;
    const joinedB = infoB?.joinedAt ?? infoB?.updatedAt ?? 0;
    if(joinedA !== joinedB){
      return joinedA - joinedB;
    }
    const nameA = (infoA?.name || '').toLowerCase();
    const nameB = (infoB?.name || '').toLowerCase();
    if(nameA !== nameB){
      return nameA.localeCompare(nameB);
    }
    return idA.localeCompare(idB);
  }

  function getSortedPlayerEntries(){
    const entries = Object.entries(tableState.players || {});
    entries.sort(playerEntryComparator);
    return entries;
  }

  function getAutoBetAmount(){
    const lastBet = getLastConfirmedBet();
    if(Number.isFinite(lastBet)){
      return lastBet;
    }
    return MIN_BET;
  }

  function adjustMyBet(delta){
    if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
    const current = getBetForPlayer(clientId);
    const next = normalizeBet(current + delta);
    if(next === current) return;
    setBetForPlayer(clientId, next);
    setBetConfirmed(clientId, false);
    commitRound({ includeDealer:false, includePlayer:false, includeShoe:false, includeState:true });
    renderTable();
  }

  function confirmMyBet(){
    if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
    if(isBetConfirmed(clientId)) return;
    const betValue = getBetForPlayer(clientId);
    storeLastConfirmedBet(betValue);
    setBetConfirmed(clientId, true);
    commitRound({ includeDealer:false, includePlayer:false, includeShoe:false, includeState:true });
    renderTable();
  }

  function applyAutoBet(){
    if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
    const amount = getAutoBetAmount();
    setBetForPlayer(clientId, amount);
    storeLastConfirmedBet(amount);
    setBetConfirmed(clientId, true);
    commitRound({ includeDealer:false, includePlayer:false, includeShoe:false, includeState:true });
    renderTable();
  }

  function renderSeats(state){
    if(!playersLane || !playerSpotsLane) return;
    const entries = getSortedPlayerEntries();
    const myIndex = entries.findIndex(([id])=>id === clientId);
    if(myIndex === -1){
      const me = tableState.players[clientId];
      if(me){
        entries.push([clientId, me]);
        entries.sort(playerEntryComparator);
      }
    }else if(myIndex >= SEAT_CLASSES.length){
      const [meEntry] = entries.splice(myIndex,1);
      entries.splice(SEAT_CLASSES.length - 1, 0, meEntry);
    }

    const seatsToRender = entries.slice(0, SEAT_CLASSES.length);
    playersLane.innerHTML = '';
    playerSpotsLane.innerHTML = '';

    SEAT_CLASSES.forEach((slotClass, index)=>{
      const wrapper = document.createElement('div');
      wrapper.className = `seat-wrapper ${slotClass}`;
      const spotWrapper = document.createElement('div');
      spotWrapper.className = `player-spot ${slotClass}`;
      const spot = document.createElement('div');
      spot.className = 'spot';
      spotWrapper.appendChild(spot);
      playerSpotsLane.appendChild(spotWrapper);
      const entry = seatsToRender[index];
      if(entry){
        const [id, info] = entry;
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        if(state.activePlayer === id){
          seat.classList.add('active');
        }

        const confirmed = isBetConfirmed(id);

        const hand = Array.isArray(info?.hand) ? info.hand : [];
        renderHand(hand, spot);

        const label = document.createElement('div');
        label.className = 'seat-label';

        const phase = typeof state.phase === 'string' ? state.phase : TABLE_PHASES.WAITING;
        const reviewPhase = phase === TABLE_PHASES.WAITING || phase === TABLE_PHASES.SUMMARY;
        const resultKey = reviewPhase
          ? String(info?.roundResult || '').toLowerCase()
          : '';
        if(resultKey){
          const resultMap = {
            blackjack: 'Blackjack!',
            bust: 'Bust',
            win: 'Win',
            lose: 'Lose',
            push: 'Push'
          };
          const resultText = resultMap[resultKey] || (resultKey.charAt(0).toUpperCase() + resultKey.slice(1));
          const resultEl = document.createElement('div');
          resultEl.className = `seat-result ${resultKey}`.trim();
          resultEl.textContent = resultText;
          label.appendChild(resultEl);
        }

        const nameEl = document.createElement('div');
        nameEl.className = 'seat-name';
        nameEl.textContent = info?.name || `Player ${id.slice(0,4).toUpperCase()}`;
        label.appendChild(nameEl);

        const totalEl = document.createElement('div');
        totalEl.className = 'seat-total';
        totalEl.textContent = hand.length ? `Total: ${handValue(hand)}` : 'Waiting for deal';
        label.appendChild(totalEl);

        const bankValue = typeof state.banks?.[id] === 'number'
          ? state.banks[id]
          : (typeof info?.bank === 'number' ? info.bank : 1000);
        const bankLabel = document.createElement('div');
        bankLabel.className = 'seat-bank';
        bankLabel.textContent = `Bank: ${bankValue}`;
        label.appendChild(bankLabel);

        const betValue = getBetForPlayer(id);
        const betLabel = document.createElement('div');
        betLabel.className = 'seat-bet';
        betLabel.textContent = `Bet: ${betValue}`;
        label.appendChild(betLabel);

        const confirmLabel = document.createElement('div');
        confirmLabel.className = 'seat-confirmation';
        if(reviewPhase){
          if(confirmed){
            confirmLabel.textContent = 'Ready';
            confirmLabel.classList.add('ready');
          }else{
            confirmLabel.textContent = 'Waiting';
          }
        }else{
          confirmLabel.textContent = 'In round';
        }
        label.appendChild(confirmLabel);

        seat.appendChild(label);

        if(id === clientId){
          const controls = document.createElement('div');
          controls.className = 'bet-controls';

          const decreaseBtn = document.createElement('button');
          decreaseBtn.type = 'button';
          decreaseBtn.className = 'bet-button ghost';
          decreaseBtn.textContent = '−';
          decreaseBtn.dataset.betAction = 'decrease';
          decreaseBtn.dataset.playerId = id;

          const betDisplay = document.createElement('div');
          betDisplay.className = 'bet-display';
          betDisplay.textContent = betValue;

          const increaseBtn = document.createElement('button');
          increaseBtn.type = 'button';
          increaseBtn.className = 'bet-button primary';
          increaseBtn.textContent = '+';
          increaseBtn.dataset.betAction = 'increase';
          increaseBtn.dataset.playerId = id;

          const canAdjustBet = phase === TABLE_PHASES.WAITING;
          decreaseBtn.classList.toggle('muted', !canAdjustBet || betValue <= MIN_BET);
          increaseBtn.classList.toggle('muted', !canAdjustBet || betValue >= MAX_BET);

          const autoBetAmount = getAutoBetAmount();
          const autoToggle = document.createElement('label');
          autoToggle.className = 'auto-bet-toggle';
          const autoCheckbox = document.createElement('input');
          autoCheckbox.type = 'checkbox';
          autoCheckbox.dataset.betAction = 'auto-toggle';
          autoCheckbox.dataset.playerId = id;
          autoCheckbox.checked = isAutoBetEnabled();
          autoCheckbox.disabled = !canAdjustBet;
          const autoText = document.createElement('span');
          autoText.className = 'auto-bet-label';
          autoText.textContent = `Auto Bet (${autoBetAmount})`;
          autoToggle.appendChild(autoCheckbox);
          autoToggle.appendChild(autoText);
          autoToggle.classList.toggle('active', isAutoBetEnabled());
          autoToggle.classList.toggle('muted', !canAdjustBet);

          const confirmBtn = document.createElement('button');
          confirmBtn.type = 'button';
          confirmBtn.className = 'bet-button primary confirm-button';
          confirmBtn.textContent = confirmed ? 'Ready' : 'Confirm Bet';
          confirmBtn.dataset.betAction = 'confirm';
          confirmBtn.dataset.playerId = id;
          const canConfirm = canAdjustBet && !confirmed;
          confirmBtn.classList.toggle('muted', !canConfirm);

          controls.appendChild(decreaseBtn);
          controls.appendChild(betDisplay);
          controls.appendChild(increaseBtn);
          controls.appendChild(autoToggle);
          controls.appendChild(confirmBtn);
          seat.appendChild(controls);
        }

        wrapper.appendChild(seat);
      }else{
        wrapper.classList.add('empty');
        spotWrapper.classList.add('empty');
      }
      playersLane.appendChild(wrapper);
    });
  }

  function isMyTurn(){
    const { phase, activePlayer } = tableState.state;
    if(phase === TABLE_PHASES.WAITING) return true;
    if(activePlayer && activePlayer !== clientId) return false;
    return true;
  }

  let autoBlackjackTimer = null;
  let roundTransitionTimer = null;

  function clearRoundTransitionTimer(){
    if(roundTransitionTimer){
      clearTimeout(roundTransitionTimer);
      roundTransitionTimer = null;
    }
  }

  function scheduleRoundAdvance(callback, delay=ROUND_RESULT_DISPLAY_MS){
    clearRoundTransitionTimer();
    roundTransitionTimer = setTimeout(()=>{
      roundTransitionTimer = null;
      callback();
    }, delay);
  }

  function computeTurnOrder(){
    const entries = getSortedPlayerEntries();
    if(!entries.length){
      return [clientId];
    }
    return entries.map(([id])=>id);
  }

  function getActivePlayerEntries(){
    const entries = getSortedPlayerEntries();
    if(!entries.length && tableState.players[clientId]){
      entries.push([clientId, tableState.players[clientId]]);
    }
    return entries.filter(([id, info])=>{
      if(!info) return false;
      const status = String(info.status || '').toLowerCase();
      return status !== 'offline';
    });
  }

  function areAllBetsConfirmed(){
    const entries = getActivePlayerEntries();
    if(!entries.length) return false;
    return entries.every(([id])=> isBetConfirmed(id));
  }

  function isAutoDealController(){
    const entries = getActivePlayerEntries();
    if(!entries.length) return true;
    const [firstId] = entries[0];
    return firstId === clientId;
  }

  function maybeApplyAutoBet(){
    if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
    if(!isAutoBetEnabled()) return;
    if(isBetConfirmed(clientId)) return;
    applyAutoBet();
  }

  function maybeStartAutoDeal(){
    if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
    if(!isAutoDealController()) return;
    if(!areAllBetsConfirmed()) return;
    startDeal();
  }

  function renderTable(){
    const state = tableState.state || defaultState;
    const phase = typeof state.phase === 'string' ? state.phase : TABLE_PHASES.WAITING;
    let me = tableState.players[clientId];
    if(!me){
      me = getPlayerEntry();
    }
    const dealerHand = Array.isArray(tableState.dealer) ? tableState.dealer : [];

    renderHand(dealerHand, dealerSpot, { hideHole: !!state.hideDealerHole });
    renderSeats(state);

    dealerTotal.textContent = state.hideDealerHole && dealerHand.length
      ? `${cardValue(dealerHand[0])} +`
      : handValue(dealerHand);

    const bankValue = typeof state.banks?.[clientId] === 'number'
      ? state.banks[clientId]
      : (typeof me.bank === 'number' ? me.bank : 1000);
    bankEl.textContent = bankValue;

    if(transientStatus && Date.now() < transientStatus.until){
      statusEl.textContent = transientStatus.message;
      statusEl.classList.add('show');
    }else if(state.status){
      const visible = !state.statusUntil || state.statusUntil > Date.now();
      statusEl.textContent = state.status;
      statusEl.classList.toggle('show', visible);
    }else{
      statusEl.classList.remove('show');
    }

    const playerCount = Object.keys(tableState.players || {}).length;
    const isMyTurn = phase === TABLE_PHASES.PLAYER && state.activePlayer === clientId;
    const resolvedHand = ['blackjack', 'bust'].includes(String(me.roundResult || '').toLowerCase());
    if(phase === TABLE_PHASES.SUMMARY){
      setButtons('summary');
    }else if(isMyTurn && !resolvedHand){
      setButtons('player');
    }else{
      setButtons('waiting');
    }

    if(playerCount > 1){
      if(phase === TABLE_PHASES.PLAYER && state.activePlayer){
        const active = tableState.players[state.activePlayer] || {};
        const label = state.activePlayer === clientId ? 'Your turn' : `${active.name || 'Player'}'s turn`;
        turnIndicator.textContent = label;
        turnIndicator.classList.remove('hidden');
      }else if(phase === TABLE_PHASES.DEALER){
        turnIndicator.textContent = "Dealer's turn";
        turnIndicator.classList.remove('hidden');
      }else{
        turnIndicator.textContent = phase === TABLE_PHASES.SUMMARY ? 'Round summary' : 'Waiting for next round';
        turnIndicator.classList.remove('hidden');
      }
    }else{
      turnIndicator.classList.add('hidden');
    }

    if(phase === TABLE_PHASES.WAITING){
      maybeApplyAutoBet();
      maybeStartAutoDeal();
    }

    if(autoBlackjackTimer){
      clearTimeout(autoBlackjackTimer);
      autoBlackjackTimer = null;
    }
    if(state.phase === 'player' && state.activePlayer === clientId){
      autoBlackjackTimer = setTimeout(()=>{
        autoBlackjackTimer = null;
        checkAutoBlackjack();
      }, 120);
    }
  }

  function shareStatus(msg, duration=1400){
    tableState.state.status = msg;
    tableState.state.statusUntil = Date.now() + duration;
  }

  function checkAutoBlackjack(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    if(me.roundResult === 'blackjack') return;
    const hand = me.hand || [];
    if(handValue(hand) !== 21) return;
    applyBlackjackForCurrent();
  }

  function applyBlackjackForCurrent(){
    const dealerHand = tableState.dealer || [];
    const me = getPlayerEntry();
    const dv = handValue(dealerHand);
    const bet = getBetForPlayer(clientId);
    const payout = Math.round(bet * 1.5);
    let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
    let message = '';
    if(dv === 21){
      message = me.name === 'You'
        ? 'Push — both Blackjack'
        : `${me.name || 'Player'} pushes with Blackjack`;
    }else{
      bank += payout;
      message = me.name === 'You'
        ? `Blackjack! +${payout}`
        : `${me.name || 'Player'} Blackjack! +${payout}`;
    }
    tableState.state.banks[clientId] = bank;
    me.bank = bank;
    me.roundResult = 'blackjack';
    shareStatus(message, ROUND_RESULT_DISPLAY_MS);
    commitRound();
    renderTable();
    scheduleRoundAdvance(()=>{
      const hasNext = finishTurn(clientId);
      commitRound();
      renderTable();
      if(!hasNext){
        dealerPlay();
      }
    });
  }

  function resolveRound(){
    const dealerHand = tableState.dealer || [];
    const dv = handValue(dealerHand);
    const banks = tableState.state.banks || {};
    const extraPlayers = {};
    let myMessage = '';
    const multiplePlayers = Object.keys(tableState.players || {}).length > 1;

    for(const [id, player] of Object.entries(tableState.players || {})){
      if(!player) continue;
      const result = player.roundResult;
      const hand = player.hand || [];
      let bank = typeof banks[id] === 'number' ? banks[id] : (typeof player.bank === 'number' ? player.bank : 1000);
      let message = '';
      const bet = getBetForPlayer(id);

      const displayName = player.name || 'Player';
      const isYou = displayName === 'You';

      if(result === 'blackjack'){
        message = isYou ? 'Blackjack!' : `${displayName} Blackjack!`;
      }else if(result === 'bust'){
        message = isYou ? `You bust -${bet}` : `${displayName} busts -${bet}`;
      }else{
        const pv = handValue(hand);
        if(dv > 21 || pv > dv){
          bank += bet;
          message = isYou ? `You win +${bet}` : `${displayName} wins +${bet}`;
          player.roundResult = 'win';
        }else if(pv < dv){
          bank -= bet;
          message = isYou ? `You lose -${bet}` : `${displayName} loses -${bet}`;
          player.roundResult = 'lose';
        }else{
          message = isYou ? 'You push' : `${displayName} pushes`;
          player.roundResult = 'push';
        }
        banks[id] = bank;
        player.bank = bank;
      }

      if(id !== clientId){
        extraPlayers[id] = player;
      }else{
        myMessage = message;
      }
    }

    tableState.state.banks = banks;
    tableState.state.phase = TABLE_PHASES.SUMMARY;
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.turnOrder = [];
    tableState.state.currentTurnIndex = 0;

    const sharedMessage = multiplePlayers ? 'Round complete' : (myMessage || 'Round complete');
    const duration = ROUND_RESULT_DISPLAY_MS;
    tableState.state.status = sharedMessage;
    tableState.state.statusUntil = Date.now() + duration;
    if(multiplePlayers && myMessage){
      showStatus(myMessage, duration);
    }

    const commitOptions = { includePlayer: !!tableState.players[clientId], extraPlayers: Object.keys(extraPlayers).length ? extraPlayers : null };
    commitRound(commitOptions);
    renderTable();
  }

  function enterBettingPhase(){
    const state = tableState.state || defaultState;
    if(state.phase !== TABLE_PHASES.SUMMARY) return;

    clearRoundTransitionTimer();
    transientStatus = null;

    tableState.state.phase = TABLE_PHASES.WAITING;
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.turnOrder = [];
    tableState.state.currentTurnIndex = 0;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    tableState.state.confirmedBets = {};

    tableState.dealer = [];

    const extraPlayers = {};
    for(const [id, player] of Object.entries(tableState.players || {})){
      if(!player) continue;
      const updated = {
        ...player,
        hand: [],
        roundResult: null
      };
      tableState.players[id] = updated;
      if(id !== clientId){
        extraPlayers[id] = updated;
      }
    }

    renderTable();
    const commitOptions = {
      includeDealer: true,
      includePlayer: !!tableState.players[clientId],
      includeShoe: false,
      includeState: true,
      extraPlayers: Object.keys(extraPlayers).length ? extraPlayers : null
    };
    commitRound(commitOptions);
  }

  function dealerPlay(){
    const draw = ()=>{
      const dealerHand = tableState.dealer || [];
      const dv = handValue(dealerHand);
      const hasAce = dealerHand.some(c=>c.rank === 'A');
      const shouldHit = dv < 17 || (dv === 17 && hasAce && handValue(dealerHand) === 17);
      if(shouldHit){
        setTimeout(()=>{
          tableState.dealer = [...dealerHand, drawFromShoe()];
          commitRound();
          renderTable();
          draw();
        }, 420);
      }else{
        resolveRound();
      }
    };
    draw();
  }

  function finishTurn(playerId){
    const state = tableState.state;
    let order = Array.isArray(state.turnOrder) ? state.turnOrder.slice() : [];
    if(!order.length){
      order = computeTurnOrder();
      state.turnOrder = order;
    }
    let currentIndex = order.indexOf(playerId);
    if(currentIndex === -1){
      currentIndex = state.currentTurnIndex || 0;
    }
    for(let nextIndex = currentIndex + 1; nextIndex < order.length; nextIndex++){
      const nextId = order[nextIndex];
      const nextPlayer = tableState.players[nextId];
      if(!nextPlayer) continue;
      if(nextPlayer.roundResult === 'blackjack' || nextPlayer.roundResult === 'bust') continue;
      const hasHand = Array.isArray(nextPlayer.hand) && nextPlayer.hand.length;
      if(!hasHand) continue;
      state.currentTurnIndex = nextIndex;
      state.activePlayer = nextId;
      state.phase = 'player';
      state.hideDealerHole = true;
      return true;
    }
    state.currentTurnIndex = order.length;
    state.activePlayer = null;
    state.phase = 'dealer';
    state.hideDealerHole = false;
    return false;
  }

  function startDeal(){
    if(tableState.state.phase !== TABLE_PHASES.WAITING || !isMyTurn()) return;
    ensureShoe();

    const players = tableState.players || {};
    const order = computeTurnOrder();
    if(!order.includes(clientId)){
      order.unshift(clientId);
    }

    const playersToWrite = {};

    tableState.dealer = [drawFromShoe(), drawFromShoe()];

    for(const id of order){
      const existing = players[id] || {};
      const hand = [drawFromShoe(), drawFromShoe()];
      const betValue = getBetForPlayer(id);
      const updated = {
        ...existing,
        hand,
        roundResult: null,
        status: isMultiplayer ? 'online' : (existing.status || 'solo'),
        bet: betValue
      };
      if(typeof updated.bank !== 'number'){
        updated.bank = tableState.state.banks?.[id] ?? 1000;
      }
      if(!updated.joinedAt){
        updated.joinedAt = Date.now();
      }
      tableState.players[id] = updated;
      playersToWrite[id] = updated;
      if(!tableState.state.banks){
        tableState.state.banks = {};
      }
      if(typeof tableState.state.banks[id] !== 'number'){
        tableState.state.banks[id] = updated.bank;
      }
      setBetForPlayer(id, betValue);
    }

    tableState.state.phase = 'player';
    tableState.state.activePlayer = order[0];
    tableState.state.turnOrder = order;
    tableState.state.currentTurnIndex = 0;
    tableState.state.hideDealerHole = true;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    tableState.state.confirmedBets = {};

    const extraPlayers = { ...playersToWrite };
    if(extraPlayers[clientId]){
      delete extraPlayers[clientId];
    }

    commitRound({ includePlayer: !!tableState.players[clientId], extraPlayers: Object.keys(extraPlayers).length ? extraPlayers : null });
    renderTable();
  }

  function playerHit(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    me.hand = [...(me.hand||[]), drawFromShoe()];
    tableState.state.status = '';
    tableState.state.statusUntil = 0;

    const total = handValue(me.hand);
    if(total > 21){
      let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
      const bet = getBetForPlayer(clientId);
      bank -= bet;
      tableState.state.banks[clientId] = bank;
      me.bank = bank;
      me.roundResult = 'bust';
      const bustMsgName = me.name === 'You'
        ? `You bust -${bet}`
        : `${me.name || 'Player'} busts -${bet}`;
      shareStatus(bustMsgName, ROUND_RESULT_DISPLAY_MS);
      commitRound();
      renderTable();
      scheduleRoundAdvance(()=>{
        const hasNext = finishTurn(clientId);
        commitRound();
        renderTable();
        if(!hasNext){
          dealerPlay();
        }
      });
      return;
    }
    commitRound();
    renderTable();
  }

  function playerStand(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    me.roundResult = 'stand';
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    const hasNext = finishTurn(clientId);
    commitRound();
    renderTable();
    if(!hasNext){
      dealerPlay();
    }
  }

  function resetLocalTable(){
    tableState.shoe = [];
    tableState.dealer = [];
    tableState.players = {};
    tableState.state = { ...defaultState, banks: {}, bets: {}, confirmedBets: {} };
  }

  function detachListeners(){
    unsubscribers.forEach(unsub => {
      try {
        unsub && unsub();
      } catch (err) {
        console.warn('Failed to detach listener', err);
      }
    });
    unsubscribers = [];
  }

  function attachListeners(){
    if(!isMultiplayer) return;
    detachListeners();
    if(!shoeRef || !dealerRef || !playersRef || !stateRef) return;

    unsubscribers.push(onValue(shoeRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      if(data && data.cards){
        tableState.shoe = normalizeCards(data.cards);
      }
      renderTable();
    }));

    unsubscribers.push(onValue(dealerRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.dealer = normalizeCards(data?.hand);
      renderTable();
    }));

    unsubscribers.push(onValue(playersRef, snapshot=>{
      const data = snapshot.val() || {};
      const previousPlayers = { ...tableState.players };
      const currentIds = new Set(Object.keys(data));
      for(const id of currentIds){
        if(!knownPlayers.has(id) && id !== clientId){
          showStatus(`${data[id]?.name || 'Player'} joined`, 1000);
        }
      }
      for(const id of knownPlayers){
        if(!currentIds.has(id) && id !== clientId){
          const name = previousPlayers[id]?.name || 'Player';
          showStatus(`${name} left`, 1000);
        }
      }
      knownPlayers = currentIds;
      const parsed = {};
      for(const [id, info] of Object.entries(data)){
        parsed[id] = {
          ...info,
          hand: normalizeCards(info.hand)
        };
        if(typeof info?.bet === 'number'){
          parsed[id].bet = normalizeBet(info.bet);
        }
      }
      tableState.players = parsed;
      for(const id of Object.keys(parsed)){
        setBetForPlayer(id, parsed[id]?.bet ?? tableState.state.bets?.[id] ?? MIN_BET);
      }
      renderTable();
    }));

    unsubscribers.push(onValue(stateRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.state = { ...defaultState, ...(data || {}) };
      if(!tableState.state.banks) tableState.state.banks = {};
      if(!tableState.state.bets) tableState.state.bets = {};
      if(!tableState.state.confirmedBets) tableState.state.confirmedBets = {};
      renderTable();
    }));
  }

  function sanitizeRoomCode(value){
    const cleaned = String(value || '').replace(/[^a-zA-Z0-9]/g, '').slice(0, 12);
    if(!cleaned) return '';
    if(cleaned.length <= 5){
      return cleaned.toUpperCase();
    }
    return cleaned.toLowerCase();
  }

  function generateRoomCode(){
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for(let i=0; i<5; i++){
      code += chars[Math.floor(Math.random()*chars.length)];
    }
    return code;
  }

  function startSingleplayer(){
    const previousPath = tablePath;
    const wasMultiplayer = isMultiplayer;
    detachListeners();
    if(wasMultiplayer && previousPath){
      const cleanup = {};
      cleanup[`${previousPath}/players/${clientId}`] = null;
      cleanup[`${previousPath}/state/banks/${clientId}`] = null;
      cleanup[`${previousPath}/state/bets/${clientId}`] = null;
      update(rootRef, cleanup).catch(()=>{});
    }
    isMultiplayer = false;
    roomId = null;
    tablePath = '';
    shoeRef = dealerRef = playersRef = stateRef = presenceRef = null;
    knownPlayers = new Set();
    resetLocalTable();
    const me = getPlayerEntry();
    me.name = playerName || 'You';
    me.bank = 1000;
    const betValue = setBetForPlayer(clientId, me.bet ?? MIN_BET);
    me.bet = betValue;
    me.hand = [];
    me.status = 'solo';
    me.roundResult = null;
    tableState.state.banks[clientId] = me.bank;
    tableState.state.bets[clientId] = betValue;
    tableState.state.phase = TABLE_PHASES.WAITING;
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    tableState.state.turnOrder = [];
    tableState.state.currentTurnIndex = 0;
    tableState.state.confirmedBets = {};
    window.location.hash = '';
    setButtons('waiting');
    renderTable();
  }

  function startMultiplayer(code, { host=false }={}){
    const sanitized = sanitizeRoomCode(code);
    if(!sanitized) return;
    detachListeners();
    resetLocalTable();
    isMultiplayer = true;
    roomId = sanitized;
    tablePath = `tables/${roomId}`;
    shoeRef = ref(db, `${tablePath}/shoe`);
    dealerRef = ref(db, `${tablePath}/dealer`);
    playersRef = ref(db, `${tablePath}/players`);
    stateRef = ref(db, `${tablePath}/state`);
    presenceRef = ref(db, `${tablePath}/players/${clientId}`);
    knownPlayers = new Set();
    window.location.hash = roomId;

    if(host){
      const now = Date.now();
      update(rootRef, {
        [`${tablePath}/shoe`]: null,
        [`${tablePath}/dealer`]: null,
        [`${tablePath}/players`]: null,
        [`${tablePath}/state`]: { ...defaultState, updatedBy: clientId, updatedAt: now }
      }).catch(err=>console.warn('Failed to prepare room', err));
    }

    attachListeners();
    joinTable();
    setButtons('waiting');
    renderTable();
  }

  function joinTable(){
    if(!isMultiplayer || !tablePath) return;
    const me = getPlayerEntry();
    const betValue = getBetForPlayer(clientId);
    me.bet = betValue;
    const now = Date.now();
    const updates = {};
    updates[`${tablePath}/players/${clientId}`] = {
      ...me,
      hand: cloneCards(me.hand),
      updatedBy: clientId,
      updatedAt: now
    };
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    tableState.state.banks[clientId] = me.bank ?? 1000;
    updates[`${tablePath}/state/banks/${clientId}`] = tableState.state.banks[clientId];
    if(!tableState.state.bets){
      tableState.state.bets = {};
    }
    tableState.state.bets[clientId] = betValue;
    updates[`${tablePath}/state/bets/${clientId}`] = betValue;
    if(!tableState.state.confirmedBets){
      tableState.state.confirmedBets = {};
    }
    delete tableState.state.confirmedBets[clientId];
    updates[`${tablePath}/state/confirmedBets/${clientId}`] = null;
    updates[`${tablePath}/state/updatedBy`] = clientId;
    updates[`${tablePath}/state/updatedAt`] = now;
    update(rootRef, updates).catch(err=>console.warn('Failed to join table', err));
    onDisconnect(presenceRef).remove().catch(()=>{});
  }

  const lobbyCards = { lobbyMain, multiplayerCard, hostCard, joinCard };

  function showLobbyCard(id){
    Object.values(lobbyCards).forEach(card => card.classList.add('hidden'));
    const target = lobbyCards[id] || lobbyMain;
    target.classList.remove('hidden');
  }

  function closeLobby(){
    lobby.classList.add('hidden');
  }

  function openLobby(id='lobbyMain'){
    lobby.classList.remove('hidden');
    showLobbyCard(id);
  }

  lobby.querySelectorAll('.back-action').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      showLobbyCard(btn.dataset.target || 'lobbyMain');
    });
  });

  btnSingle.addEventListener('click', ()=>{
    startSingleplayer();
    closeLobby();
  });

  btnMultiplayer.addEventListener('click', ()=>{
    showLobbyCard('multiplayerCard');
  });

  btnHost.addEventListener('click', ()=>{
    const code = generateRoomCode();
    hostCodeEl.textContent = code;
    hostCodeEl.dataset.code = code;
    if(hostNameInput){
      hostNameInput.value = playerName;
      hostNameInput.classList.remove('invalid');
    }
    if(btnCopyCode){
      clearTimeout(copyButtonResetTimer);
      copyButtonResetTimer = null;
      btnCopyCode.textContent = copyButtonDefaultLabel || 'Copy code';
    }
    showLobbyCard('hostCard');
    setTimeout(()=>{
      if(hostNameInput){
        hostNameInput.focus();
        hostNameInput.select();
      }
    }, 50);
  });

  btnHostStart.addEventListener('click', ()=>{
    const code = hostCodeEl.dataset.code || hostCodeEl.textContent || '';
    if(!code) return;
    if(hostNameInput){
      const name = sanitizePlayerName(hostNameInput.value);
      if(!name){
        flagInvalidInput(hostNameInput);
        hostNameInput.focus();
        return;
      }
      setPlayerName(name);
    }
    startMultiplayer(code, { host: true });
    closeLobby();
  });

  btnJoin.addEventListener('click', ()=>{
    joinCodeInput.value = '';
    if(joinNameInput){
      joinNameInput.value = playerName;
      joinNameInput.classList.remove('invalid');
    }
    showLobbyCard('joinCard');
    setTimeout(()=>{
      if(joinNameInput){
        joinNameInput.focus();
        joinNameInput.select();
      }else{
        joinCodeInput.focus();
      }
    }, 50);
  });

  function requestJoin(){
    const code = sanitizeRoomCode(joinCodeInput.value);
    if(joinNameInput){
      const name = sanitizePlayerName(joinNameInput.value);
      if(!name){
        flagInvalidInput(joinNameInput);
        joinNameInput.focus();
        return;
      }
      setPlayerName(name);
    }
    if(!code){
      joinCodeInput.focus();
      return;
    }
    startMultiplayer(code);
    closeLobby();
  }

  btnJoinConfirm.addEventListener('click', requestJoin);
  if(hostNameInput){
    hostNameInput.addEventListener('input', ()=> hostNameInput.classList.remove('invalid'));
    hostNameInput.addEventListener('keydown', event=>{
      if(event.key === 'Enter'){
        event.preventDefault();
        btnHostStart.click();
      }
    });
  }
  joinCodeInput.addEventListener('input', ()=>{
    joinCodeInput.value = sanitizeRoomCode(joinCodeInput.value);
  });
  joinCodeInput.addEventListener('keydown', event=>{
    if(event.key === 'Enter'){
      event.preventDefault();
      requestJoin();
    }
  });
  if(joinNameInput){
    joinNameInput.addEventListener('input', ()=> joinNameInput.classList.remove('invalid'));
    joinNameInput.addEventListener('keydown', event=>{
      if(event.key === 'Enter'){
        event.preventDefault();
        joinCodeInput.focus();
      }
    });
  }

  if(btnCopyCode){
    btnCopyCode.addEventListener('click', async ()=>{
      const code = (hostCodeEl.dataset.code || hostCodeEl.textContent || '').trim();
      if(!code || !/[^-]/.test(code)){
        return;
      }
      const success = await copyTextToClipboard(code);
      btnCopyCode.blur();
      btnCopyCode.textContent = success ? 'Copied!' : 'Press Ctrl+C to copy';
      clearTimeout(copyButtonResetTimer);
      copyButtonResetTimer = setTimeout(()=>{
        btnCopyCode.textContent = copyButtonDefaultLabel || 'Copy code';
      }, success ? 1600 : 2600);
    });
  }

  btnHit.addEventListener('click', ()=> !btnHit.classList.contains('muted') && playerHit());
  btnStand.addEventListener('click', ()=> !btnStand.classList.contains('muted') && playerStand());
  btnNextHand.addEventListener('click', ()=>{
    if(btnNextHand.classList.contains('muted') || btnNextHand.classList.contains('hidden')) return;
    enterBettingPhase();
  });

  if(playersLane){
    playersLane.addEventListener('click', event=>{
      const button = event.target.closest('[data-bet-action]');
      if(!button) return;
      if(button.dataset.playerId !== clientId) return;
      if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
      const action = button.dataset.betAction;
      if(action === 'auto-toggle') return;
      event.preventDefault();
      if(action === 'increase'){
        adjustMyBet(BET_STEP);
      }else if(action === 'decrease'){
        adjustMyBet(-BET_STEP);
      }else if(action === 'confirm'){
        confirmMyBet();
      }
    });
    playersLane.addEventListener('change', event=>{
      const control = event.target.closest('[data-bet-action]');
      if(!control) return;
      if(control.dataset.playerId !== clientId) return;
      if(control.dataset.betAction !== 'auto-toggle') return;
      if(tableState.state.phase !== TABLE_PHASES.WAITING) return;
      const checked = !!event.target.checked;
      setAutoBetEnabled(checked);
      if(checked){
        applyAutoBet();
      }else{
        renderTable();
      }
    });
  }

  const initialCode = sanitizeRoomCode(window.location.hash.replace('#',''));
  if(initialCode){
    startMultiplayer(initialCode);
    closeLobby();
  }else{
    startSingleplayer();
    openLobby('lobbyMain');
  }

  isSupported()
    .then((supported) => {
      if (supported) {
        getAnalytics(app);
      }
    })
    .catch((err) => console.warn('Firebase analytics not supported', err));
</script>
</body>
</html>
