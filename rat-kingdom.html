<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rat Kingdom — HTML Prototype</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#0b0e12; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial; }
  canvas { image-rendering: pixelated; image-rendering: crisp-edges; display:block; margin:0 auto; background:#000; border:1px solid #1a1f27; }
  #hud {
    position:fixed; left:12px; top:10px; color:#eaeaea; font-size:12px; line-height:1.5; user-select:none;
    text-shadow: 0 1px 0 #000;
  }
  #hud .pill { display:inline-block; padding:4px 8px; margin:0 6px 6px 0; border-radius:10px; background:#151a22; border:1px solid #212734; }
  #hud .gold { background:#1b1607; border-color:#362e0f; }
  #help {
    position:fixed; right:12px; top:10px; color:#c9d1d9; font-size:12px; max-width:46ch; padding:8px 10px; border-radius:10px; border:1px solid #1f2633; background:#10151d; opacity:.95; user-select:none;
  }
  #toast {
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; color:#f0f6fc; font-size:12px; padding:8px 12px; background:#0f1720; border:1px solid #1e293b; border-radius:8px; opacity:0; transition:opacity .25s ease;
  }
  .show { opacity:1 !important; }
  a { color:#83c2ff; text-decoration:none; border-bottom:1px dashed #83c2ff55; }
  .back-nav {
    position:fixed; top:16px; left:16px; z-index:30;
  }
  .back-nav__link {
    display:inline-flex; align-items:center; gap:.45rem;
    padding:.55rem 1.1rem; border-radius:999px;
    font-weight:600; letter-spacing:.04em; text-decoration:none;
    color:#eaeaea; background:rgba(9,14,22,.85);
    border:1px solid rgba(255,255,255,.18);
    box-shadow:0 16px 28px rgba(0,0,0,.45);
    transition:transform .18s ease, border-color .18s ease, box-shadow .18s ease;
    cursor:pointer;
    font:inherit;
  }
  .back-nav__link:hover,
  .back-nav__link:focus-visible {
    transform:translateY(-1px);
    border-color:rgba(255,255,255,.32);
    box-shadow:0 22px 36px rgba(0,0,0,.55);
    outline:none;
  }
  .back-nav__icon { font-size:1rem; line-height:1; }
</style>
</head>
<body>
<nav class="back-nav" aria-label="Return to main menu">
  <button class="back-nav__link" type="button" data-back-button aria-label="Back">
    <span class="back-nav__icon" aria-hidden="true">⟵</span>
    <span>Back</span>
  </button>
</nav>
<canvas id="game" width="384" height="216"></canvas>

<div id="hud"></div>
<div id="help">
  <strong>Rat Kingdom (HTML Prototype)</strong><br>
  A/D or ←/→ move • Shift sprint • 1–5 select build • <b>E</b> build • <b>R</b> upgrade • <b>F</b> toggle grid<br>
  <b>G</b> save • <b>L</b> load • <b>M</b> multiplayer (if Firebase loaded) • <b>Esc</b> cancel
</div>
<div id="toast"></div>

<script>
const backButton = document.querySelector('[data-back-button]');
if (backButton) {
  backButton.addEventListener('click', () => {
    if (window.history.length <= 1) {
      window.location.href = 'index.html';
    } else {
      window.history.back();
    }
  });
}

(() => {
  // =========================
  // Config & Constants
  // =========================
  const INTERNAL_W = 384, INTERNAL_H = 216;   // low-res internal buffer (16:9)
  const WORLD_LEFT = -1800, WORLD_RIGHT = 1800;
  const GROUND_Y = 150;
  const GRAVITY = 0.45;

  const START_GOLD = 10;
  const SLOT_SPACING = 24;        // build slots every N pixels
  const FRONTIER_STEP = 8 * SLOT_SPACING; // each Outpost expands territory by this
  const WAVE_SECONDS = 45;        // time between waves
  const ENEMY_PER_WAVE_BASE = 4;  // scales with wave
  const ENEMY_HP_BASE = 8;        // scales with wave
  const ENEMY_SPEED = 0.35;
  const GOLD_DROP_MIN = 1, GOLD_DROP_MAX = 2;

  const BUILD = {
    None: 0, Wall: 1, Catapult: 2, Farm: 3, Barracks: 4, Outpost: 5
  };

  const BUILD_INFO = {
    [BUILD.Wall]:     { name:"Wall",     cost: 3,  hp: 30,  upCost:[3,5], upHP:[50,70] },
    [BUILD.Catapult]: { name:"Catapult", cost: 6,  hp: 20,  range: 110, fireRate: 2.2, dmg: 4, upCost:[4,6], upRange:[130,150], upFR:[1.8,1.4], upDMG:[6,8], upHP:[30,40] },
    [BUILD.Farm]:     { name:"Farm",     cost: 5,  hp: 18,  tick: 6, yield: 2, upCost:[3,4], upTick:[5,4], upYield:[3,4], upHP:[24,30] },
    [BUILD.Barracks]: { name:"Barracks", cost: 7,  hp: 25,  spawnT: 8, maxAlly: 4, upCost:[4,6], upSpawn:[6,5], upMax:[6,8], upHP:[35,45] },
    [BUILD.Outpost]:  { name:"Outpost",  cost: 8,  hp: 28 }
  };

  // =========================
  // State
  // =========================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  // Fit canvas to window with integer scale
  function fitCanvas() {
    const scale = Math.max(1, Math.floor(Math.min(window.innerWidth / INTERNAL_W, window.innerHeight / INTERNAL_H)));
    canvas.style.width = (INTERNAL_W * scale) + 'px';
    canvas.style.height = (INTERNAL_H * scale) + 'px';
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  const hud = document.getElementById('hud');
  const toastEl = document.getElementById('toast');

  function toast(msg, ms=1400){ toastEl.textContent = msg; toastEl.classList.add('show'); clearTimeout(toastEl._t); toastEl._t = setTimeout(()=>toastEl.classList.remove('show'), ms); }

  // Input
  const keys = new Map();
  const input = { left:false, right:false, sprint:false, build:false, upgrade:false, grid:false };
  window.addEventListener('keydown', e => { keys.set(e.code, true); });
  window.addEventListener('keyup', e => { keys.set(e.code, false); });

  // Camera / Day-Night
  let camX = 0, camY = 0;
  let dayClock = 0, dayLength = 120; // seconds

  // Player (Rat hero)
  const rat = {
    x: 0, y: GROUND_Y-10, vx: 0, vy: 0, w: 14, h: 10, dir: 1,
    accel: 0.09, maxV: 1.25, sprintV: 2.0, friction: 0.83, stamina: 100, maxStamina: 100, sprintDrain: 35/60, sprintRegen: 18/60,
    onGround: true
  };

  // Economy / Build selection
  let gold = START_GOLD;
  let selected = BUILD.Wall;
  let showGrid = true;

  // Territory (frontiers from camp)
  const campX = 0;
  let rightFrontier = 8 * SLOT_SPACING;
  let leftFrontier  = 8 * SLOT_SPACING;

  // Terrain undulations
  const ridges = [];
  (function genRidges(){
    for (let i=0;i<48;i++){
      const rx = WORLD_LEFT + Math.random()*(WORLD_RIGHT-WORLD_LEFT);
      const h = 2 + Math.random()*7;
      const w = 60 + Math.random()*120;
      ridges.push({x:rx, w, h});
    }
  })();

  function groundAt(x){
    let y = GROUND_Y;
    for (const r of ridges){
      const t = (x - r.x) / r.w;
      if (t > 0 && t < 1){
        const s = Math.sin(Math.PI * t);
        y -= s * r.h;
      }
    }
    return y;
  }

  // Build slots
  const slots = [];
  for (let x = WORLD_LEFT; x <= WORLD_RIGHT; x += SLOT_SPACING) {
    const gy = groundAt(x) - 1;
    // Skip too near camp log
    if (Math.abs(x - campX) < SLOT_SPACING*2) continue;
    slots.push({ x, y: gy, built: null, level: 0, hp: 0, maxHp: 0, progress: 0, lastTick: 0, cooldown: 0 });
  }

  // Entities
  const coinsOnGround = []; // {x,y,vy}
  const allies = []; // {x,y,vx,dir,hp,maxHp,range,dmg,spd,targetId}
  const enemies = []; // {x,y,vx,dir,hp,maxHp,spd,targetX}

  // Projectiles (catapults etc.)
  const projectiles = []; // {x,y,vx,vy,dmg,ttl}

  // Waves
  let waveNum = 0;
  let timeToNextWave = WAVE_SECONDS;
  let nextWaveSide = -1; // -1 left, +1 right, alternates

  // Parallax background
  const parallax = [
    { speed: .25, color:"#0c1020", blips:randIslands(12, 30,80, 6,26) },
    { speed: .5,  color:"#12182a", blips:randIslands(14, 30,110, 8,36) },
    { speed: .8,  color:"#161f34", blips:randIslands(16, 30,150, 8,40) }
  ];

  function randIslands(n, wmin,wmax, hmin,hmax){
    const arr=[];
    for(let i=0;i<n;i++){
      const x = WORLD_LEFT + Math.random()*(WORLD_RIGHT-WORLD_LEFT);
      const w = wmin + Math.random()*(wmax-wmin);
      const h = hmin + Math.random()*(hmax-hmin);
      arr.push({x,w,h});
    }
    return arr;
  }

  // =========================
  // Building helpers
  // =========================
  function canBuildAt(slot) {
    // Within frontiers?
    const withinRight = slot.x <= (campX + rightFrontier);
    const withinLeft  = slot.x >= (campX - leftFrontier);
    if (!(withinLeft && withinRight)) return false;
    // Slot free?
    if (slot.built) return false;
    // Distance from player reasonable
    if (Math.abs(slot.x - rat.x) > SLOT_SPACING*2.5) return false;
    return true;
  }

  function buildCost(kind, level=0){
    const bi = BUILD_INFO[kind];
    if (!bi) return 0;
    return level === 0 ? bi.cost : (bi.upCost ? bi.upCost[level-1]||999 : 999);
  }

  function placeBuilding(slot, kind){
    const bi = BUILD_INFO[kind];
    slot.built = kind;
    slot.level = 1;
    slot.hp = bi.hp;
    slot.maxHp = bi.hp;
    slot.progress = 0;
    slot.lastTick = 0;
    slot.cooldown = 0;
  }

  function upgradeBuilding(slot){
    if (!slot.built) return false;
    const bi = BUILD_INFO[slot.built];
    if (!bi.upCost || slot.level >= 3) return false;
    slot.level++;
    // Apply per-type upgrades
    if (slot.built === BUILD.Wall){
      const idx = slot.level-2; // 0 or 1
      slot.maxHp = (bi.upHP[idx] || slot.maxHp);
      slot.hp = slot.maxHp;
    } else if (slot.built === BUILD.Catapult){
      const idx = slot.level-2;
      const newHP = bi.upHP[idx] || slot.maxHp;
      slot.maxHp = newHP; slot.hp = newHP;
    } else if (slot.built === BUILD.Farm){
      const idx = slot.level-2;
      slot.maxHp = bi.upHP[idx] || slot.maxHp;
      slot.hp = slot.maxHp;
    } else if (slot.built === BUILD.Barracks){
      const idx = slot.level-2;
      slot.maxHp = bi.upHP[idx] || slot.maxHp;
      slot.hp = slot.maxHp;
    }
    return true;
  }

  // =========================
  // Game Loop
  // =========================
  let last = performance.now(), acc = 0, FIX = 1000/60;

  function loop(now){
    const dt = now - last; last = now; acc += dt;
    while (acc >= FIX){ step(FIX/1000); acc -= FIX; }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function step(dt){
    readInput();

    // Day-night tint
    dayClock += dt;
    if (dayClock >= dayLength) dayClock -= dayLength;

    // Wave timer
    timeToNextWave -= dt;
    if (timeToNextWave <= 0){
      startWave();
      timeToNextWave = WAVE_SECONDS;
    }

    // Player move
    const tSpeed = (input.sprint && rat.stamina>0) ? rat.sprintV : rat.maxV;
    let ax = 0;
    if (input.left) { ax -= rat.accel; rat.dir = -1; }
    if (input.right){ ax += rat.accel; rat.dir =  1; }
    rat.vx += ax;
    rat.vx = clamp(rat.vx, -tSpeed, tSpeed);
    if (!input.left && !input.right) rat.vx *= rat.friction;
    if (input.sprint && (input.left||input.right) && Math.abs(rat.vx)>rat.maxV*0.95) {
      rat.stamina = Math.max(0, rat.stamina - rat.sprintDrain);
    } else {
      rat.stamina = Math.min(rat.maxStamina, rat.stamina + rat.sprintRegen);
    }
    rat.vy += GRAVITY;
    let nx = clamp(rat.x + rat.vx*3, WORLD_LEFT+16, WORLD_RIGHT-16);
    let gy = groundAt(nx) - rat.h;
    let ny = rat.y + rat.vy;
    if (ny >= gy){ ny = gy; rat.vy = 0; rat.onGround = true; } else rat.onGround = false;
    rat.x = nx; rat.y = ny;

    // Building interactions
    // Build (E)
    if (input.build){
      const slot = closestBuildableSlot();
      if (slot && canBuildAt(slot) && selected !== BUILD.None){
        const cost = buildCost(selected, 0);
        if (gold >= cost){
          gold -= cost;
          placeBuilding(slot, selected);
          if (selected === BUILD.Outpost){
            // Expand frontier based on side
            if (slot.x > campX) rightFrontier = Math.min(rightFrontier + FRONTIER_STEP, (WORLD_RIGHT - campX) - SLOT_SPACING*2);
            else leftFrontier = Math.min(leftFrontier + FRONTIER_STEP, (campX - WORLD_LEFT) - SLOT_SPACING*2);
            toast("Territory expanded!");
          }
          toast(`Built ${BUILD_INFO[selected].name}`);
        } else {
          toast("Not enough gold.");
        }
      }
      keys.set("KeyE", false);
      input.build = false;
    }

    // Upgrade/Repair (R)
    if (input.upgrade){
      const slot = closestOwnedSlot();
      if (slot && slot.built){
        const lvl = slot.level;
        const cost = buildCost(slot.built, lvl);
        if (slot.hp < slot.maxHp) {
          const pay = Math.min(cost, gold);
          slot.hp = clamp(slot.hp + pay*3, 0, slot.maxHp); // repair 3 hp per gold
          gold -= pay;
          toast("Repaired.");
        } else if (gold >= cost){
          if (upgradeBuilding(slot)){
            gold -= cost;
            toast("Upgraded to Lv" + slot.level);
          } else {
            toast("Max level.");
          }
        } else {
          toast("Not enough gold.");
        }
      }
      keys.set("KeyR", false);
      input.upgrade = false;
    }

    // Farms produce
    for (const s of slots){
      if (s.built === BUILD.Farm){
        const bi = BUILD_INFO[BUILD.Farm];
        const tick = (s.level===1)? bi.tick : (s.level===2? bi.upTick[0] : bi.upTick[1]);
        const yieldAmt = (s.level===1)? bi.yield : (s.level===2? bi.upYield[0] : bi.upYield[1]);
        s.lastTick += dt;
        if (s.lastTick >= tick){
          s.lastTick -= tick;
          gold += yieldAmt;
          floatCoin(s.x, s.y-8, yieldAmt);
        }
      }
      // Barracks spawn allies
      if (s.built === BUILD.Barracks){
        s.cooldown -= dt;
        const bi = BUILD_INFO[BUILD.Barracks];
        const maxAlly = (s.level===1)? bi.maxAlly : (s.level===2? bi.upMax[0] : bi.upMax[1]);
        const spawnT  = (s.level===1)? bi.spawnT   : (s.level===2? bi.upSpawn[0] : bi.upSpawn[1]);
        const local = allies.filter(a => Math.abs(a.x - s.x) < 140).length;
        if (s.cooldown <= 0 && local < maxAlly){
          s.cooldown = spawnT;
          spawnAlly(s.x + 6*Math.sign(s.x-campX));
        }
      }
      // Catapult fire
      if (s.built === BUILD.Catapult){
        s.cooldown -= dt;
        const bi = BUILD_INFO[BUILD.Catapult];
        const range = (s.level===1)? bi.range : (s.level===2? bi.upRange[0] : bi.upRange[1]);
        const fireRate = (s.level===1)? bi.fireRate : (s.level===2? bi.upFR[0] : bi.upFR[1]);
        const dmg = (s.level===1)? bi.dmg : (s.level===2? bi.upDMG[0] : bi.upDMG[1]);
        if (s.cooldown <= 0){
          const target = closestEnemyInRange(s.x, range);
          if (target){
            s.cooldown = fireRate;
            fireLob(s.x, s.y-10, target, dmg);
          }
        }
      }
    }

    // Allies behavior
    for (let i=allies.length-1; i>=0; i--){
      const a = allies[i];
      a.vx = a.spd * a.dir;
      // Patrol around nearest defended area (toward wave side if enemies)
      const nearestE = closestEnemyTo(a.x, 140);
      if (nearestE) a.dir = Math.sign(nearestE.x - a.x) || a.dir;
      a.x += a.vx*2.0;
      a.y = groundAt(a.x) - 8;
      // Combat
      if (nearestE && Math.abs(nearestE.x - a.x) < a.range){
        // bite!
        nearestE.hp -= a.dmg * dt * 2.2;
      }
      // death
      if (a.hp <= 0) { allies.splice(i,1); }
    }

    // Enemies
    for (let i=enemies.length-1; i>=0; i--){
      const e = enemies[i];
      // Move toward targetX (camp)
      e.vx = (e.x < e.targetX) ? e.spd : -e.spd;
      e.x += e.vx*2.0;
      e.y = groundAt(e.x) - 8;

      // Collide with walls first
      const wall = nearestBlockingWall(e.x);
      if (wall && Math.abs(wall.x - e.x) < 10){
        // attack wall
        wall.hp -= 6 * dt;
        if (wall.hp <= 0) {
          spawnCoinsAt(wall.x, wall.y-6, randInt(GOLD_DROP_MIN, GOLD_DROP_MAX));
          wall.built = null; wall.level = 0; wall.hp = 0; wall.maxHp = 0; wall.cooldown = 0;
        }
        // enemies slow near walls
        e.x -= e.vx*1.0*dt;
      } else {
        // attack camp if reached
        if (Math.abs(e.x - campX) < 14){
          // steal gold if any
          if (gold>0 && Math.random()<0.015){
            gold--; // enemy steals
          }
        }
      }

      // Hit by allies
      const a = closestAllyTo(e.x, 20);
      if (a) e.hp -= (a.dmg * dt * 2.5);

      // Projectiles hit
      // handled in projectile loop

      if (e.hp <= 0){
        spawnCoinsAt(e.x, e.y-6, randInt(GOLD_DROP_MIN, GOLD_DROP_MAX));
        enemies.splice(i,1);
      }
    }

    // Projectiles
    for (let i=projectiles.length-1; i>=0; i--){
      const p = projectiles[i];
      p.ttl -= dt;
      p.vy += GRAVITY*0.6;
      p.x += p.vx; p.y += p.vy;
      // hit ground?
      if (p.y >= groundAt(p.x)-2){
        // splash damage to nearest enemy
        const target = closestEnemyTo(p.x, 18);
        if (target) target.hp -= p.dmg;
        projectiles.splice(i,1);
        continue;
      }
      // direct hit check
      const hit = closestEnemyToPoint(p.x, p.y, 8);
      if (hit){ hit.hp -= p.dmg; projectiles.splice(i,1); }
      else if (p.ttl <= 0) projectiles.splice(i,1);
    }

    // Coins on ground
    for (let i=coinsOnGround.length-1;i>=0;i--){
      const cg = coinsOnGround[i];
      cg.vy += 0.2;
      cg.y += cg.vy;
      const gy2 = groundAt(cg.x)-2;
      if (cg.y > gy2){ cg.y = gy2; cg.vy *= -0.2; if (Math.abs(cg.vy)<0.25) cg.vy=0; }
      // pickup by player
      if (Math.abs(cg.x - rat.x) < 10 && Math.abs(cg.y - (rat.y-4)) < 10){
        gold += cg.v; coinsOnGround.splice(i,1);
      }
    }

    // Camera
    camX = clamp(rat.x - INTERNAL_W/2, WORLD_LEFT, WORLD_RIGHT - INTERNAL_W);
    camY = 0;

    // Multiplayer (optional; no-op if Firebase not present)
    netStep(dt);
  }

  function readInput(){
    input.left    = !!(keys.get("ArrowLeft")||keys.get("KeyA"));
    input.right   = !!(keys.get("ArrowRight")||keys.get("KeyD"));
    input.sprint  = !!(keys.get("ShiftLeft")||keys.get("ShiftRight"));
    input.build   = !!keys.get("KeyE");
    input.upgrade = !!keys.get("KeyR");
    // Toggle grid
    if (keys.get("KeyF")) { showGrid = !showGrid; keys.set("KeyF",false); }
    // Save/Load
    if (keys.get("KeyG")) { saveGame(); keys.set("KeyG",false); }
    if (keys.get("KeyL")) { loadGame(); keys.set("KeyL",false); }
    if (keys.get("Escape")) { selected = BUILD.None; keys.set("Escape",false); }
    if (keys.get("Digit1")) { selected = BUILD.Wall; keys.set("Digit1",false); }
    if (keys.get("Digit2")) { selected = BUILD.Catapult; keys.set("Digit2",false); }
    if (keys.get("Digit3")) { selected = BUILD.Farm; keys.set("Digit3",false); }
    if (keys.get("Digit4")) { selected = BUILD.Barracks; keys.set("Digit4",false); }
    if (keys.get("Digit5")) { selected = BUILD.Outpost; keys.set("Digit5",false); }
    if (keys.get("KeyM")) { tryStartMultiplayer(); keys.set("KeyM",false); }
  }

  // =========================
  // Waves & Spawning
  // =========================
  function startWave(){
    waveNum++;
    nextWaveSide *= -1; // alternate
    const count = ENEMY_PER_WAVE_BASE + Math.floor(waveNum*0.7);
    const hp    = ENEMY_HP_BASE + Math.floor(waveNum*1.5);
    const startX = (nextWaveSide<0)? (WORLD_LEFT+24) : (WORLD_RIGHT-24);
    for (let i=0;i<count;i++){
      const off = (Math.random()*120-60);
      enemies.push({
        x: startX + off,
        y: groundAt(startX+off)-8,
        vx: 0, dir: nextWaveSide, hp: hp, maxHp: hp,
        spd: ENEMY_SPEED + Math.random()*0.1 + waveNum*0.01,
        targetX: campX
      });
    }
    toast(`Wave ${waveNum} — ${nextWaveSide<0? 'From Left':'From Right'}`);
  }

  function spawnCoinsAt(x,y,c){
    for (let i=0;i<c;i++){
      coinsOnGround.push({x: x+(Math.random()*8-4), y: y+(Math.random()*5-2), vy: -1.2 - Math.random()*0.6, v: 1});
    }
  }
  function floatCoin(x,y,v){
    coinsOnGround.push({x, y, vy:-0.8, v});
  }

  function spawnAlly(x){
    allies.push({
      x, y: groundAt(x)-8, vx:0, dir: (x>campX? -1:1), hp:12, maxHp:12,
      range: 18, dmg: 3, spd: 0.4
    });
  }

  function fireLob(x,y,target,dmg){
    const dx = (target.x - x), dy = (target.y - y);
    // crude lob
    const t = Math.max(22, Math.min(42, Math.abs(dx)));
    projectiles.push({ x, y, vx: dx/t, vy: (dy-(-30))/t, dmg, ttl: 4 });
  }

  // =========================
  // Queries
  // =========================
  function closestBuildableSlot(){
    let best=null, bd=99e9;
    for (const s of slots){
      if (!canBuildAt(s)) continue;
      const d = Math.abs(s.x - rat.x);
      if (d < bd){ bd=d; best=s; }
    }
    return best;
  }
  function closestOwnedSlot(){
    let best=null, bd=24;
    for (const s of slots){
      if (!s.built) continue;
      const d = Math.abs(s.x - rat.x);
      if (d < bd){ bd=d; best=s; }
    }
    return best;
  }
  function nearestBlockingWall(x){
    let best=null, bd=16;
    for (const s of slots){
      if (s.built === BUILD.Wall){
        const d = Math.abs(s.x - x);
        if (d < bd){ bd=d; best=s; }
      }
    }
    return best;
  }
  function closestEnemyInRange(x,range){
    let best=null, bd=range;
    for (const e of enemies){
      const d = Math.abs(e.x - x);
      if (d < bd){ bd=d; best=e; }
    }
    return best;
  }
  function closestEnemyTo(x,range){
    let best=null, bd=range;
    for (const e of enemies){
      const d = Math.abs(e.x - x);
      if (d < bd){ bd=d; best=e; }
    }
    return best;
  }
  function closestEnemyToPoint(x,y,range){
    let best=null, bd=range;
    for (const e of enemies){
      const d = Math.hypot(e.x-x, e.y-y);
      if (d < bd){ bd=d; best=e; }
    }
    return best;
  }
  function closestAllyTo(x,range){
    let best=null, bd=range;
    for (const a of allies){
      const d = Math.abs(a.x - x);
      if (d < bd){ bd=d; best=a; }
    }
    return best;
  }

  // =========================
  // Save / Load
  // =========================
  function snapshot(){
    return {
      gold, waveNum, timeToNextWave, nextWaveSide,
      rightFrontier, leftFrontier,
      slots: slots.map(s => ({ x:s.x, y:s.y, built:s.built, level:s.level, hp:Math.round(s.hp), maxHp:s.maxHp, lastTick:s.lastTick, cooldown:s.cooldown })),
      rat: { x:rat.x, y:rat.y, stamina:rat.stamina }
    };
  }
  function restore(state){
    gold = state.gold ?? gold;
    waveNum = state.waveNum ?? waveNum;
    timeToNextWave = state.timeToNextWave ?? timeToNextWave;
    nextWaveSide = state.nextWaveSide ?? nextWaveSide;
    rightFrontier = state.rightFrontier ?? rightFrontier;
    leftFrontier = state.leftFrontier ?? leftFrontier;
    for (const s of slots){
      const src = state.slots?.find(k => k.x===s.x);
      if (src){
        s.built = src.built; s.level = src.level; s.hp = src.hp; s.maxHp = src.maxHp;
        s.lastTick = src.lastTick || 0; s.cooldown = src.cooldown || 0;
      } else {
        s.built = null; s.level = 0; s.hp = 0; s.maxHp = 0; s.lastTick=0; s.cooldown=0;
      }
    }
    rat.x = state.rat?.x ?? rat.x; rat.y = state.rat?.y ?? rat.y; rat.stamina = state.rat?.stamina ?? rat.stamina;
  }
  function saveGame(){
    localStorage.setItem("ratkingdom_save", JSON.stringify(snapshot()));
    toast("Saved.");
  }
  function loadGame(){
    const s = localStorage.getItem("ratkingdom_save");
    if (!s) { toast("No save."); return; }
    try { restore(JSON.parse(s)); toast("Loaded."); }
    catch{ toast("Load failed."); }
  }
  // autosave occasionally
  setInterval(()=>localStorage.setItem("ratkingdom_save", JSON.stringify(snapshot())), 5000);

  // =========================
  // Drawing
  // =========================
  function draw(){
    // Sky gradient by day phase
    const t = dayClock/dayLength;
    const noon="#6ab7ff", dusk="#f6a26a", night="#0a0b22", dawn="#ffd59b";
    let sky;
    if (t<0.25) sky = mix(dawn, noon, t/0.25);
    else if (t<0.5) sky = mix(noon, dusk, (t-0.25)/0.25);
    else if (t<0.75) sky = mix(dusk, night, (t-0.5)/0.25);
    else sky = mix(night, dawn, (t-0.75)/0.25);
    fillRect(0,0,INTERNAL_W,INTERNAL_H, sky);

    // Parallax
    for (const layer of parallax){
      ctx.fillStyle = layer.color;
      ctx.globalAlpha = .7;
      for (const b of layer.blips){
        const x = Math.floor((b.x - camX) * layer.speed) % (WORLD_RIGHT - WORLD_LEFT);
        ctx.fillRect(x, GROUND_Y - 60 - b.h, b.w, b.h);
      }
      ctx.globalAlpha = 1;
    }

    // Ground fill
    fillRect(0, GROUND_Y, INTERNAL_W, INTERNAL_H-GROUND_Y, "#1b1e24");

    // Ground silhouette based on samples
    ctx.fillStyle = "#2a2f38";
    for (let sx=0; sx<INTERNAL_W; sx++){
      const wx = camX + sx;
      const gy = Math.floor(groundAt(wx));
      ctx.fillRect(sx, gy, 1, INTERNAL_H-gy);
    }

    // Camp marker (log + banner)
    {
      const x = Math.floor(campX - camX), y = Math.floor(groundAt(campX));
      fillRect(x-16, y-6, 32, 6, "#553311");
      fillRect(x+10, y-18, 1, 12, "#888");
      fillRect(x+11, y-18, 8, 5, (waveNum%2)? "#e33" : "#7ab");
    }

    // Slots / structures
    const nearSlot = closestBuildableSlot();
    for (const s of slots){
      const sx = Math.floor(s.x - camX), sy = Math.floor(s.y);
      // frontier masking
      const inTerritory = (s.x <= campX + rightFrontier) && (s.x >= campX - leftFrontier);
      if (showGrid){
        ctx.globalAlpha = inTerritory ? 0.25 : 0.08;
        fillRect(sx-1, sy-7, 2, 6, inTerritory ? "#95a1b3":"#555");
        ctx.globalAlpha = 1;
      }
      if (s.built){
        drawStructure(s, sx, sy);
      }
      // highlight buildable
      if (s===nearSlot){
        strokeRect(sx-6, sy-10, 12, 10, "#7cffa1");
      }
    }

    // Coins
    for (const cg of coinsOnGround){
      const x = Math.floor(cg.x - camX), y = Math.floor(cg.y);
      fillRect(x-1, y-2, 3, 3, "#e6c74c");
    }

    // Allies
    for (const a of allies){
      const x = Math.floor(a.x - camX), y = Math.floor(a.y);
      fillRect(x-4, y-8, 8, 8, "#aaff88"); // body
      // tiny hp bar
      fillRect(x-6, y-12, 12, 2, "#111");
      const hw = Math.max(0, Math.floor(12*(a.hp/a.maxHp)));
      fillRect(x-6, y-12, hw, 2, "#7cff7c");
    }

    // Enemies
    for (const e of enemies){
      const x = Math.floor(e.x - camX), y = Math.floor(e.y);
      fillRect(x-4, y-8, 8, 8, "#8c2aff");
      // hp bar
      fillRect(x-6, y-12, 12, 2, "#111");
      const hw = Math.max(0, Math.floor(12*(e.hp/e.maxHp)));
      fillRect(x-6, y-12, hw, 2, "#ff7699");
    }

    // Projectiles
    for (const p of projectiles){
      const x = Math.floor(p.x - camX), y = Math.floor(p.y);
      fillRect(x-1, y-1, 3, 3, "#d7d0c6");
    }

    // Player
    {
      const x = Math.floor(rat.x - camX), y = Math.floor(rat.y);
      // mouse/rat body
      fillRect(x-7, y-5, 14, 5, "#d0a070");
      // head
      fillRect(rat.dir>0? x+4 : x-6, y-9, 6, 4, "#e6deb7");
      // tail
      fillRect(x-8, y-3, 6, 1, "#bd7a6f");
    }

    // HUD
    const phase = (t<0.25) ? "Dawn" : (t<0.5) ? "Day" : (t<0.75) ? "Dusk" : "Night";
    hud.innerHTML = `
      <span class="pill gold">Gold: ${gold}</span>
      <span class="pill">Wave: ${waveNum}</span>
      <span class="pill">Next: ${Math.ceil(timeToNextWave)}s (${nextWaveSide<0?'Left':'Right'})</span>
      <span class="pill">Territory: L ${Math.floor(leftFrontier/SLOT_SPACING)} • R ${Math.floor(rightFrontier/SLOT_SPACING)}</span>
      <span class="pill">Stamina: ${Math.round(rat.stamina)}</span>
      <span class="pill">Phase: ${phase}</span>
      <span class="pill">Build: ${BUILD_INFO[selected]?.name || 'None'} (Cost ${buildCost(selected)})</span>
    `;
  }

  function drawStructure(s, sx, sy){
    const kind = s.built;
    const lvl = s.level;
    if (kind === BUILD.Wall){
      fillRect(sx-6, sy-8, 12, 8 + (lvl-1)*2, "#6b7079");
    } else if (kind === BUILD.Catapult){
      // base
      fillRect(sx-7, sy-6, 14, 6, "#6a5136");
      // arm
      fillRect(sx-1, sy-12, 2, 6, "#433526");
      // level badge
      fillRect(sx-2, sy-14, 4, 2, lvl===1 ? "#777" : (lvl===2 ? "#e0b84d" : "#d86"));
    } else if (kind === BUILD.Farm){
      fillRect(sx-8, sy-6, 16, 6, "#3c4a2b"); // field base
      // crop rows
      fillRect(sx-7, sy-7, 3, 1, "#a6c26b");
      fillRect(sx-2, sy-7, 3, 1, "#a6c26b");
      fillRect(sx+3, sy-7, 3, 1, "#a6c26b");
      fillRect(sx-2, sy-10, 4, 2, lvl===1 ? "#777" : (lvl===2 ? "#e0b84d" : "#d86"));
    } else if (kind === BUILD.Barracks){
      fillRect(sx-9, sy-8, 18, 8, "#4f5768"); // hut
      fillRect(sx-5, sy-13, 10, 5, "#2b313e"); // roof
      fillRect(sx-2, sy-14, 4, 2, lvl===1 ? "#777" : (lvl===2 ? "#e0b84d" : "#d86"));
    } else if (kind === BUILD.Outpost){
      fillRect(sx-10, sy-10, 20, 10, "#5b5a65"); // tower
      fillRect(sx+6, sy-18, 1, 8, "#999");
      fillRect(sx+7, sy-18, 6, 4, "#c55");
    }
    // hp bar
    fillRect(sx-10, sy-14, 20, 3, "#0b0b0b");
    const hw = Math.max(0, Math.floor(20*(s.hp/Math.max(1,s.maxHp))));
    fillRect(sx-10, sy-14, hw, 3, "#7cff7c");
  }

  // =========================
  // Utilities
  // =========================
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function mix(a,b,k){
    const ca=parseInt(a.slice(1),16), cb=parseInt(b.slice(1),16);
    const ar=(ca>>16)&255, ag=(ca>>8)&255, ab=ca&255;
    const br=(cb>>16)&255, bg=(cb>>8)&255, bb=cb&255;
    const rr=Math.round(ar+(br-ar)*k), rg=Math.round(ag+(bg-ag)*k), rb=Math.round(ab+(bb-ab)*k);
    return `rgb(${rr},${rg},${rb})`;
  }
  function fillRect(x,y,w,h,color){ ctx.fillStyle=color; ctx.fillRect(x,y,w,h); }
  function strokeRect(x,y,w,h,color){ ctx.strokeStyle=color; ctx.strokeRect(x,y,w,h); }
  function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

  // =========================
  // Optional Multiplayer (Firebase Stub)
  // =========================
  // Usage:
  // 1) Include Firebase SDKs before this script (e.g., in <head>):
  //    <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js"><\/script>
  //    <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-database-compat.js"><\/script>
  // 2) Provide your config below in firebaseConfig, uncomment init lines.
  // 3) Press M in-game to host/join a lobby (random id). Position + wave events will sync.
  let net = {
    enabled: false,
    db: null,
    roomId: null,
    lastSend: 0,
  };

  function tryStartMultiplayer(){
    if (!window.firebase || !firebase.apps) { toast("Firebase SDK not detected."); return; }
    if (!net.enabled){
      try {
        // If no apps, initialize (configure with your own project)
        // const firebaseConfig = { apiKey:"", authDomain:"", databaseURL:"", projectId:"", storageBucket:"", messagingSenderId:"", appId:"" };
        // if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        net.db = firebase.database();
        net.roomId = localStorage.getItem("ratking_room") || ("room_" + Math.random().toString(36).slice(2,8));
        localStorage.setItem("ratking_room", net.roomId);
        net.enabled = true;
        subscribeRoom();
        toast("Multiplayer: room " + net.roomId);
      } catch (e){
        toast("Firebase init failed.");
        net.enabled = false;
      }
    } else {
      toast("Multiplayer already on (room " + net.roomId + ")");
    }
  }

  function subscribeRoom(){
    if (!net.db || !net.roomId) return;
    const ref = net.db.ref("ratking/"+net.roomId);
    ref.on("value", snap => {
      const data = snap.val();
      if (!data) return;
      // Simple merges (do not overwrite local slots if you don't want to)
      if (typeof data.waveNum === "number" && data.waveNum > waveNum){
        waveNum = data.waveNum;
        timeToNextWave = data.timeToNextWave ?? timeToNextWave;
        nextWaveSide = data.nextWaveSide ?? nextWaveSide;
      }
      if (data.spawn && Array.isArray(data.spawn)){
        for (const sp of data.spawn){
          if (sp.t === "enemy"){
            enemies.push({
              x: sp.x, y: groundAt(sp.x)-8, vx:0, dir: Math.sign(campX-sp.x), hp: ENEMY_HP_BASE, maxHp: ENEMY_HP_BASE, spd: ENEMY_SPEED, targetX: campX
            });
          }
        }
      }
    });
  }

  function netStep(dt){
    if (!net.enabled || !net.db || !net.roomId) return;
    net.lastSend += dt;
    if (net.lastSend >= 0.2){
      net.lastSend = 0;
      const ref = net.db.ref("ratking/"+net.roomId);
      ref.update({
        rat: { x: Math.round(rat.x), stamina: Math.round(rat.stamina) },
        waveNum, timeToNextWave, nextWaveSide
      }).catch(()=>{ /* ignore */ });
    }
  }

  // =========================
  // Boot
  // =========================
  // Auto-load if present; start with a couple of starting defenses for feel
  if (localStorage.getItem("ratkingdom_save")){
    try { restore(JSON.parse(localStorage.getItem("ratkingdom_save"))); }
    catch {}
  } else {
    // starter walls
    const sLeft = slots.find(s => !s.built && s.x < campX - SLOT_SPACING*2 && s.x > campX - SLOT_SPACING*6);
    const sRight= slots.find(s => !s.built && s.x > campX + SLOT_SPACING*2 && s.x < campX + SLOT_SPACING*6);
    if (sLeft) { placeBuilding(sLeft, BUILD.Wall); sLeft.level=1; sLeft.hp=sLeft.maxHp; }
    if (sRight){ placeBuilding(sRight, BUILD.Wall); sRight.level=1; sRight.hp=sRight.maxHp; }
  }

})(); // end IIFE
</script>
</body>
</html>
