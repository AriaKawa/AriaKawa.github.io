<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <main class="landing">
        <header class="landing__header">
            <h1>Vault</h1>
            <p class="landing__tagline">Choose a path to explore the latest creations.</p>
        </header>
        <nav class="landing__nav" aria-label="Primary">
            <a class="landing__link" href="education.html">
                <span class="landing__label">Education</span>
            </a>
            <a class="landing__link" href="games.html">
                <span class="landing__label">Games</span>
            </a>
            <a class="landing__link" href="in-progress.html">
                <span class="landing__label">In Progress</span>
            </a>
        </nav>
    </main>

    <script>
        (function setupBananaDownload() {
            const button = document.querySelector('[data-download-banana]');
            if (!(button instanceof HTMLButtonElement)) {
                return;
            }

            const defaultLabel = button.textContent?.trim() || 'Download banana';
            const downloadUrl = 'assets/banana.svg';
            const downloadName = 'banana.svg';

            button.addEventListener('click', async () => {
                const restoreLabel = () => {
                    button.textContent = defaultLabel;
                    button.disabled = false;
                };

                button.disabled = true;
                button.textContent = 'Preparing banana…';

                try {
                    const response = await fetch(downloadUrl, { cache: 'no-store' });
                    if (!response.ok) {
                        throw new Error(`Request failed with status ${response.status}`);
                    }

                    const blob = await response.blob();
                    const href = URL.createObjectURL(blob);
                    const anchor = document.createElement('a');
                    anchor.href = href;
                    anchor.download = downloadName;
                    document.body.appendChild(anchor);
                    anchor.click();
                    anchor.remove();
                    URL.revokeObjectURL(href);

                    button.textContent = 'Banana ready!';
                    window.setTimeout(restoreLabel, 1200);
                } catch (error) {
                    console.error('Unable to download banana image', error);
                    button.textContent = 'Download failed. Try again';
                    window.setTimeout(restoreLabel, 1800);
                }
            });
        })();

        (function setupAccountMenu() {
            const menu = document.querySelector('[data-account-menu]');
            if (!menu) {
                return;
            }

            const trigger = menu.querySelector('[data-account-trigger]');
            const dropdown = menu.querySelector('[data-account-dropdown]');
            const signInButton = menu.querySelector('[data-account-action="signin"]');
            const signOutButton = menu.querySelector('[data-account-action="signout"]');

            if (!trigger || !dropdown || !signInButton || !signOutButton) {
                return;
            }

            let isOpen = false;

            function closeMenu(options = {}) {
                const { focusTrigger = false } = options;

                if (!isOpen) {
                    if (focusTrigger) {
                        trigger.focus();
                    }
                    return;
                }

                isOpen = false;
                menu.classList.remove('is-open');
                dropdown.hidden = true;
                trigger.setAttribute('aria-expanded', 'false');
                document.removeEventListener('pointerdown', handlePointerDown, true);
                document.removeEventListener('keydown', handleKeydown, true);

                if (focusTrigger) {
                    trigger.focus();
                }
            }

            function openMenu() {
                if (isOpen) {
                    return;
                }

                isOpen = true;
                dropdown.hidden = false;
                menu.classList.add('is-open');
                trigger.setAttribute('aria-expanded', 'true');

                document.addEventListener('pointerdown', handlePointerDown, true);
                document.addEventListener('keydown', handleKeydown, true);

                const firstAction = dropdown.querySelector('[data-account-action]:not([hidden])');
                if (firstAction instanceof HTMLElement) {
                    window.requestAnimationFrame(() => {
                        firstAction.focus();
                    });
                }
            }

            function handleKeydown(event) {
                if (!isOpen) {
                    return;
                }

                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeMenu({ focusTrigger: true });
                    return;
                }

                if (event.key === 'Tab') {
                    const focusable = Array.from(
                        dropdown.querySelectorAll('[data-account-action]:not([hidden])')
                    );

                    if (focusable.length === 0) {
                        return;
                    }

                    const first = focusable[0];
                    const last = focusable[focusable.length - 1];

                    if (!event.shiftKey && document.activeElement === last) {
                        event.preventDefault();
                        first.focus();
                    } else if (event.shiftKey && document.activeElement === first) {
                        event.preventDefault();
                        last.focus();
                    }
                }
            }

            function handlePointerDown(event) {
                if (!menu.contains(event.target)) {
                    closeMenu();
                }
            }

            menu.__closeAccountMenu = closeMenu;
            menu.__openAccountMenu = openMenu;

            trigger.addEventListener('click', () => {
                if (isOpen) {
                    closeMenu();
                } else {
                    openMenu();
                }
            });

            trigger.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    openMenu();
                }
            });
        })();
        })();
    </script>

    <script type="module">
        import { initializeApp, getApp, getApps } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAnalytics, isSupported } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
        import {
            getAuth,
            GoogleAuthProvider,
            onAuthStateChanged,
            signInWithPopup,
            signOut
        } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getDatabase, ref, set, update, onValue } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDRniZatGeylxphjHQadYjucOcirNBRIdk",
            authDomain: "multiplayer-640ec.firebaseapp.com",
            databaseURL: "https://multiplayer-640ec-default-rtdb.firebaseio.com",
            projectId: "multiplayer-640ec",
            storageBucket: "multiplayer-640ec.firebasestorage.app",
            messagingSenderId: "94914236381",
            appId: "1:94914236381:web:55ab00cc690140180cf034",
            measurementId: "G-V43J1S8RGF"
        };

        const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
        isSupported()
            .then((supported) => {
                if (supported) {
                    getAnalytics(app);
                }
            })
            .catch((err) => console.warn("Firebase analytics not supported", err));

        const database = getDatabase(app);
        const auth = getAuth(app);
        auth.useDeviceLanguage();
        const provider = new GoogleAuthProvider();
        provider.setCustomParameters({ prompt: 'select_account' });

        const outfits = [
            { id: 'classic', name: 'Cozy Classic', description: 'The baseline guild tunic.', price: 0 },
            { id: 'hoodie', name: 'Midnight Hoodie', description: 'Urban stealth with neon trim.', price: 1 },
            { id: 'adventurer', name: 'Adventurer Cape', description: 'Ready for future expeditions.', price: 2 }
        ];

        const avatarCard = document.querySelector('[data-avatar-card]');
        const avatarPreview = avatarCard?.querySelector('.rat-avatar') ?? null;
        const closet = avatarCard?.querySelector('[data-avatar-closet]') ?? null;
        const closetToggle = closet?.querySelector('[data-closet-toggle]') ?? null;
        const closetMenu = closet?.querySelector('[data-closet-menu]') ?? null;
        const closetList = closet?.querySelector('[data-closet-list]') ?? null;
        const closetEmpty = closet?.querySelector('[data-closet-empty]') ?? null;
        const currentOutfitLabel = avatarCard?.querySelector('[data-current-outfit]') ?? null;
        const currencyDisplay = document.querySelector('[data-currency-balance]');
        const currencyAmount = currencyDisplay?.querySelector('[data-currency-amount]') ?? null;

        if (!avatarCard || !avatarPreview || !closet || !closetToggle || !closetMenu || !closetList || !currentOutfitLabel) {
            if (currencyAmount) {
                currencyAmount.textContent = '—';
            }
            setupAccountMenu();
            return;
        }

        const outfitById = new Map(outfits.map((outfit) => [outfit.id, outfit]));
        const closetEntries = new Map();

        outfits.forEach((outfit) => {
            const item = document.createElement('li');
            item.className = 'closet-item';
            item.dataset.outfit = outfit.id;

            const body = document.createElement('div');
            body.className = 'closet-item__body';

            const name = document.createElement('span');
            name.className = 'closet-item__name';
            name.textContent = outfit.name;
            body.appendChild(name);

            if (outfit.description) {
                const description = document.createElement('p');
                description.className = 'closet-item__description';
                description.textContent = outfit.description;
                body.appendChild(description);
            }

            const footer = document.createElement('div');
            footer.className = 'closet-item__footer';

            const status = document.createElement('span');
            status.className = 'closet-item__status';
            status.setAttribute('data-closet-status', '');
            footer.appendChild(status);

            const action = document.createElement('button');
            action.type = 'button';
            action.className = 'closet-item__action';
            action.setAttribute('data-closet-action', '');
            action.textContent = 'Wear';
            footer.appendChild(action);

            item.appendChild(body);
            item.appendChild(footer);
            closetList.appendChild(item);

            closetEntries.set(outfit.id, {
                element: item,
                status,
                button: action
            });
        });

        const defaultOutfit = 'classic';
        const defaultCoins = 1;
        const defaultOwnedOutfits = new Set([defaultOutfit]);

        let coins = defaultCoins;
        let ownedOutfits = new Set(defaultOwnedOutfits);
        let currentOutfit = defaultOutfit;
        let closetIsOpen = false;
        let currentUser = null;
        let applyingRemoteState = false;
        let stopUserListener = null;

        const accountMenu = setupAccountMenu();

        function setupAccountMenu() {
            const menu = document.querySelector('[data-account-menu]');
            const trigger = menu?.querySelector('[data-account-trigger]') ?? null;
            const dropdown = menu?.querySelector('[data-account-dropdown]') ?? null;
            const avatar = menu?.querySelector('[data-account-avatar]') ?? null;
            const nameEl = menu?.querySelector('[data-account-name]') ?? null;
            const statusEl = menu?.querySelector('[data-account-status]') ?? null;
            const signInButton = menu?.querySelector('[data-account-action="signin"]') ?? null;
            const signOutButton = menu?.querySelector('[data-account-action="signout"]') ?? null;

            if (!menu || !trigger || !dropdown || !avatar || !nameEl || !statusEl || !signInButton || !signOutButton) {
                return {
                    onUserChange() {
                        return () => {};
                    },
                    reportSyncStatus() {}
                };
            }

            const listeners = new Set();
            let syncHealthy = true;
            let currentAccount = null;

            function normalizeName(value) {
                if (typeof value !== 'string') {
                    return '';
                }

                return value.replace(/\s+/g, ' ').trim();
            }

            function resolveDisplayName(user) {
                if (!user) {
                    return 'Guest';
                }

                const fromDisplayName = normalizeName(user.displayName ?? '');
                if (fromDisplayName) {
                    return fromDisplayName;
                }

                const fromEmail = normalizeName(user.email ?? '');
                if (fromEmail) {
                    const [first] = fromEmail.split('@');
                    return first ? normalizeName(first) || 'Traveler' : 'Traveler';
                }

                return 'Traveler';
            }

            function getInitial(name) {
                const normalized = normalizeName(name);
                if (!normalized) {
                    return 'G';
                }

                return normalized.charAt(0).toUpperCase();
            }

            function updateUI(user) {
                const displayName = resolveDisplayName(user);
                const isSignedIn = Boolean(user);
                menu.dataset.state = isSignedIn ? 'signed-in' : 'signed-out';
                avatar.textContent = getInitial(displayName);
                nameEl.textContent = displayName;

                const baseStatus = isSignedIn ? 'Signed in' : 'Signed out';
                const statusText = !syncHealthy && isSignedIn ? `${baseStatus} • sync unavailable` : baseStatus;
                statusEl.textContent = statusText;

                signInButton.hidden = isSignedIn;
                signOutButton.hidden = !isSignedIn;

                if (trigger) {
                    const ariaLabel = isSignedIn
                        ? `Open account menu for ${displayName}`
                        : 'Open account menu. You are signed out.';
                    trigger.setAttribute('aria-label', ariaLabel);
                }
            }

            const closeMenu = typeof menu.__closeAccountMenu === 'function'
                ? menu.__closeAccountMenu
                : () => {}
            ;

            signInButton.addEventListener('click', async () => {
                try {
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    console.warn('Sign-in failed', error);
                } finally {
                    closeMenu({ focusTrigger: true });
                }
            });

            signOutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.warn('Sign-out failed', error);
                }

                closeMenu({ focusTrigger: true });
            });

            onAuthStateChanged(auth, (user) => {
                currentAccount = user ?? null;
                updateUI(currentAccount);
                listeners.forEach((listener) => {
                    try {
                        listener(currentAccount);
                    } catch (error) {
                        console.error('Account listener error', error);
                    }
                });
            });

            updateUI(null);

            return {
                onUserChange(listener) {
                    if (typeof listener !== 'function') {
                        return () => {};
                    }

                    listeners.add(listener);
                    listener(currentAccount);
                    return () => {
                        listeners.delete(listener);
                    };
                },
                reportSyncStatus(healthy) {
                    syncHealthy = Boolean(healthy);
                    updateUI(currentAccount);
                }
            };
        }

        function userVaultRef(uid) {
            return ref(database, `users/${uid}/vault`);
        }

        function defaultUserState() {
            return {
                coins: defaultCoins,
                currentOutfit: defaultOutfit,
                ownedOutfits: Array.from(defaultOwnedOutfits)
            };
        }

        function sanitizeState(value) {
            let coinsValue = defaultCoins;
            let outfitValue = defaultOutfit;
            const owned = new Set(defaultOwnedOutfits);

            if (value && typeof value === 'object') {
                const parsedCoins = Number.parseInt(value.coins, 10);
                if (Number.isFinite(parsedCoins) && parsedCoins >= 0) {
                    coinsValue = parsedCoins;
                }

                if (Array.isArray(value.ownedOutfits)) {
                    value.ownedOutfits.forEach((item) => {
                        if (typeof item === 'string' && outfitById.has(item)) {
                            owned.add(item);
                        }
                    });
                }

                if (typeof value.currentOutfit === 'string' && outfitById.has(value.currentOutfit)) {
                    outfitValue = value.currentOutfit;
                }
            }

            owned.add(outfitValue);

            return {
                coins: coinsValue,
                currentOutfit: outfitValue,
                ownedOutfits: owned
            };
        }

        async function syncUserState(partial) {
            if (!currentUser || applyingRemoteState) {
                return;
            }

            try {
                await update(userVaultRef(currentUser.uid), partial);
                accountMenu.reportSyncStatus(true);
            } catch (error) {
                console.warn('Unable to sync wardrobe profile', error);
                accountMenu.reportSyncStatus(false);
            }
        }

        function applyRemoteState(state) {
            applyingRemoteState = true;
            coins = state.coins;
            ownedOutfits = new Set(state.ownedOutfits);
            const applied = applyOutfit(state.currentOutfit);
            ownedOutfits.add(applied);
            applyingRemoteState = false;

            updateCurrencyUI();
            updateClosetUI();
            updateCurrentOutfitSummary();
        }

        function persistCoins(value) {
            coins = value;
            if (!currentUser || applyingRemoteState) {
                return;
            }

            syncUserState({ coins: value });
        }

        function persistOwnedOutfits(owned) {
            if (!currentUser || applyingRemoteState) {
                return;
            }

            const list = Array.from(owned);
            syncUserState({ ownedOutfits: list });
        }

        function persistOutfit(value) {
            currentOutfit = value;
            if (!currentUser || applyingRemoteState) {
                return;
            }

            syncUserState({ currentOutfit: value });
        }

        function updateCurrencyUI() {
            if (!currencyAmount) {
                return;
            }

            const label = coins === 1 ? 'coin' : 'coins';
            currencyAmount.textContent = `${coins} ${label}`;
        }

        function applyOutfit(value) {
            const next = value && outfitById.has(value) ? value : defaultOutfit;
            avatarPreview.dataset.outfit = next;
            currentOutfit = next;
            return next;
        }

        function updateCurrentOutfitSummary() {
            const details = outfitById.get(currentOutfit) ?? outfitById.get(defaultOutfit);
            const fallback = outfitById.get(defaultOutfit)?.name ?? 'Cozy Classic';
            currentOutfitLabel.textContent = `Currently wearing: ${details?.name ?? fallback}`;
        }

        function updateClosetUI() {
            let ownedCount = 0;

            closetEntries.forEach((entry, outfitId) => {
                const owned = ownedOutfits.has(outfitId);
                entry.element.hidden = !owned;
                entry.element.classList.toggle('is-selected', currentOutfit === outfitId);

                if (!owned) {
                    return;
                }

                ownedCount += 1;

                if (entry.status) {
                    entry.status.textContent = currentOutfit === outfitId ? 'Currently wearing' : 'Owned';
                }

                if (entry.button) {
                    entry.button.disabled = currentOutfit === outfitId;
                    entry.button.textContent = currentOutfit === outfitId ? 'Equipped' : 'Wear';
                }
            });

            if (closetEmpty) {
                closetEmpty.hidden = ownedCount > 0;
            }

            const disabled = ownedCount === 0;
            closetToggle.disabled = disabled;
            closetToggle.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        }

        function openCloset() {
            if (closetIsOpen) {
                return;
            }

            closetIsOpen = true;
            closet.classList.add('is-open');
            closetMenu.hidden = false;
            closetToggle.setAttribute('aria-expanded', 'true');

            document.addEventListener('pointerdown', handlePointerDown, true);
            document.addEventListener('keydown', handleClosetKeydown, true);

            const focusable = closetMenu.querySelector('[data-closet-action]:not([disabled])');
            if (focusable instanceof HTMLElement) {
                window.requestAnimationFrame(() => {
                    focusable.focus();
                });
            }
        }

        function closeCloset(options = {}) {
            const { focusToggle = false } = options;

            if (!closetIsOpen) {
                if (focusToggle) {
                    closetToggle.focus();
                }
                return;
            }

            closetIsOpen = false;
            closet.classList.remove('is-open');
            closetMenu.hidden = true;
            closetToggle.setAttribute('aria-expanded', 'false');
            document.removeEventListener('pointerdown', handlePointerDown, true);
            document.removeEventListener('keydown', handleClosetKeydown, true);

            if (focusToggle) {
                closetToggle.focus();
            }
        }

        function handlePointerDown(event) {
            if (!closet.contains(event.target)) {
                closeCloset();
            }
        }

        function handleClosetKeydown(event) {
            if (!closetIsOpen) {
                return;
            }

            if (event.key === 'Escape') {
                event.preventDefault();
                closeCloset({ focusToggle: true });
                return;
            }

            if (event.key === 'Tab') {
                const focusable = Array.from(
                    closetMenu.querySelectorAll('[data-closet-action]:not([disabled])')
                );

                if (focusable.length === 0) {
                    return;
                }

                const first = focusable[0];
                const last = focusable[focusable.length - 1];

                if (!event.shiftKey && document.activeElement === last) {
                    event.preventDefault();
                    first.focus();
                } else if (event.shiftKey && document.activeElement === first) {
                    event.preventDefault();
                    last.focus();
                }
            }
        }

        closetToggle.addEventListener('click', () => {
            if (closetIsOpen) {
                closeCloset();
            } else {
                openCloset();
            }
        });

        closetToggle.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                openCloset();
            }
        });

        closetList.addEventListener('click', (event) => {
            const button = event.target instanceof HTMLElement
                ? event.target.closest('[data-closet-action]')
                : null;

            if (!(button instanceof HTMLButtonElement)) {
                return;
            }

            const item = button.closest('.closet-item');
            if (!item) {
                return;
            }

            const outfit = item.dataset.outfit;
            if (!outfit || !ownedOutfits.has(outfit)) {
                return;
            }

            if (currentOutfit === outfit) {
                closeCloset({ focusToggle: true });
                return;
            }

            const applied = applyOutfit(outfit);
            persistOutfit(applied);
            updateClosetUI();
            updateCurrentOutfitSummary();
            closeCloset({ focusToggle: true });
        });

        const appliedDefault = applyOutfit(defaultOutfit);
        ownedOutfits.add(appliedDefault);
        updateCurrencyUI();
        updateClosetUI();
        updateCurrentOutfitSummary();
        closeCloset();

        accountMenu.onUserChange((user) => {
            currentUser = user ?? null;

            if (stopUserListener) {
                stopUserListener();
                stopUserListener = null;
            }

            applyRemoteState(sanitizeState({}));

            if (!currentUser) {
                accountMenu.reportSyncStatus(true);
                return;
            }

            stopUserListener = onValue(
                userVaultRef(currentUser.uid),
                (snapshot) => {
                    if (!snapshot.exists()) {
                        set(userVaultRef(currentUser.uid), defaultUserState())
                            .then(() => {
                                accountMenu.reportSyncStatus(true);
                            })
                            .catch((error) => {
                                console.warn('Unable to initialize wardrobe profile', error);
                                accountMenu.reportSyncStatus(false);
                            });
                        return;
                    }

                    const sanitized = sanitizeState(snapshot.val());
                    applyRemoteState(sanitized);
                    accountMenu.reportSyncStatus(true);
                },
                (error) => {
                    console.warn('Unable to read wardrobe profile', error);
                    accountMenu.reportSyncStatus(false);
                }
            );
        });
    </script>
</body>
</html>
