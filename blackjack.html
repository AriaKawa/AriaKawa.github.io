<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blackjack — Aria & Friends Hub</title>
<style>
  :root{
    --felt:#0e4d37;            /* table background */
    --felt-dark:#0a3a2a;
    --line:#154f40;
    --card:#fff;
    --shadow:0 14px 30px rgba(0,0,0,.35);
    --accent:#ffd13b;          /* primary button */
    --accent-2:#161a24;        /* secondary button */
    --text:#e9f1ee;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--text); background:#0b1020; display:grid; place-items:center;
  }
  .table{
    position:relative; width:min(1100px, 96vw); aspect-ratio: 16/9;
    background: radial-gradient(120% 90% at 50% -15%, #208b6e 0, var(--felt) 32%, var(--felt-dark) 95%);
    border-radius:28px; box-shadow: var(--shadow);
    overflow:hidden; border:6px solid #0c3024;
  }
  .table::after{
    content:""; position:absolute; inset:20px;
    border:2px dashed rgba(255,255,255,.15); border-radius:22px; pointer-events:none;
  }
  header{
    position:absolute; top:14px; left:18px; right:18px; display:flex; align-items:center; gap:.75rem;
    z-index:3;
  }
  .brand{font-weight:800; letter-spacing:.08em; opacity:.9}
  .spacer{flex:1}
  .chip{
    font-variant-numeric:tabular-nums;
    background:linear-gradient(#ffe07a, #e3b312);
    color:#2a2100; font-weight:800; padding:.45rem .7rem; border-radius:999px; box-shadow: var(--shadow);
  }
  .turn-indicator{
    background:rgba(0,0,0,.35);
    padding:.45rem .9rem;
    border-radius:999px;
    font-weight:700;
    letter-spacing:.04em;
    text-transform:uppercase;
    font-size:.82rem;
    box-shadow:0 6px 16px rgba(0,0,0,.18);
  }

  /* Lanes */
  .lane{ position:absolute; left:50%; transform:translateX(-50%); width:80%; }
  .dealer.lane{ top:10%; }
  .lane.seats{
    bottom:7%;
    width:86%;
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap:1.1rem;
    align-items:end;
    justify-items:center;
    padding:0 1.4rem;
  }

  .seat-wrapper{
    display:flex;
    justify-content:center;
    align-items:flex-end;
    min-height:190px;
    width:100%;
  }
  .seat-wrapper.slot-0{ justify-self:start; }
  .seat-wrapper.slot-1{ justify-self:center; }
  .seat-wrapper.slot-2{ justify-self:center; }
  .seat-wrapper.slot-3{ justify-self:end; }

  .player-seat{
    position:relative;
    width:180px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:.4rem;
    padding:.6rem .4rem .8rem;
    border-radius:18px;
    background:rgba(0,0,0,.2);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.07);
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }
  .player-seat .spot{ width:100%; }
  .player-seat.active{
    box-shadow:0 0 18px rgba(255,209,59,.35), inset 0 0 0 2px rgba(255,209,59,.6);
  }
  .player-seat.active .seat-name{
    color:var(--accent);
  }

  .seat-label{
    text-align:center;
    text-shadow:0 2px 8px rgba(0,0,0,.55);
    font-weight:600;
    display:grid;
    gap:.2rem;
  }
  .seat-name{ font-size:1rem; letter-spacing:.02em; }
  .seat-total, .seat-bank{
    font-size:.85rem;
    opacity:.85;
    font-weight:500;
  }

  /* Card */
  .card{
    width:96px; height:136px; border-radius:12px; background:var(--card);
    box-shadow: var(--shadow); position:absolute; transition: transform .4s ease, top .4s ease, left .4s ease, opacity .3s ease;
    display:grid; place-items:center; overflow:hidden;
  }
  @media (max-width:720px){
    .card{ width:78px; height:112px; border-radius:10px; }
  }
  .card .svg{ width:94%; height:94%; }
  .back{
    background:repeating-linear-gradient(45deg, #1d2740, #1d2740 10px, #2b3a66 10px, #2b3a66 20px);
    border:3px solid #e5e9f6; position:absolute; inset:0; border-radius:12px;
  }

  /* Spots where cards settle */
  .spot{ position:relative; height:150px; display:flex; justify-content:center; }
  .hand{ position:relative; min-height:100%; }
  @media (max-width:720px){ .spot{ height:120px; } }

  @media (max-width:720px){
    .lane.seats{ bottom:8%; gap:.7rem; padding:0 .8rem; }
    .seat-wrapper{ min-height:150px; }
    .player-seat{ width:150px; padding:.5rem .35rem .7rem; }
  }

  /* Labels */
  .label{
    position:absolute; left:50%; transform:translateX(-50%);
    text-align:center; text-shadow:0 2px 8px rgba(0,0,0,.5);
  }
  .label.dealer{ top:4%; font-weight:700; opacity:.9 }
  .label.player{ bottom:6%; font-weight:700; opacity:.95 }
  .total{ font-size:1.05rem; opacity:.9 }

  /* Controls */
  .controls{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:3%; display:flex; gap:.6rem; z-index:3; flex-wrap:wrap; justify-content:center;
  }
  button{
    appearance:none; border:0; border-radius:14px; padding:.9rem 1.2rem;
    font-weight:800; box-shadow: var(--shadow); cursor:pointer; transition: transform .05s ease, filter .2s ease, opacity .2s ease;
  }
  button:active{ transform:translateY(1px) scale(.99) }
  .primary{ background:var(--accent); color:#1a1400 }
  .ghost{ background:var(--accent-2); color:#e9ecf5; border:1px solid rgba(255,255,255,.1) }
  .muted{ opacity:.6; pointer-events:none }

  /* Toast / status */
  .status{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:1.6rem; font-weight:800; letter-spacing:.02em; text-align:center;
    text-shadow:0 3px 30px rgba(0,0,0,.55); opacity:0; transition:opacity .2s ease;
    pointer-events:none; max-width:80%;
  }
  .status.show{ opacity:1 }

  /* Exit link */
  .back-link{
    position:absolute; top:16px; right:20px; z-index:4; display:inline-flex; align-items:center;
    gap:.4rem; font-size:.95rem; text-decoration:none; font-weight:600; color:var(--text);
    background:rgba(0,0,0,.35); padding:.45rem .8rem; border-radius:999px; transition:background .2s ease, transform .2s ease;
  }
  .back-link:hover{ background:rgba(0,0,0,.55); transform:translateY(-1px); }

  .hidden{ display:none !important; }

  .lobby{
    position:fixed; inset:0; z-index:10; display:flex; align-items:center; justify-content:center;
    background:rgba(6,12,24,.8); backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
    padding:1.5rem;
  }
  .lobby-card{
    background:rgba(13,27,44,.92); border:1px solid rgba(255,255,255,.08); border-radius:26px;
    box-shadow:var(--shadow); padding:clamp(1.6rem,4vw,2.6rem); width:min(420px,94vw);
    display:grid; gap:1.1rem; text-align:center;
  }
  .lobby-card h2{ font-size:1.8rem; margin:0; letter-spacing:.04em; }
  .lobby-card p{ margin:0; opacity:.85; line-height:1.4; }
  .lobby-actions{ display:grid; gap:.8rem; }
  .lobby .ghost{ background:rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.18); box-shadow:none; }
  .lobby .ghost:hover{ background:rgba(255,255,255,.14); }
  .lobby .secondary{ background:rgba(0,0,0,.35); color:var(--text); border:1px solid rgba(255,255,255,.15); box-shadow:none; }
  .lobby .secondary:hover{ background:rgba(0,0,0,.5); }
  .lobby .back-action{ font-size:.9rem; font-weight:600; padding:.6rem .9rem; justify-self:center; }
  .code-display{
    font-size:2rem; letter-spacing:.24em; font-weight:800; text-transform:uppercase;
    padding:.8rem 1.2rem; border-radius:22px; background:rgba(0,0,0,.38); border:1px solid rgba(255,255,255,.18);
  }
  .lobby input{
    appearance:none; border-radius:16px; border:1px solid rgba(255,255,255,.18);
    padding:.85rem 1rem; background:rgba(0,0,0,.35); color:var(--text); font-size:1.05rem; text-transform:uppercase;
    text-align:center; letter-spacing:.18em;
  }
  .lobby input:focus{ outline:2px solid rgba(255,209,59,.55); outline-offset:3px; }
</style>
</head>
<body>
  <a class="back-link" href="index.html">← Back to the friend hub</a>
  <div class="lobby" id="lobby">
    <div class="lobby-card" id="lobbyMain">
      <h2>Blackjack Lounge</h2>
      <p>Select how you'd like to play.</p>
      <div class="lobby-actions">
        <button class="primary" id="btnSingleplayer">Singleplayer</button>
        <button class="ghost" id="btnMultiplayer">Multiplayer</button>
      </div>
    </div>
    <div class="lobby-card hidden" id="multiplayerCard">
      <h2>Multiplayer</h2>
      <p>Invite friends with a shared table code.</p>
      <div class="lobby-actions">
        <button class="primary" id="btnHost">Host</button>
        <button class="ghost" id="btnJoin">Join</button>
      </div>
      <button class="secondary back-action" data-target="lobbyMain">Back</button>
    </div>
    <div class="lobby-card hidden" id="hostCard">
      <h2>Host a Table</h2>
      <p>Share this code with friends so they can join.</p>
      <div class="code-display" id="hostCode">----</div>
      <button class="ghost" id="btnCopyCode">Copy code</button>
      <button class="primary" id="btnHostStart">Enter Table</button>
      <button class="secondary back-action" data-target="multiplayerCard">Back</button>
    </div>
    <div class="lobby-card hidden" id="joinCard">
      <h2>Join a Table</h2>
      <p>Enter the code from your host.</p>
      <input type="text" id="joinCodeInput" maxlength="12" autocomplete="off" placeholder="CODE" />
      <div class="lobby-actions">
        <button class="primary" id="btnJoinConfirm">Join Table</button>
        <button class="secondary back-action" data-target="multiplayerCard">Back</button>
      </div>
    </div>
  </div>
  <div class="table" id="table">
    <header>
      <div class="brand">BLACKJACK • FRIENDS LOUNGE</div>
      <div class="spacer"></div>
      <div class="turn-indicator hidden" id="turnIndicator">Waiting</div>
      <div class="chip">Bank: <span id="bank">1000</span></div>
    </header>

    <div class="label dealer">Dealer • <span class="total" id="dealerTotal">0</span></div>
    <div class="lane dealer">
      <div class="spot" id="dealerSpot"></div>
    </div>

    <div class="lane seats" id="playersLane"></div>

    <div class="status" id="status"></div>

    <div class="controls" id="controls">
      <button class="primary" id="btnDeal">Deal</button>
      <button class="primary muted" id="btnHit">Hit</button>
      <button class="ghost muted" id="btnStand">Stand</button>
      <button class="ghost" id="btnNew">New Shoe</button>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
  import { getAnalytics, isSupported } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
  import { getDatabase, ref, onValue, update, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

  /* ---------- Card + Deck ---------- */
  const SUITS = ["♠","♥","♦","♣"];      // Spade, Heart, Diamond, Club
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];

  function buildShoe(decks=6){
    const shoe=[];
    for(let d=0; d<decks; d++){
      for(const s of SUITS){
        for(const r of RANKS){
          shoe.push({suit:s, rank:r});
        }
      }
    }
    for(let i=shoe.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [shoe[i], shoe[j]]=[shoe[j], shoe[i]];
    }
    return shoe;
  }

  /* ---------- Values ---------- */
  function cardValue(card){
    if(!card) return 0;
    if(card.rank==="A") return 11;
    if(["K","Q","J"].includes(card.rank)) return 10;
    return parseInt(card.rank,10);
  }
  function handValue(cards){
    let sum = 0, aces = 0;
    for(const c of cards){
      sum += cardValue(c);
      if(c.rank==="A") aces++;
    }
    while(sum>21 && aces>0){ sum -= 10; aces--; }
    return sum;
  }

  /* ---------- SVG Renderer ---------- */
  function suitColor(s){ return (s==="♥"||s==="♦") ? "#d64545" : "#1f2a44"; }
  function renderSVG(card){
    const s = suitColor(card.suit);
    const rank = card.rank;
    return `
    <svg class="svg" viewBox="0 0 250 350" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="${rank} ${card.suit}">
      <defs>
        <filter id="innerShadow" x="-50%" y="-50%" width="200%" height="200%">
          <feOffset dx="0" dy="2" />
          <feGaussianBlur stdDeviation="2" result="offblur"/>
          <feComposite in="SourceGraphic" in2="offblur" operator="arithmetic" k2="-1" k3="1"/>
        </filter>
      </defs>
      <rect x="4" y="4" rx="22" ry="22" width="242" height="342" fill="#ffffff" filter="url(#innerShadow)"/>
      <rect x="8" y="8" rx="18" ry="18" width="234" height="334" fill="#ffffff"/>
      <g fill="${s}">
        <text x="22" y="40" font-size="44" font-family="ui-monospace, Menlo, Consolas, monospace">${rank}</text>
        <text x="22" y="76" font-size="44">${card.suit}</text>
        <text x="228" y="340" font-size="44" text-anchor="end" transform="rotate(180,228,340)">${rank}</text>
        <text x="228" y="304" font-size="44" text-anchor="end" transform="rotate(180,228,304)">${card.suit}</text>
        <text x="125" y="205" font-size="120" text-anchor="middle" dominant-baseline="middle" opacity=".9">${card.suit}</text>
      </g>
    </svg>`;
  }

  /* ---------- DOM helpers ---------- */
  const dealerSpot = document.getElementById('dealerSpot');
  const playersLane = document.getElementById('playersLane');
  const dealerTotal = document.getElementById('dealerTotal');
  const statusEl = document.getElementById('status');
  const turnIndicator = document.getElementById('turnIndicator');
  const btnDeal = document.getElementById('btnDeal');
  const btnHit = document.getElementById('btnHit');
  const btnStand = document.getElementById('btnStand');
  const btnNew = document.getElementById('btnNew');
  const bankEl = document.getElementById('bank');
  const lobby = document.getElementById('lobby');
  const lobbyMain = document.getElementById('lobbyMain');
  const multiplayerCard = document.getElementById('multiplayerCard');
  const hostCard = document.getElementById('hostCard');
  const joinCard = document.getElementById('joinCard');
  const hostCodeEl = document.getElementById('hostCode');
  const btnCopyCode = document.getElementById('btnCopyCode');
  const joinCodeInput = document.getElementById('joinCodeInput');
  const btnSingle = document.getElementById('btnSingleplayer');
  const btnMultiplayer = document.getElementById('btnMultiplayer');
  const btnHost = document.getElementById('btnHost');
  const btnJoin = document.getElementById('btnJoin');
  const btnHostStart = document.getElementById('btnHostStart');
  const btnJoinConfirm = document.getElementById('btnJoinConfirm');
  const copyButtonDefaultLabel = btnCopyCode ? btnCopyCode.textContent : '';
  let copyButtonResetTimer = null;

  function setButtons(state){
    const on = (el, ok)=> el.classList.toggle('muted', !ok);
    switch(state){
      case 'deal': on(btnDeal,true); on(btnHit,false); on(btnStand,false); break;
      case 'player': on(btnDeal,false); on(btnHit,true); on(btnStand,true); break;
      default: on(btnDeal,false); on(btnHit,false); on(btnStand,false); break;
    }
  }

  let transientStatus = null;
  function showStatus(msg, ms=1100){
    transientStatus = { message: msg, until: Date.now() + ms };
    statusEl.textContent = msg;
    statusEl.classList.add('show');
    setTimeout(()=>{
      if(transientStatus && Date.now() >= transientStatus.until){
        transientStatus = null;
        statusEl.classList.remove('show');
        renderTable();
      }
    }, ms);
  }

  async function copyTextToClipboard(text){
    if(!text) return false;
    if(navigator.clipboard && navigator.clipboard.writeText){
      try{
        await navigator.clipboard.writeText(text);
        return true;
      }catch(err){
        console.warn('Clipboard API failed, falling back', err);
      }
    }
    try{
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      const selection = document.getSelection();
      const previousRange = selection && selection.rangeCount ? selection.getRangeAt(0) : null;
      textarea.select();
      const successful = document.execCommand('copy');
      document.body.removeChild(textarea);
      if(previousRange){
        selection.removeAllRanges();
        selection.addRange(previousRange);
      }
      return successful;
    }catch(err){
      console.warn('Fallback clipboard copy failed', err);
      return false;
    }
  }

  function normalizeCards(list){
    if(Array.isArray(list)){
      return list.filter(Boolean).map(card=>({suit:card.suit, rank:card.rank}));
    }
    if(!list || typeof list !== 'object') return [];
    return Object.keys(list)
      .map(Number)
      .sort((a,b)=>a-b)
      .map(key=>list[key])
      .filter(Boolean)
      .map(card=>({suit:card.suit, rank:card.rank}));
  }

  function renderHand(hand, spot, {hideHole=false}={}){
    spot.innerHTML='';
    const fan = document.createElement('div');
    fan.className = 'hand';
    spot.appendChild(fan);

    if(!hand.length) return;

    let cardWidth = 96;
    let cardHeight = 136;

    hand.forEach((card, idx)=>{
      const el = document.createElement('div');
      el.className='card';
      const faceDown = hideHole && idx===1;
      el.innerHTML = faceDown ? '<div class="back"></div>' : renderSVG(card);
      fan.appendChild(el);

      if(idx===0){
        const rect = el.getBoundingClientRect();
        if(rect.width) cardWidth = rect.width;
        if(rect.height) cardHeight = rect.height;
      }

      el.style.left = `${20 + idx*28}px`;
      el.style.top = `${6 + idx*2}px`;
      el.style.transform = `translate(0,0) rotate(${[-3,-1,1,3][idx%4]}deg)`;
    });

    const spread = (hand.length - 1) * 28;
    const totalWidth = cardWidth + spread + 40;
    fan.style.width = `${Math.max(totalWidth, cardWidth)}px`;
    fan.style.height = `${cardHeight + 12}px`;
  }

  /* ---------- Firebase ---------- */
  const firebaseConfig = {
    apiKey: "AIzaSyDRniZatGeylxphjHQadYjucOcirNBRIdk",
    authDomain: "multiplayer-640ec.firebaseapp.com",
    databaseURL: "https://multiplayer-640ec-default-rtdb.firebaseio.com",
    projectId: "multiplayer-640ec",
    storageBucket: "multiplayer-640ec.firebasestorage.app",
    messagingSenderId: "94914236381",
    appId: "1:94914236381:web:55ab00cc690140180cf034",
    measurementId: "G-V43J1S8RGF"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const rootRef = ref(db);

  const clientId = (crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
  const playerName = `Player ${clientId.slice(0,4).toUpperCase()}`;

  let roomId = null;
  let isMultiplayer = false;
  let tablePath = '';
  let shoeRef = null;
  let dealerRef = null;
  let playersRef = null;
  let stateRef = null;
  let presenceRef = null;
  let unsubscribers = [];
  let knownPlayers = new Set();

  const defaultState = {
    phase: 'waiting',
    activePlayer: null,
    hideDealerHole: false,
    banks: {},
    status: '',
    statusUntil: 0,
    turnOrder: [],
    currentTurnIndex: 0
  };

  const tableState = {
    shoe: [],
    dealer: [],
    players: {},
    state: { ...defaultState }
  };

  function cloneCards(cards){
    return (cards || []).map(card=>({suit:card.suit, rank:card.rank}));
  }

  function commitRound({includeDealer=true, includePlayer=true, includeShoe=true, includeState=true, extraPlayers=null}={}){
    if(!isMultiplayer || !tablePath){
      renderTable();
      return Promise.resolve();
    }
    const now = Date.now();
    const updates = {};
    if(includeShoe){
      updates[`${tablePath}/shoe`] = {
        cards: cloneCards(tableState.shoe),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includeDealer){
      updates[`${tablePath}/dealer`] = {
        hand: cloneCards(tableState.dealer),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(includePlayer && tableState.players[clientId]){
      updates[`${tablePath}/players/${clientId}`] = {
        ...tableState.players[clientId],
        hand: cloneCards(tableState.players[clientId].hand),
        updatedBy: clientId,
        updatedAt: now
      };
    }
    if(extraPlayers && typeof extraPlayers === 'object'){
      for(const [id, info] of Object.entries(extraPlayers)){
        if(!info) continue;
        if(id === clientId && includePlayer) continue;
        updates[`${tablePath}/players/${id}`] = {
          ...info,
          hand: cloneCards(info.hand),
          updatedBy: clientId,
          updatedAt: now
        };
      }
    }
    if(includeState){
      updates[`${tablePath}/state`] = {
        ...tableState.state,
        updatedBy: clientId,
        updatedAt: now
      };
    }
    return update(rootRef, updates);
  }

  function ensureShoe(){
    if(!Array.isArray(tableState.shoe) || tableState.shoe.length === 0){
      tableState.shoe = buildShoe(6);
      return;
    }
    if(tableState.shoe.length < 40){
      showStatus('Shuffling…', 800);
      tableState.shoe = buildShoe(6);
    }
  }

  function drawFromShoe(){
    ensureShoe();
    const shoe = tableState.shoe;
    const card = shoe.pop();
    tableState.shoe = shoe;
    return card;
  }

  function getPlayerEntry(){
    if(!tableState.players[clientId]){
      tableState.players[clientId] = {
        name: playerName,
        bank: tableState.state.banks?.[clientId] ?? 1000,
        hand: [],
        status: isMultiplayer ? 'online' : 'solo',
        joinedAt: Date.now(),
        roundResult: null
      };
    }else if(!tableState.players[clientId].joinedAt){
      tableState.players[clientId].joinedAt = Date.now();
    }
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    if(typeof tableState.state.banks[clientId] !== 'number'){
      tableState.state.banks[clientId] = tableState.players[clientId].bank ?? 1000;
    }
    return tableState.players[clientId];
  }

  const SEAT_CLASSES = ['slot-0','slot-1','slot-2','slot-3'];

  function playerEntryComparator([idA, infoA],[idB, infoB]){
    const joinedA = infoA?.joinedAt ?? infoA?.updatedAt ?? 0;
    const joinedB = infoB?.joinedAt ?? infoB?.updatedAt ?? 0;
    if(joinedA !== joinedB){
      return joinedA - joinedB;
    }
    const nameA = (infoA?.name || '').toLowerCase();
    const nameB = (infoB?.name || '').toLowerCase();
    if(nameA !== nameB){
      return nameA.localeCompare(nameB);
    }
    return idA.localeCompare(idB);
  }

  function getSortedPlayerEntries(){
    const entries = Object.entries(tableState.players || {});
    entries.sort(playerEntryComparator);
    return entries;
  }

  function renderSeats(state){
    if(!playersLane) return;
    const entries = getSortedPlayerEntries();
    const myIndex = entries.findIndex(([id])=>id === clientId);
    if(myIndex === -1){
      const me = tableState.players[clientId];
      if(me){
        entries.push([clientId, me]);
        entries.sort(playerEntryComparator);
      }
    }else if(myIndex >= SEAT_CLASSES.length){
      const [meEntry] = entries.splice(myIndex,1);
      entries.splice(SEAT_CLASSES.length - 1, 0, meEntry);
    }

    const seatsToRender = entries.slice(0, SEAT_CLASSES.length);
    playersLane.innerHTML = '';

    SEAT_CLASSES.forEach((slotClass, index)=>{
      const wrapper = document.createElement('div');
      wrapper.className = `seat-wrapper ${slotClass}`;
      const entry = seatsToRender[index];
      if(entry){
        const [id, info] = entry;
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        if(state.activePlayer === id){
          seat.classList.add('active');
        }

        const spot = document.createElement('div');
        spot.className = 'spot';
        seat.appendChild(spot);

        const hand = Array.isArray(info?.hand) ? info.hand : [];
        renderHand(hand, spot);

        const label = document.createElement('div');
        label.className = 'seat-label';

        const nameEl = document.createElement('div');
        nameEl.className = 'seat-name';
        nameEl.textContent = info?.name || `Player ${id.slice(0,4).toUpperCase()}`;
        label.appendChild(nameEl);

        const totalEl = document.createElement('div');
        totalEl.className = 'seat-total';
        totalEl.textContent = hand.length ? `Total: ${handValue(hand)}` : 'Waiting for deal';
        label.appendChild(totalEl);

        const bankValue = typeof state.banks?.[id] === 'number'
          ? state.banks[id]
          : (typeof info?.bank === 'number' ? info.bank : 1000);
        const bankLabel = document.createElement('div');
        bankLabel.className = 'seat-bank';
        bankLabel.textContent = `Bank: ${bankValue}`;
        label.appendChild(bankLabel);

        seat.appendChild(label);
        wrapper.appendChild(seat);
      }else{
        wrapper.classList.add('empty');
      }
      playersLane.appendChild(wrapper);
    });
  }

  function isMyTurn(){
    const { phase, activePlayer } = tableState.state;
    if(phase === 'waiting') return true;
    if(activePlayer && activePlayer !== clientId) return false;
    return true;
  }

  let autoBlackjackTimer = null;

  function computeTurnOrder(){
    const entries = getSortedPlayerEntries();
    if(!entries.length){
      return [clientId];
    }
    return entries.map(([id])=>id);
  }

  function renderTable(){
    const state = tableState.state || defaultState;
    let me = tableState.players[clientId];
    if(!me){
      me = getPlayerEntry();
    }
    const dealerHand = Array.isArray(tableState.dealer) ? tableState.dealer : [];

    renderHand(dealerHand, dealerSpot, { hideHole: !!state.hideDealerHole });
    renderSeats(state);

    dealerTotal.textContent = state.hideDealerHole && dealerHand.length
      ? `${cardValue(dealerHand[0])} +`
      : handValue(dealerHand);

    const bankValue = typeof state.banks?.[clientId] === 'number'
      ? state.banks[clientId]
      : (typeof me.bank === 'number' ? me.bank : 1000);
    bankEl.textContent = bankValue;

    if(transientStatus && Date.now() < transientStatus.until){
      statusEl.textContent = transientStatus.message;
      statusEl.classList.add('show');
    }else if(state.status){
      const visible = !state.statusUntil || state.statusUntil > Date.now();
      statusEl.textContent = state.status;
      statusEl.classList.toggle('show', visible);
    }else{
      statusEl.classList.remove('show');
    }

    const playerCount = Object.keys(tableState.players || {}).length;
    if(state.phase === 'waiting'){
      setButtons('deal');
    }else if(state.phase === 'player' && state.activePlayer === clientId){
      setButtons('player');
    }else{
      setButtons('lock');
    }

    if(playerCount > 1){
      if(state.phase === 'player' && state.activePlayer){
        const active = tableState.players[state.activePlayer] || {};
        const label = state.activePlayer === clientId ? 'Your turn' : `${active.name || 'Player'}'s turn`;
        turnIndicator.textContent = label;
        turnIndicator.classList.remove('hidden');
      }else if(state.phase === 'dealer'){
        turnIndicator.textContent = "Dealer's turn";
        turnIndicator.classList.remove('hidden');
      }else{
        turnIndicator.textContent = 'Waiting for next round';
        turnIndicator.classList.remove('hidden');
      }
    }else{
      turnIndicator.classList.add('hidden');
    }

    if(autoBlackjackTimer){
      clearTimeout(autoBlackjackTimer);
      autoBlackjackTimer = null;
    }
    if(state.phase === 'player' && state.activePlayer === clientId){
      autoBlackjackTimer = setTimeout(()=>{
        autoBlackjackTimer = null;
        checkAutoBlackjack();
      }, 120);
    }
  }

  function shareStatus(msg, duration=1400){
    tableState.state.status = msg;
    tableState.state.statusUntil = Date.now() + duration;
  }

  function checkAutoBlackjack(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    if(me.roundResult === 'blackjack') return;
    const hand = me.hand || [];
    if(handValue(hand) !== 21) return;
    applyBlackjackForCurrent();
  }

  function applyBlackjackForCurrent(){
    const dealerHand = tableState.dealer || [];
    const me = getPlayerEntry();
    const dv = handValue(dealerHand);
    let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
    let message = '';
    if(dv === 21){
      message = me.name === 'You'
        ? 'Push — both Blackjack'
        : `${me.name || 'Player'} pushes with Blackjack`;
    }else{
      bank += 150;
      message = me.name === 'You'
        ? 'Blackjack! +150'
        : `${me.name || 'Player'} Blackjack! +150`;
    }
    tableState.state.banks[clientId] = bank;
    me.bank = bank;
    me.roundResult = 'blackjack';
    shareStatus(message, 1500);
    const hasNext = finishTurn(clientId);
    commitRound();
    renderTable();
    if(!hasNext){
      dealerPlay();
    }
  }

  function resolveRound(){
    const dealerHand = tableState.dealer || [];
    const dv = handValue(dealerHand);
    const banks = tableState.state.banks || {};
    const extraPlayers = {};
    let myMessage = '';
    const multiplePlayers = Object.keys(tableState.players || {}).length > 1;

    for(const [id, player] of Object.entries(tableState.players || {})){
      if(!player) continue;
      const result = player.roundResult;
      const hand = player.hand || [];
      let bank = typeof banks[id] === 'number' ? banks[id] : (typeof player.bank === 'number' ? player.bank : 1000);
      let message = '';

      const displayName = player.name || 'Player';
      const isYou = displayName === 'You';

      if(result === 'blackjack'){
        message = isYou ? 'Blackjack!' : `${displayName} Blackjack!`;
      }else if(result === 'bust'){
        message = isYou ? 'You bust' : `${displayName} busts`;
      }else{
        const pv = handValue(hand);
        if(dv > 21 || pv > dv){
          bank += 100;
          message = isYou ? 'You win +100' : `${displayName} wins +100`;
          player.roundResult = 'win';
        }else if(pv < dv){
          bank -= 100;
          message = isYou ? 'You lose -100' : `${displayName} loses -100`;
          player.roundResult = 'lose';
        }else{
          message = isYou ? 'You push' : `${displayName} pushes`;
          player.roundResult = 'push';
        }
        banks[id] = bank;
        player.bank = bank;
      }

      if(id !== clientId){
        extraPlayers[id] = player;
      }else{
        myMessage = message;
      }
    }

    tableState.state.banks = banks;
    tableState.state.phase = 'waiting';
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.turnOrder = [];
    tableState.state.currentTurnIndex = 0;

    const sharedMessage = multiplePlayers ? 'Round complete' : (myMessage || 'Round complete');
    const duration = multiplePlayers ? 1400 : 1500;
    tableState.state.status = sharedMessage;
    tableState.state.statusUntil = Date.now() + duration;
    if(multiplePlayers && myMessage){
      showStatus(myMessage, duration);
    }

    const commitOptions = { includePlayer: !!tableState.players[clientId], extraPlayers: Object.keys(extraPlayers).length ? extraPlayers : null };
    commitRound(commitOptions);
    renderTable();
  }

  function dealerPlay(){
    const draw = ()=>{
      const dealerHand = tableState.dealer || [];
      const dv = handValue(dealerHand);
      const hasAce = dealerHand.some(c=>c.rank === 'A');
      const shouldHit = dv < 17 || (dv === 17 && hasAce && handValue(dealerHand) === 17);
      if(shouldHit){
        setTimeout(()=>{
          tableState.dealer = [...dealerHand, drawFromShoe()];
          commitRound();
          renderTable();
          draw();
        }, 420);
      }else{
        resolveRound();
      }
    };
    draw();
  }

  function finishTurn(playerId){
    const state = tableState.state;
    let order = Array.isArray(state.turnOrder) ? state.turnOrder.slice() : [];
    if(!order.length){
      order = computeTurnOrder();
      state.turnOrder = order;
    }
    let currentIndex = order.indexOf(playerId);
    if(currentIndex === -1){
      currentIndex = state.currentTurnIndex || 0;
    }
    for(let nextIndex = currentIndex + 1; nextIndex < order.length; nextIndex++){
      const nextId = order[nextIndex];
      const nextPlayer = tableState.players[nextId];
      if(!nextPlayer) continue;
      if(nextPlayer.roundResult === 'blackjack' || nextPlayer.roundResult === 'bust') continue;
      const hasHand = Array.isArray(nextPlayer.hand) && nextPlayer.hand.length;
      if(!hasHand) continue;
      state.currentTurnIndex = nextIndex;
      state.activePlayer = nextId;
      state.phase = 'player';
      state.hideDealerHole = true;
      return true;
    }
    state.currentTurnIndex = order.length;
    state.activePlayer = null;
    state.phase = 'dealer';
    state.hideDealerHole = false;
    return false;
  }

  function startDeal(){
    if(tableState.state.phase !== 'waiting' || !isMyTurn()) return;
    ensureShoe();

    const players = tableState.players || {};
    const order = computeTurnOrder();
    if(!order.includes(clientId)){
      order.unshift(clientId);
    }

    const playersToWrite = {};

    tableState.dealer = [drawFromShoe(), drawFromShoe()];

    for(const id of order){
      const existing = players[id] || {};
      const hand = [drawFromShoe(), drawFromShoe()];
      const updated = {
        ...existing,
        hand,
        roundResult: null,
        status: isMultiplayer ? 'online' : (existing.status || 'solo')
      };
      if(typeof updated.bank !== 'number'){
        updated.bank = tableState.state.banks?.[id] ?? 1000;
      }
      if(!updated.joinedAt){
        updated.joinedAt = Date.now();
      }
      tableState.players[id] = updated;
      playersToWrite[id] = updated;
      if(!tableState.state.banks){
        tableState.state.banks = {};
      }
      if(typeof tableState.state.banks[id] !== 'number'){
        tableState.state.banks[id] = updated.bank;
      }
    }

    tableState.state.phase = 'player';
    tableState.state.activePlayer = order[0];
    tableState.state.turnOrder = order;
    tableState.state.currentTurnIndex = 0;
    tableState.state.hideDealerHole = true;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;

    const extraPlayers = { ...playersToWrite };
    if(extraPlayers[clientId]){
      delete extraPlayers[clientId];
    }

    commitRound({ includePlayer: !!tableState.players[clientId], extraPlayers: Object.keys(extraPlayers).length ? extraPlayers : null });
    renderTable();
  }

  function playerHit(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    me.hand = [...(me.hand||[]), drawFromShoe()];
    tableState.state.status = '';
    tableState.state.statusUntil = 0;

    const total = handValue(me.hand);
    if(total > 21){
      let bank = tableState.state.banks[clientId] ?? me.bank ?? 1000;
      bank -= 100;
      tableState.state.banks[clientId] = bank;
      me.bank = bank;
      me.roundResult = 'bust';
      const bustMsgName = me.name === 'You' ? 'You bust' : `${me.name || 'Player'} busts`;
      shareStatus(bustMsgName, 1500);
      const hasNext = finishTurn(clientId);
      commitRound();
      renderTable();
      if(!hasNext){
        dealerPlay();
      }
      return;
    }
    commitRound();
    renderTable();
  }

  function playerStand(){
    if(tableState.state.phase !== 'player' || tableState.state.activePlayer !== clientId) return;
    const me = getPlayerEntry();
    me.roundResult = 'stand';
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    const hasNext = finishTurn(clientId);
    commitRound();
    renderTable();
    if(!hasNext){
      dealerPlay();
    }
  }

  function newShoe(){
    tableState.shoe = buildShoe(6);
    shareStatus('New shoe ready', 700);
    commitRound({ includeDealer:false, includePlayer:false, includeShoe:true });
    renderTable();
  }

  function resetLocalTable(){
    tableState.shoe = [];
    tableState.dealer = [];
    tableState.players = {};
    tableState.state = { ...defaultState, banks: {} };
  }

  function detachListeners(){
    unsubscribers.forEach(unsub => {
      try {
        unsub && unsub();
      } catch (err) {
        console.warn('Failed to detach listener', err);
      }
    });
    unsubscribers = [];
  }

  function attachListeners(){
    if(!isMultiplayer) return;
    detachListeners();
    if(!shoeRef || !dealerRef || !playersRef || !stateRef) return;

    unsubscribers.push(onValue(shoeRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      if(data && data.cards){
        tableState.shoe = normalizeCards(data.cards);
      }
      renderTable();
    }));

    unsubscribers.push(onValue(dealerRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.dealer = normalizeCards(data?.hand);
      renderTable();
    }));

    unsubscribers.push(onValue(playersRef, snapshot=>{
      const data = snapshot.val() || {};
      const previousPlayers = { ...tableState.players };
      const currentIds = new Set(Object.keys(data));
      for(const id of currentIds){
        if(!knownPlayers.has(id) && id !== clientId){
          showStatus(`${data[id]?.name || 'Player'} joined`, 1000);
        }
      }
      for(const id of knownPlayers){
        if(!currentIds.has(id) && id !== clientId){
          const name = previousPlayers[id]?.name || 'Player';
          showStatus(`${name} left`, 1000);
        }
      }
      knownPlayers = currentIds;
      const parsed = {};
      for(const [id, info] of Object.entries(data)){
        parsed[id] = {
          ...info,
          hand: normalizeCards(info.hand)
        };
      }
      tableState.players = parsed;
      renderTable();
    }));

    unsubscribers.push(onValue(stateRef, snapshot=>{
      const data = snapshot.val();
      if(data && data.updatedBy === clientId) return;
      tableState.state = { ...defaultState, ...(data || {}) };
      if(!tableState.state.banks) tableState.state.banks = {};
      renderTable();
    }));
  }

  function sanitizeRoomCode(value){
    const cleaned = String(value || '').replace(/[^a-zA-Z0-9]/g, '').slice(0, 12);
    if(!cleaned) return '';
    if(cleaned.length <= 5){
      return cleaned.toUpperCase();
    }
    return cleaned.toLowerCase();
  }

  function generateRoomCode(){
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for(let i=0; i<5; i++){
      code += chars[Math.floor(Math.random()*chars.length)];
    }
    return code;
  }

  function startSingleplayer(){
    const previousPath = tablePath;
    const wasMultiplayer = isMultiplayer;
    detachListeners();
    if(wasMultiplayer && previousPath){
      const cleanup = {};
      cleanup[`${previousPath}/players/${clientId}`] = null;
      cleanup[`${previousPath}/state/banks/${clientId}`] = null;
      update(rootRef, cleanup).catch(()=>{});
    }
    isMultiplayer = false;
    roomId = null;
    tablePath = '';
    shoeRef = dealerRef = playersRef = stateRef = presenceRef = null;
    knownPlayers = new Set();
    resetLocalTable();
    const me = getPlayerEntry();
    me.name = 'You';
    me.bank = 1000;
    me.hand = [];
    me.status = 'solo';
    me.roundResult = null;
    tableState.state.banks[clientId] = me.bank;
    tableState.state.phase = 'waiting';
    tableState.state.activePlayer = null;
    tableState.state.hideDealerHole = false;
    tableState.state.status = '';
    tableState.state.statusUntil = 0;
    tableState.state.turnOrder = [];
    tableState.state.currentTurnIndex = 0;
    window.location.hash = '';
    setButtons('deal');
    renderTable();
  }

  function startMultiplayer(code, { host=false }={}){
    const sanitized = sanitizeRoomCode(code);
    if(!sanitized) return;
    detachListeners();
    resetLocalTable();
    isMultiplayer = true;
    roomId = sanitized;
    tablePath = `tables/${roomId}`;
    shoeRef = ref(db, `${tablePath}/shoe`);
    dealerRef = ref(db, `${tablePath}/dealer`);
    playersRef = ref(db, `${tablePath}/players`);
    stateRef = ref(db, `${tablePath}/state`);
    presenceRef = ref(db, `${tablePath}/players/${clientId}`);
    knownPlayers = new Set();
    window.location.hash = roomId;

    if(host){
      const now = Date.now();
      update(rootRef, {
        [`${tablePath}/shoe`]: null,
        [`${tablePath}/dealer`]: null,
        [`${tablePath}/players`]: null,
        [`${tablePath}/state`]: { ...defaultState, updatedBy: clientId, updatedAt: now }
      }).catch(err=>console.warn('Failed to prepare room', err));
    }

    attachListeners();
    joinTable();
    setButtons('deal');
    renderTable();
  }

  function joinTable(){
    if(!isMultiplayer || !tablePath) return;
    const me = getPlayerEntry();
    const now = Date.now();
    const updates = {};
    updates[`${tablePath}/players/${clientId}`] = {
      ...me,
      hand: cloneCards(me.hand),
      updatedBy: clientId,
      updatedAt: now
    };
    if(!tableState.state.banks){
      tableState.state.banks = {};
    }
    tableState.state.banks[clientId] = me.bank ?? 1000;
    updates[`${tablePath}/state/banks/${clientId}`] = tableState.state.banks[clientId];
    updates[`${tablePath}/state/updatedBy`] = clientId;
    updates[`${tablePath}/state/updatedAt`] = now;
    update(rootRef, updates).catch(err=>console.warn('Failed to join table', err));
    onDisconnect(presenceRef).remove().catch(()=>{});
  }

  const lobbyCards = { lobbyMain, multiplayerCard, hostCard, joinCard };

  function showLobbyCard(id){
    Object.values(lobbyCards).forEach(card => card.classList.add('hidden'));
    const target = lobbyCards[id] || lobbyMain;
    target.classList.remove('hidden');
  }

  function closeLobby(){
    lobby.classList.add('hidden');
  }

  function openLobby(id='lobbyMain'){
    lobby.classList.remove('hidden');
    showLobbyCard(id);
  }

  lobby.querySelectorAll('.back-action').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      showLobbyCard(btn.dataset.target || 'lobbyMain');
    });
  });

  btnSingle.addEventListener('click', ()=>{
    startSingleplayer();
    closeLobby();
  });

  btnMultiplayer.addEventListener('click', ()=>{
    showLobbyCard('multiplayerCard');
  });

  btnHost.addEventListener('click', ()=>{
    const code = generateRoomCode();
    hostCodeEl.textContent = code;
    hostCodeEl.dataset.code = code;
    if(btnCopyCode){
      clearTimeout(copyButtonResetTimer);
      copyButtonResetTimer = null;
      btnCopyCode.textContent = copyButtonDefaultLabel || 'Copy code';
    }
    showLobbyCard('hostCard');
  });

  btnHostStart.addEventListener('click', ()=>{
    const code = hostCodeEl.dataset.code || hostCodeEl.textContent || '';
    if(!code) return;
    startMultiplayer(code, { host: true });
    closeLobby();
  });

  btnJoin.addEventListener('click', ()=>{
    joinCodeInput.value = '';
    showLobbyCard('joinCard');
    setTimeout(()=> joinCodeInput.focus(), 50);
  });

  function requestJoin(){
    const code = sanitizeRoomCode(joinCodeInput.value);
    if(!code){
      joinCodeInput.focus();
      return;
    }
    startMultiplayer(code);
    closeLobby();
  }

  btnJoinConfirm.addEventListener('click', requestJoin);
  joinCodeInput.addEventListener('input', ()=>{
    joinCodeInput.value = sanitizeRoomCode(joinCodeInput.value);
  });
  joinCodeInput.addEventListener('keydown', event=>{
    if(event.key === 'Enter'){
      event.preventDefault();
      requestJoin();
    }
  });

  if(btnCopyCode){
    btnCopyCode.addEventListener('click', async ()=>{
      const code = (hostCodeEl.dataset.code || hostCodeEl.textContent || '').trim();
      if(!code || !/[^-]/.test(code)){
        return;
      }
      const success = await copyTextToClipboard(code);
      btnCopyCode.blur();
      btnCopyCode.textContent = success ? 'Copied!' : 'Press Ctrl+C to copy';
      clearTimeout(copyButtonResetTimer);
      copyButtonResetTimer = setTimeout(()=>{
        btnCopyCode.textContent = copyButtonDefaultLabel || 'Copy code';
      }, success ? 1600 : 2600);
    });
  }

  btnDeal.addEventListener('click', ()=> startDeal());
  btnHit.addEventListener('click', ()=> !btnHit.classList.contains('muted') && playerHit());
  btnStand.addEventListener('click', ()=> !btnStand.classList.contains('muted') && playerStand());
  btnNew.addEventListener('click', ()=> newShoe());

  const initialCode = sanitizeRoomCode(window.location.hash.replace('#',''));
  if(initialCode){
    startMultiplayer(initialCode);
    closeLobby();
  }else{
    startSingleplayer();
    openLobby('lobbyMain');
  }

  isSupported()
    .then((supported) => {
      if (supported) {
        getAnalytics(app);
      }
    })
    .catch((err) => console.warn('Firebase analytics not supported', err));
</script>
</body>
</html>
