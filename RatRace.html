<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rat Races â€” ARIA ARCADE</title>
<style>
  :root{
    --bg:#0b1020;        /* site navy */
    --felt:#0e4d37;      /* track */
    --felt-dark:#0a3a2a;
    --lane:#145a46;
    --line:rgba(255,255,255,.16);
    --card:#151a29;
    --text:#e8eef6;
    --muted:#a9b4c7;
    --accent:#ffd13b;
    --accent2:#2b3350;
    --win:#63d471;
    --lose:#ef476f;
    --shadow:0 14px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;
    color:var(--text);
    background:
      radial-gradient(circle at 20% 20%, rgba(53,104,214,.25) 0 24%, transparent 60%),
      radial-gradient(circle at 80% 10%, rgba(255,209,59,.15) 0 28%, transparent 62%),
      linear-gradient(160deg, #05060d 0%, #090f1f 60%, #0c1228 100%);
    display:flex; min-height:100dvh; align-items:center; justify-content:center; padding:24px 0;
  }
  .wrap{
    width:min(1240px,96vw); margin:0 auto; display:grid; gap:22px;
    grid-template-columns: 1.15fr .85fr; align-items:start;
  }
  @media (max-width:1080px){ .wrap{ grid-template-columns: 1fr; max-width:680px; } }

  /* Track */
  .track{
    position:relative; aspect-ratio: 16/9; border-radius:32px; overflow:hidden;
    background:
      radial-gradient(150% 130% at 50% -10%, rgba(82,212,183,.25) 0%, rgba(11,78,59,.18) 45%, rgba(5,34,27,1) 100%),
      linear-gradient(180deg, #0b4030 0%, #05231a 85%);
    border:8px solid rgba(8,32,24,.95); box-shadow:0 40px 80px rgba(0,0,0,.45);
  }
  .track::before{
    content:""; position:absolute; inset:0; background:linear-gradient(180deg, rgba(0,0,0,.55) 0%, rgba(0,0,0,0) 32%);
    pointer-events:none; z-index:2;
  }
  .track::after{
    content:""; position:absolute; inset:20px; border-radius:26px;
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08), inset 0 -40px 60px rgba(0,0,0,.4);
    background:radial-gradient(120% 150% at 50% 120%, rgba(255,255,255,.05) 0, transparent 65%);
  }
  .lanes{
    position:absolute; inset:36px 34px 92px 34px; display:grid; gap:12px; z-index:1;
    filter:drop-shadow(0 18px 24px rgba(0,0,0,.35));
  }
  .lane{
    position:relative; overflow:hidden; border-radius:18px; border:1px solid rgba(255,255,255,.08);
    background:
      linear-gradient(90deg, rgba(255,255,255,.08) 0 8px, transparent 8px 18px) repeat-x,
      linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.02));
    background-size:36px 100%, 100% 100%;
  }
  .lane::before{
    content:""; position:absolute; inset:0; border-radius:inherit;
    background:linear-gradient(180deg, rgba(255,255,255,.12) 0%, rgba(0,0,0,.18) 70%);
    mix-blend-mode:soft-light; opacity:.55;
  }
  .finish{
    position:absolute; top:36px; bottom:92px; right:40px; width:12px;
    background:
      linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,0) 18%, rgba(0,0,0,.45) 100%),
      repeating-linear-gradient(180deg, #f4f5f7 0 14px, #1a1f26 14px 28px);
    box-shadow:inset 0 0 0 2px rgba(0,0,0,.6), 0 12px 20px rgba(0,0,0,.45);
    border-radius:6px;
  }

  /* Rat */
  .rat{
    position:absolute; left:0; top:50%; transform:translate(0,-50%);
    width:140px; height:70px; display:grid; place-items:center; pointer-events:none;
  }
  .rat svg{ width:138px; height:auto; }
  .rat svg .tail{ animation:tail-sway 1.1s ease-in-out infinite; transform-origin:24px 70px; }
  .rat svg .body-group{ animation:body-bob .42s ease-in-out infinite; transform-origin:130px 78px; }
  .rat svg .ear{ animation:ear-flick 2.8s ease-in-out infinite; transform-origin:182px 40px; }
  .rat svg .sparkle{ animation:sparkle 2s linear infinite; }
  @keyframes body-bob{ 0%,100%{ transform:translateY(0); } 50%{ transform:translateY(-4px); } }
  @keyframes tail-sway{ 0%,100%{ transform:rotate(-6deg); } 50%{ transform:rotate(10deg); } }
  @keyframes ear-flick{ 0%,92%{ transform:rotate(0deg); } 96%{ transform:rotate(-6deg); } 100%{ transform:rotate(0deg); } }
  @keyframes sparkle{ 0%{ opacity:0; transform:translate(0,0) scale(.6); }
                       40%{ opacity:.8; transform:translate(4px,-6px) scale(1); }
                       100%{ opacity:0; transform:translate(12px,-18px) scale(0); } }
  .nameTag{
    position:absolute; left:12px; top:10px; background:rgba(18,28,45,.72); padding:.18rem .65rem;
    font-size:.78rem; letter-spacing:.04em; border-radius:999px; backdrop-filter: blur(6px);
    box-shadow:0 6px 12px rgba(0,0,0,.35); text-transform:uppercase;
  }

  /* HUD */
  header{
    display:flex; gap:12px; align-items:center; justify-content:space-between; padding:14px 24px;
    position:absolute; left:0; right:0; bottom:0; height:88px; z-index:3;
    background:linear-gradient(180deg, rgba(0,0,0,0) 0, rgba(5,14,18,.25) 32%, rgba(3,7,10,.55) 100%);
  }
  .status{
    font-weight:800; letter-spacing:.05em; text-shadow:0 6px 20px rgba(0,0,0,.6); font-size:1.25rem;
  }
  .status.countdown{ font-size:1.4rem; }
  .pill{ background:linear-gradient(135deg, #ffe775 0%, #ffbf24 65%, #ff8b24 100%);
    color:#1a1600; border-radius:999px; padding:.4rem .9rem; font-weight:800; box-shadow:0 8px 16px rgba(0,0,0,.35);
  }
  .legend{ display:flex; gap:14px; opacity:.92; font-size:.92rem; align-items:center; }
  .legend span{ display:inline-flex; gap:8px; align-items:center; background:rgba(9,14,24,.55);
    padding:.35rem .65rem; border-radius:999px; border:1px solid rgba(255,255,255,.08); }

  /* Betting Panel */
  .panel{
    background:linear-gradient(180deg,#181f33,#0f1423); border:1px solid rgba(255,255,255,.08);
    border-radius:22px; padding:22px; box-shadow:0 28px 50px rgba(0,0,0,.45);
  }
  .panel h2{ margin:.2rem 0 1.1rem; font-size:1.15rem; letter-spacing:.18em; opacity:.92; text-transform:uppercase; }
  .grid{ display:grid; gap:12px; grid-template-columns: 1fr 1fr 1fr; }
  @media (max-width:900px){ .grid{ grid-template-columns: 1fr; } }
  .field{ display:flex; gap:12px; align-items:center; }
  .field label{ width:96px; color:var(--muted); font-size:.9rem; text-transform:uppercase; letter-spacing:.08em; }
  input[type="text"], input[type="number"], select{
    width:100%; background:rgba(8,12,24,.85); color:var(--text); border:1px solid rgba(255,255,255,.12);
    border-radius:12px; padding:.6rem .85rem; outline:none; box-shadow:inset 0 2px 8px rgba(0,0,0,.35);
  }
  .btn{
    appearance:none; border:0; border-radius:14px; padding:.85rem 1.1rem; cursor:pointer; font-weight:800;
    color:#121013; background:linear-gradient(135deg,#ffe775,#ffbf24 65%,#ff8b24);
    box-shadow:0 16px 28px rgba(0,0,0,.4); letter-spacing:.06em; text-transform:uppercase;
  }
  .btn.secondary{ background:linear-gradient(135deg,#2e3757,#1e263f); color:#e9eef6; border:1px solid rgba(255,255,255,.14) }
  .btn.muted{ opacity:.6; pointer-events:none }

  .btn.small{ padding:.55rem .8rem; font-size:.85rem; }

  .mpCard{
    background:rgba(10,16,30,.65);
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px;
    padding:14px 16px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.04);
    margin-bottom:18px;
    display:grid;
    gap:10px;
  }
  .mpRow{ display:flex; flex-wrap:wrap; gap:8px; }
  .mpRoom{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; font-size:.9rem; }
  .mpRoomCode{ font-weight:700; letter-spacing:.08em; background:rgba(255,255,255,.08); padding:.35rem .65rem; border-radius:10px; }
  .mpJoin{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .mpJoin label{ font-size:.85rem; color:var(--muted); text-transform:uppercase; letter-spacing:.08em; }
  .mpJoin input{ flex:1 1 120px; min-width:0; }
  .mpNotice{ font-size:.85rem; color:var(--muted); }

  .summaryGrid{
    display:grid; gap:14px; margin-top:16px;
    grid-template-columns:repeat(auto-fit, minmax(260px,1fr));
  }
  .summaryCard{
    background:rgba(9,14,26,.72);
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px;
    padding:16px 18px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.03);
    display:flex; flex-direction:column; gap:12px;
  }
  .summaryHeader{ display:flex; justify-content:space-between; align-items:center; font-size:.85rem; text-transform:uppercase; letter-spacing:.12em; color:var(--muted); }
  .summaryMeta{ font-size:.78rem; letter-spacing:.08em; color:var(--muted); opacity:.85; }

  .playerList{ display:flex; flex-direction:column; gap:10px; }
  .playerRow{
    position:relative;
    padding:12px 14px;
    border-radius:14px;
    background:rgba(12,18,32,.78);
    border:1px solid rgba(255,255,255,.04);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.02);
    display:flex; flex-direction:column; gap:10px;
  }
  .playerRow.you{ border-color:rgba(255,209,59,.45); box-shadow:0 0 0 1px rgba(255,209,59,.25); }
  .playerRow.ghost{ opacity:.7; }
  .playerRowTop{ display:flex; justify-content:space-between; gap:12px; align-items:center; }
  .playerIdentity{ display:flex; gap:10px; align-items:center; min-width:0; }
  .playerAvatar{
    width:40px; height:40px; border-radius:50%;
    display:grid; place-items:center;
    font-weight:700; letter-spacing:.04em; color:#0c101c;
    background:linear-gradient(135deg, rgba(255,255,255,.25), rgba(255,255,255,0));
    position:relative; isolation:isolate;
  }
  .playerAvatar::after{
    content:""; position:absolute; inset:0; border-radius:inherit;
    background:var(--avatar-color, #2e3757); z-index:-1;
  }
  .playerInfo{ min-width:0; }
  .playerName{ font-weight:700; letter-spacing:.02em; font-size:1rem; }
  .playerMeta{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; margin-top:2px; font-size:.75rem; color:var(--muted); }
  .playerBadges{ display:flex; flex-wrap:wrap; gap:4px; }
  .playerBadge{
    padding:.15rem .45rem; border-radius:999px; font-size:.7rem; font-weight:700;
    letter-spacing:.08em; text-transform:uppercase;
    border:1px solid rgba(255,255,255,.12); color:var(--muted);
    background:rgba(18,26,42,.75);
  }
  .playerBadge.you{ color:#111; background:linear-gradient(135deg,#ffe775,#ffbf24 70%,#ff8b24); border-color:rgba(255,255,255,.2); }
  .playerBadge.host{ color:#fff; background:linear-gradient(135deg,#506bff,#2c3d8a); border-color:rgba(255,255,255,.18); }
  .playerBadge.ghost{ background:rgba(140,149,171,.2); color:rgba(208,215,230,.9); border-color:rgba(255,255,255,.08); }
  .playerTotals{ text-align:right; min-width:92px; }
  .playerTotals strong{ display:block; font-size:1.05rem; }
  .playerTotals span{ display:block; font-size:.78rem; color:var(--muted); letter-spacing:.05em; }
  .playerBreakdown{ display:flex; flex-wrap:wrap; gap:6px; }
  .playerBreakdown--empty{ color:var(--muted); font-size:.78rem; }
  .ratPill{
    display:inline-flex; align-items:center; gap:6px; padding:.25rem .55rem;
    border-radius:999px; font-size:.78rem; letter-spacing:.03em;
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.08);
  }
  .ratPill::before{
    content:""; width:10px; height:10px; border-radius:50%; background:var(--rat-color,#ffd13b);
  }

  .ratTotals{ display:flex; flex-direction:column; gap:10px; }
  .ratRow{
    position:relative; overflow:hidden; border-radius:12px; padding:10px 12px;
    background:rgba(12,18,32,.72); border:1px solid rgba(255,255,255,.05);
  }
  .ratRow.has-bets{ border-color:rgba(255,209,59,.32); }
  .ratProgress{
    position:absolute; inset:0; background:linear-gradient(135deg, rgba(255,209,59,.24), rgba(255,209,59,.05));
    opacity:.9;
  }
  .ratRowInner{ position:relative; display:flex; justify-content:space-between; gap:12px; align-items:center; }
  .ratInfo{ display:flex; gap:10px; align-items:center; font-weight:600; letter-spacing:.03em; }
  .ratInfo .ratSwatch{ width:14px; height:14px; border-radius:4px; box-shadow:0 0 0 1px rgba(255,255,255,.35); }
  .ratNumbers{ text-align:right; }
  .ratAmount{ display:block; font-weight:700; font-size:1rem; }
  .ratMeta{ display:block; font-size:.78rem; color:var(--muted); letter-spacing:.05em; }

  .emptyState{ padding:14px; border-radius:12px; border:1px dashed rgba(255,255,255,.12); text-align:center; font-size:.82rem; color:var(--muted); background:rgba(9,14,26,.35); }

  .bettorOwner{ margin-top:6px; font-size:.75rem; color:var(--muted); display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
  .ownerLabel{ font-weight:600; letter-spacing:.03em; }
  .ownerBadges{ display:flex; flex-wrap:wrap; gap:4px; }

  tbody tr.mine{ border:1px solid rgba(255,209,59,.35); box-shadow:0 16px 28px rgba(255,209,59,.1); }

  table{ width:100%; border-collapse:separate; border-spacing:0 10px; font-variant-numeric:tabular-nums; }
  th, td{ text-align:left; padding:.65rem .9rem; }
  th{ color:var(--muted); font-weight:700; font-size:.85rem; text-transform:uppercase; letter-spacing:.08em; }
  tbody tr{ background:rgba(7,11,24,.85); border:1px solid rgba(255,255,255,.08); box-shadow:0 12px 18px rgba(0,0,0,.35); transition:transform .18s ease, box-shadow .18s ease; }
  tbody tr:hover{ transform:translateY(-2px); box-shadow:0 16px 28px rgba(0,0,0,.42); }
  tbody tr td:first-child{ border-top-left-radius:10px; border-bottom-left-radius:10px }
  tbody tr td:last-child{ border-top-right-radius:10px; border-bottom-right-radius:10px }
  .right{ text-align:right }
  .ok{ color:var(--win); font-weight:800 }
  .bad{ color:var(--lose); font-weight:800 }

  .note{ font-size:.9rem; color:var(--muted); margin-top:.5rem }
</style>
</head>
<body>
  <div class="wrap">
    <!-- TRACK -->
    <div class="track" id="track">
      <div class="lanes" id="lanes"></div>
      <div class="finish"></div>

      <header>
        <div class="status" id="status">Place your bets.</div>
        <div class="legend">
          <span><span class="pill" id="pot">$0</span> pot</span>
          <span>Min bet $1</span>
        </div>
      </header>
    </div>

    <!-- PANEL -->
    <div class="panel">
      <div class="mpCard">
        <div class="mpRow">
          <button class="btn secondary" id="btnSolo" type="button">Solo</button>
          <button class="btn secondary" id="btnHostRoom" type="button">Host Room</button>
          <button class="btn secondary" id="btnJoinRoom" type="button">Join Room</button>
        </div>
        <div class="mpRoom" id="roomInfo" hidden>
          <span>Room:</span>
          <span class="mpRoomCode" id="roomCode">â€”</span>
          <button class="btn secondary small" id="btnCopyRoom" type="button">Copy Code</button>
        </div>
        <div class="mpJoin" id="joinControls" hidden>
          <label for="joinCode">Room Code</label>
          <input id="joinCode" type="text" placeholder="ABCDE" maxlength="12" autocomplete="off" />
          <button class="btn secondary" id="btnConfirmJoin" type="button">Join</button>
        </div>
        <div class="mpNotice" id="mpNotice">You are playing solo.</div>
      </div>
      <div class="summaryGrid">
        <div class="summaryCard">
          <div class="summaryHeader">Players <span class="summaryMeta" id="playerCount">â€”</span></div>
          <div class="playerList" id="playerList"></div>
        </div>
        <div class="summaryCard">
          <div class="summaryHeader">Rat Pool <span class="summaryMeta" id="poolMeta">â€”</span></div>
          <div class="ratTotals" id="ratTotals"></div>
        </div>
      </div>
      <h2>Betting</h2>
      <div class="grid">
        <div class="field"><label for="bettor">Bettor</label><input id="bettor" type="text" placeholder="Name (optional)"></div>
        <div class="field"><label for="rat">Rat</label>
          <select id="rat"></select>
        </div>
        <div class="field"><label for="amount">Amount</label><input id="amount" type="number" min="1" step="1" value="10"></div>
      </div>
      <div style="display:flex; gap:8px; margin:.8rem 0 1rem">
        <button class="btn" id="addBet">Add Bet</button>
        <button class="btn secondary" id="closeBets">Close Bets & Start</button>
        <button class="btn secondary" id="reset">New Race</button>
      </div>

      <table>
        <thead><tr><th>Bettor</th><th>Rat</th><th class="right">Amount</th><th class="right">Remove</th></tr></thead>
        <tbody id="betRows"></tbody>
      </table>

      <div class="note">
        Payouts are pari-mutuel: winners split the pot in proportion to their bet. If nobody bet the winning rat, the house keeps the pot (ðŸ˜¼).
      </div>

      <h2 style="margin-top:1.2rem">Results</h2>
      <table>
        <thead><tr><th>Bettor</th><th>Rat</th><th class="right">Bet</th><th class="right">Payout</th><th class="right">Net</th></tr></thead>
        <tbody id="resultRows"><tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr></tbody>
      </table>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getAnalytics, isSupported } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
import { getDatabase, ref, onValue, update, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

/* ============== Setup rats & lanes ============== */
const RAT_DATA = [
  { id:'r1', name:'Whisker', color:'#b9c2cc' },
  { id:'r2', name:'Nibble',  color:'#cdbfb2' },
  { id:'r3', name:'Shadow',  color:'#9aa6b2' },
  { id:'r4', name:'Cheddar', color:'#d8b04f' },
  { id:'r5', name:'Squeaks', color:'#c59ab2' },
];

const lanes = document.getElementById('lanes');
const statusEl = document.getElementById('status');
const potEl = document.getElementById('pot');
lanes.style.gridTemplateRows = `repeat(${RAT_DATA.length}, 1fr)`;

// build lanes + rats
const rats = RAT_DATA.map((r) => {
  const lane = document.createElement('div');
  lane.className = 'lane';
  lane.dataset.rat = r.id;
  lanes.appendChild(lane);

  const rat = document.createElement('div');
  rat.className = 'rat';
  rat.innerHTML = ratSVG(r.color);
  lane.appendChild(rat);

  const tag = document.createElement('div');
  tag.className = 'nameTag';
  tag.textContent = r.name;
  lane.appendChild(tag);

  return { ...r, lane, el:rat, x:0, v:0, baseSpeed:0, wobbleAmp:0, wobblePeriod:160, wobblePhase:0 };
});

// selection dropdown
const sel = document.getElementById('rat');
for(const r of RAT_DATA){
  const o = document.createElement('option');
  o.value = r.id; o.textContent = r.name;
  sel.appendChild(o);
}

/* ============== Betting state ============== */
let bets = []; // {id, name, ratId, amount, owner, createdAt}
const betRows = document.getElementById('betRows');
const resultRows = document.getElementById('resultRows');
const addBetBtn = document.getElementById('addBet');
const closeBetsBtn = document.getElementById('closeBets');
const resetBtn = document.getElementById('reset');
const bettorInput = document.getElementById('bettor');
const amountInput = document.getElementById('amount');
let players = {};

const soloBtn = document.getElementById('btnSolo');
const hostBtn = document.getElementById('btnHostRoom');
const joinBtn = document.getElementById('btnJoinRoom');
const joinControls = document.getElementById('joinControls');
const joinCodeInput = document.getElementById('joinCode');
const joinConfirmBtn = document.getElementById('btnConfirmJoin');
const roomInfo = document.getElementById('roomInfo');
const roomCodeEl = document.getElementById('roomCode');
const copyRoomBtn = document.getElementById('btnCopyRoom');
const mpNotice = document.getElementById('mpNotice');
const playerListEl = document.getElementById('playerList');
const ratTotalsEl = document.getElementById('ratTotals');
const playerCountEl = document.getElementById('playerCount');
const poolMetaEl = document.getElementById('poolMeta');

function fmt(n){ return '$'+Number(n).toLocaleString(undefined,{minimumFractionDigits:0}); }
function pot(){ return bets.reduce((a,b)=>a+Number(b.amount||0),0); }
function totalOn(rid){ return bets.filter(b=>b.ratId===rid).reduce((a,b)=>a+Number(b.amount),0); }

function canRemoveBet(bet){
  if(!bet) return false;
  if(!isMultiplayer) return true;
  return isHost || bet.owner === clientId;
}

function redrawBets(){
  betRows.innerHTML = '';
  if(!bets.length){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="4" style="color:var(--muted)">No bets yet.</td>`;
    betRows.appendChild(tr);
  }else{
    const sorted = [...bets].sort((a,b)=>{
      if(a.createdAt && b.createdAt){ return a.createdAt - b.createdAt; }
      return (a.name || '').localeCompare(b.name || '');
    });
    for(const b of sorted){
      const tr = document.createElement('tr');
      if(b.owner === clientId){
        tr.classList.add('mine');
      }
      const removeCell = canRemoveBet(b)
        ? `<button class="btn secondary" data-remove="${b.id}" style="padding:.4rem .6rem">Ã—</button>`
        : 'â€”';
      const ownerDetail = formatOwnerMeta(b.owner);
      tr.innerHTML = `
        <td>${escapeHTML(b.name||'â€”')}${ownerDetail}</td>
        <td>${ratName(b.ratId)}</td>
        <td class="right">${fmt(b.amount)}</td>
        <td class="right">${removeCell}</td>`;
      betRows.appendChild(tr);
    }
  }
  potEl.textContent = fmt(pot());
  renderSummaries();
}
function escapeHTML(s){ return (s??'').replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;",""":"&quot;","'":"&#039;"}[m])); }
function ratName(id){ return RAT_DATA.find(r=>r.id===id)?.name || id; }
function ratColor(id){ return RAT_DATA.find(r=>r.id===id)?.color || '#ffd13b'; }
function getLocalPlayerName(){ return bettorInput.value.trim() || playerName || 'You'; }
function defaultPlayerName(id){
  if(id === clientId) return getLocalPlayerName();
  if(!id) return 'Player';
  const tail = String(id).slice(-4).toUpperCase();
  return `Player ${tail}`;
}
function playerInitials(name){
  if(!name) return '?';
  const words = name.trim().split(/\s+/).filter(Boolean);
  if(!words.length) return '?';
  if(words.length === 1) return words[0].slice(0,2).toUpperCase();
  return (words[0][0] + words[words.length-1][0]).toUpperCase();
}
function avatarColorFor(id=''){
  let hash = 0;
  for(let i=0;i<id.length;i++){
    hash = (hash * 31 + id.charCodeAt(i)) >>> 0;
  }
  const hue = hash % 360;
  return `hsl(${hue}, 62%, 45%)`;
}
function computeOwnerStats(){
  const stats = {};
  for(const bet of bets){
    const owner = bet.owner || 'anon';
    const amount = Number(bet.amount) || 0;
    if(!stats[owner]){
      stats[owner] = { total:0, count:0, rats:{} };
    }
    stats[owner].total += amount;
    stats[owner].count += 1;
    stats[owner].rats[bet.ratId] = (stats[owner].rats[bet.ratId] || 0) + amount;
  }
  return stats;
}
function formatBetCount(count){
  return count === 1 ? '1 bet' : `${count || 0} bets`;
}
function playerDisplayInfo(ownerId){
  const info = players?.[ownerId];
  const name = ownerId === clientId
    ? getLocalPlayerName()
    : (info?.name?.trim() || defaultPlayerName(ownerId));
  return {
    id: ownerId,
    name,
    isHost: !!info?.isHost,
    you: ownerId === clientId,
    ghost: isMultiplayer && !!ownerId && !info
  };
}
function formatOwnerMeta(ownerId){
  if(!ownerId) return '';
  const info = playerDisplayInfo(ownerId);
  const badges = [];
  if(info.you) badges.push('<span class="playerBadge you">You</span>');
  if(info.isHost) badges.push('<span class="playerBadge host">Host</span>');
  if(info.ghost) badges.push('<span class="playerBadge ghost">Offline</span>');
  return `<div class="bettorOwner"><span class="ownerLabel">${escapeHTML(info.name)}</span>${badges.length ? `<span class="ownerBadges">${badges.join('')}</span>` : ''}</div>`;
}
function renderSummaries(){
  renderPlayerList();
  renderRatTotals();
}
function renderPlayerList(){
  if(!playerListEl) return;
  const ownerStats = computeOwnerStats();
  let entries = [];
  if(isMultiplayer){
    const activeEntries = Object.entries(players || {}).filter(([,value])=>value);
    entries = activeEntries.map(([id,value])=>({ id, data:value, stats: ownerStats[id] || { total:0, count:0, rats:{} } }));
    for(const ownerId of Object.keys(ownerStats)){
      if(!entries.find(e=>e.id===ownerId)){
        entries.push({ id: ownerId, data: null, stats: ownerStats[ownerId] });
      }
    }
    if(!entries.find(e=>e.id===clientId)){
      entries.push({ id: clientId, data: { name: getLocalPlayerName(), isHost }, stats: ownerStats[clientId] || { total:0, count:0, rats:{} } });
    }
  }else{
    entries = [{ id: clientId, data: { name: getLocalPlayerName(), isHost:true }, stats: ownerStats[clientId] || { total: pot(), count: bets.length, rats:{} } }];
  }
  entries.sort((a,b)=>{
    const aInfo = playerDisplayInfo(a.id);
    const bInfo = playerDisplayInfo(b.id);
    if(aInfo.you !== bInfo.you){ return aInfo.you ? -1 : 1; }
    if(aInfo.isHost !== bInfo.isHost){ return bInfo.isHost ? 1 : -1; }
    const aTotal = a.stats?.total || 0;
    const bTotal = b.stats?.total || 0;
    if(bTotal !== aTotal) return bTotal - aTotal;
    return aInfo.name.localeCompare(bInfo.name);
  });
  const count = entries.length;
  if(playerCountEl){
    playerCountEl.textContent = count ? (count === 1 ? '1 player' : `${count} players`) : 'No players';
  }
  if(!count){
    playerListEl.innerHTML = `<div class="emptyState">No players yet.</div>`;
    return;
  }
  playerListEl.innerHTML = entries.map(entry=>{
    const info = playerDisplayInfo(entry.id);
    const total = entry.stats?.total || 0;
    const countText = formatBetCount(entry.stats?.count || 0);
    const breakdownEntries = Object.entries(entry.stats?.rats || {}).filter(([,amt])=>amt>0).sort((a,b)=>b[1]-a[1]).slice(0,4);
    const breakdown = breakdownEntries.length
      ? `<div class="playerBreakdown">${breakdownEntries.map(([rid,amt])=>`<span class="ratPill" style="--rat-color:${ratColor(rid)}">${escapeHTML(ratName(rid))} <span>${fmt(amt)}</span></span>`).join('')}</div>`
      : `<div class="playerBreakdown playerBreakdown--empty">No bets yet.</div>`;
    const badges = [];
    if(info.you) badges.push('<span class="playerBadge you">You</span>');
    if(info.isHost) badges.push('<span class="playerBadge host">Host</span>');
    if(info.ghost) badges.push('<span class="playerBadge ghost">Offline</span>');
    const metaText = entry.stats?.count ? formatBetCount(entry.stats.count) : 'No bets yet';
    const metaContent = `${badges.length ? `<span class="playerBadges">${badges.join('')}</span>` : ''}<span>${metaText}</span>`;
    return `<div class="playerRow${info.you ? ' you' : ''}${info.ghost ? ' ghost' : ''}">
      <div class="playerRowTop">
        <div class="playerIdentity">
          <div class="playerAvatar" style="--avatar-color:${avatarColorFor(entry.id)}">${escapeHTML(playerInitials(info.name))}</div>
          <div class="playerInfo">
            <div class="playerName">${escapeHTML(info.name)}</div>
            <div class="playerMeta">${metaContent}</div>
          </div>
        </div>
        <div class="playerTotals">
          <strong>${fmt(total)}</strong>
          <span>${countText}</span>
        </div>
      </div>
      ${breakdown}
    </div>`;
  }).join('');
}
function renderRatTotals(){
  if(!ratTotalsEl) return;
  const totalPot = pot();
  if(poolMetaEl){
    poolMetaEl.textContent = totalPot ? `${fmt(totalPot)} total` : 'No bets yet';
  }
  const rows = RAT_DATA.map(r=>{
    const amount = totalOn(r.id);
    const count = bets.filter(b=>b.ratId===r.id).length;
    const share = totalPot ? Math.round((amount/totalPot)*100) : 0;
    const barPct = totalPot ? Math.max(6, (amount/totalPot)*100) : 0;
    const progress = amount > 0 ? `<div class="ratProgress" style="width:${Math.min(barPct,100)}%"></div>` : '';
    const metaParts = [];
    metaParts.push(count ? formatBetCount(count) : 'No bets');
    if(share) metaParts.push(`${share}% of pot`);
    return `<div class="ratRow${amount ? ' has-bets' : ''}">${progress}<div class="ratRowInner"><div class="ratInfo"><span class="ratSwatch" style="background:${ratColor(r.id)}"></span><span>${escapeHTML(r.name)}</span></div><div class="ratNumbers"><span class="ratAmount">${fmt(amount)}</span><span class="ratMeta">${metaParts.join(' â€¢ ')}</span></div></div></div>`;
  }).join('');
  ratTotalsEl.innerHTML = rows || `<div class="emptyState">No bets yet.</div>`;
}

addBetBtn.addEventListener('click', ()=>{
  if(isMultiplayer && remoteState.status !== 'open'){ statusEl.textContent = 'Betting is closed.'; return; }
  const name = bettorInput.value.trim();
  const ratId = sel.value;
  const amount = Math.max(1, Math.floor(Number(amountInput.value||0)));
  const bet = { id:generateId(), name, ratId, amount, owner:clientId, createdAt:Date.now() };
  if(isMultiplayer){
    if(!gamePath) return;
    const updatePayload = {};
    updatePayload[`${gamePath}/bets/${bet.id}`] = bet;
    update(rootRef, updatePayload).catch(err=>{
      console.warn('Failed to add bet', err);
      statusEl.textContent = 'Unable to add bet right now.';
    });
  }else{
    bets.push(bet);
    redrawBets();
  }
});

betRows.addEventListener('click', (e)=>{
  const id = e.target?.dataset?.remove;
  if(!id) return;
  const bet = bets.find(b=>b.id===id);
  if(!bet) return;
  if(isMultiplayer){
    if(!canRemoveBet(bet)) return;
    const updatePayload = {};
    updatePayload[`${gamePath}/bets/${id}`] = null;
    update(rootRef, updatePayload).catch(err=>{
      console.warn('Failed to remove bet', err);
    });
  }else{
    bets = bets.filter(b=>b.id!==id);
    redrawBets();
  }
});

/* ============== Race engine ============== */
let racing = false, finished = false, animId = 0, winner = null;
let countdownToken = 0;
let currentRaceSetup = null;
let postedResults = false;

function resetRacePositions(){
  for(const r of rats){
    r.x = 0;
    r.v = 0;
    r.baseSpeed = 0;
    r.wobbleAmp = 0;
    r.wobblePeriod = 160;
    r.wobblePhase = 0;
    r.el.style.left = '0px';
    r.el.style.transform = 'translate(0px,-50%)';
  }
  winner = null; finished=false; racing=false; currentRaceSetup=null; postedResults=false;
}
resetRacePositions();

function cancelCountdown(){ countdownToken++; statusEl.classList.remove('countdown'); }

async function startCountdown({ startTime=Date.now(), duration=2100 }={}){
  const token = ++countdownToken;
  statusEl.classList.add('countdown');
  const steps = [
    { value:3, offset:0 },
    { value:2, offset:700 },
    { value:1, offset:1400 }
  ];
  for(const step of steps){
    const wait = startTime + step.offset - Date.now();
    if(wait > 1) await sleep(wait);
    if(token !== countdownToken) return;
    const remaining = startTime + duration - Date.now();
    if(remaining <= 0) break;
    statusEl.textContent = `Racing in ${step.value}â€¦`;
  }
  const finalWait = startTime + duration - Date.now();
  if(finalWait > 1) await sleep(finalWait);
  if(token !== countdownToken) return;
  statusEl.textContent = 'Go!';
  await sleep(200);
  if(token !== countdownToken) return;
  statusEl.classList.remove('countdown');
}

function startRace(setup){
  const trackWidth = lanes.clientWidth - 26*2; // inner minus padding approx
  const finishX = trackWidth - 140; // where nose hits finish (rat width ~120)
  racing = true;
  finished = false;

  const configuration = setup || createRaceSetup();
  currentRaceSetup = configuration;

  const byId = new Map((configuration?.rats || []).map(cfg => [cfg.id, cfg]));
  for(const r of rats){
    const cfg = byId.get(r.id) || {};
    r.v = cfg.baseSpeed ?? (2.4 + Math.random()*0.9);
    r.baseSpeed = r.v;
    r.wobbleAmp = cfg.wobbleAmp ?? (0.25 + Math.random()*0.35);
    r.wobblePeriod = cfg.wobblePeriod ?? (140 + Math.random()*120);
    r.wobblePhase = cfg.wobblePhase ?? (Math.random()*Math.PI*2);
  }
  const t0 = performance.now();
  const step = (t)=>{
    const dt = Math.min(32, t - (step.t||t)); step.t = t;
    for(const r of rats){
      if(finished) break;
      const wobble = Math.sin(((t - t0)/ (r.wobblePeriod||160)) + (r.wobblePhase||0)) * (r.wobbleAmp||0.3);
      r.x += (r.baseSpeed + wobble) * (dt/16.7);
      if(r.x >= finishX && !winner){
        winner = r; finished = true; racing=false;
      }
      r.el.style.transform = `translate(${Math.max(0, r.x)}px,-50%)`;
    }
    if(!finished){ animId = requestAnimationFrame(step); }
    else {
      cancelAnimationFrame(animId);
      endRace();
    }
  };
  animId = requestAnimationFrame(step);
}

function endRace(options={}){
  if(!winner){ statusEl.textContent = 'No winner?!'; return; }
  statusEl.textContent = `Winner: ${winner.name}!`;
  const p = pot();
  const totalOnWin = totalOn(winner.id);
  const winners = bets.filter(b=>b.ratId===winner.id);
  resultRows.innerHTML = '';
  if(!winners.length){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="5">No one bet on ${winner.name}. House keeps the ${fmt(p)} pot.</td>`;
    resultRows.appendChild(tr);
    postWinnerToNetwork(winner.id, options);
    return;
  }
  for(const b of bets){
    const payout = b.ratId===winner.id ? (b.amount / totalOnWin) * p : 0;
    const net = payout - b.amount;
    const tr = document.createElement('tr');
    if(b.owner === clientId){ tr.classList.add('mine'); }
    const ownerDetail = formatOwnerMeta(b.owner);
    tr.innerHTML = `
      <td>${escapeHTML(b.name||'â€”')}${ownerDetail}</td>
      <td>${ratName(b.ratId)}</td>
      <td class="right">${fmt(b.amount)}</td>
      <td class="right ${payout? 'ok':''}">${payout? fmt(Math.round(payout)) : '$0'}</td>
      <td class="right ${net>0?'ok':(net<0?'bad':'')}">${net>0? '+'+fmt(Math.round(net)).slice(1): (net<0? '-'+fmt(Math.round(-net)).slice(1): '$0')}</td>
    `;
    resultRows.appendChild(tr);
  }
  postWinnerToNetwork(winner.id, options);
}

/* ============== Controls ============== */
closeBetsBtn.addEventListener('click', async ()=>{
  if(isMultiplayer){
    if(!isHost){ statusEl.textContent = 'Waiting for the host to start.'; return; }
    if(!bets.length){ statusEl.textContent = 'Place at least one bet.'; return; }
    await hostStartRace();
  }else{
    if(!bets.length){ statusEl.textContent = 'Place at least one bet.'; return; }
    toggleBetUI(true);
    const startTime = Date.now();
    await startCountdown({ startTime });
    startRace();
  }
});

resetBtn.addEventListener('click', ()=>{
  if(isMultiplayer){
    if(!isHost) return;
    hostResetRace();
  }else{
    bets = []; redrawBets();
    resultRows.innerHTML = `<tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr>`;
    statusEl.textContent = 'Place your bets.';
    toggleBetUI(false);
    resetRacePositions();
  }
});

function toggleBetUI(lock){
  addBetBtn.classList.toggle('muted', lock);
  addBetBtn.disabled = lock;
  closeBetsBtn.classList.toggle('muted', lock || (isMultiplayer && !isHost));
  closeBetsBtn.disabled = lock || (isMultiplayer && !isHost);
  resetBtn.classList.toggle('muted', isMultiplayer && !isHost);
  resetBtn.disabled = isMultiplayer && !isHost;
  for(const el of [bettorInput, sel, amountInput]){
    el.disabled = lock;
  }
}

/* ============== Utilities & SVG ============== */
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function generateId(){
  if(window.crypto?.randomUUID){
    return window.crypto.randomUUID();
  }
  return 'b'+Math.random().toString(36).slice(2,10)+Date.now().toString(36);
}

function createRaceSetup(){
  return {
    rats: RAT_DATA.map(r=>({
      id: r.id,
      baseSpeed: 2.4 + Math.random()*0.9,
      wobbleAmp: 0.25 + Math.random()*0.35,
      wobblePeriod: 140 + Math.random()*120,
      wobblePhase: Math.random()*Math.PI*2
    }))
  };
}

function ratSVG(color='#b9c2cc'){
  const darker = shade(color, -25);
  const highlight = shade(color, 22);
  const mid = shade(color, -8);
  const earInner = shade(color, 12);
  const sparkle = shade(color, 50);
  const gradId = `g${Math.random().toString(36).slice(2,8)}`;
  const headGradId = `h${Math.random().toString(36).slice(2,8)}`;
  return `
  <svg viewBox="0 0 240 130" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Racing rat">
    <defs>
      <linearGradient id="${gradId}" x1="40" y1="40" x2="210" y2="110" gradientUnits="userSpaceOnUse">
        <stop offset="0%" stop-color="${highlight}"/>
        <stop offset="40%" stop-color="${color}"/>
        <stop offset="100%" stop-color="${darker}"/>
      </linearGradient>
      <linearGradient id="${headGradId}" x1="120" y1="40" x2="220" y2="90" gradientUnits="userSpaceOnUse">
        <stop offset="0%" stop-color="${highlight}"/>
        <stop offset="60%" stop-color="${mid}"/>
        <stop offset="100%" stop-color="${darker}"/>
      </linearGradient>
      <filter id="ratShadow" x="-60%" y="-60%" width="220%" height="220%">
        <feDropShadow dx="0" dy="12" stdDeviation="10" flood-color="rgba(0,0,0,.45)" flood-opacity="1"/>
      </filter>
    </defs>
    <g filter="url(#ratShadow)">
      <path class="tail" d="M18 90 C 55 118, 110 118, 148 98" fill="none" stroke="#d89c86" stroke-width="7" stroke-linecap="round" stroke-linejoin="round"/>
      <g class="body-group">
        <path d="M70 64 C 60 40, 86 18, 138 22 C 188 26, 214 56, 208 86 C 202 114, 142 120, 106 108 C 78 98, 72 84, 70 64 Z" fill="url(#${gradId})"/>
        <ellipse cx="188" cy="66" rx="36" ry="30" fill="url(#${headGradId})"/>
        <ellipse cx="202" cy="46" rx="16" ry="14" fill="${earInner}" class="ear"/>
        <ellipse cx="205" cy="44" rx="8" ry="7" fill="${shade(color,-12)}" opacity=".75" class="ear"/>
        <path d="M174 70 q18 -12 36 0" fill="#f8c2b5" opacity=".25"/>
        <circle cx="206" cy="72" r="4.2" fill="#1a2033"/>
        <circle cx="207.6" cy="70.9" r="1.4" fill="#fff" opacity=".8"/>
        <path d="M224 75 q10 5 0 12" stroke="#f4a698" stroke-width="4" stroke-linecap="round"/>
        <path d="M198 86 q10 4 24 0" stroke="#f4a698" stroke-width="5" stroke-linecap="round"/>
        <path d="M128 104 q16 12 36 0" stroke="#f4a698" stroke-width="6" stroke-linecap="round"/>
        <path d="M156 112 q18 8 34 -4" stroke="#f4a698" stroke-width="6" stroke-linecap="round"/>
        <path d="M176 76 l-18 8" stroke="#f4a698" stroke-width="2.4" stroke-linecap="round"/>
        <path d="M176 82 l-18 8" stroke="#f4a698" stroke-width="2.4" stroke-linecap="round"/>
        <path d="M176 88 l-18 8" stroke="#f4a698" stroke-width="2.4" stroke-linecap="round"/>
        <path d="M168 62 C 150 60, 146 46, 150 34" stroke="${shade(color,-35)}" stroke-width="5" stroke-linecap="round" opacity=".28"/>
        <circle cx="216" cy="74" r="4.4" fill="#f7a9a0"/>
        <circle cx="217.2" cy="72.8" r="1.6" fill="#fff" opacity=".8"/>
        <circle class="sparkle" cx="118" cy="44" r="3" fill="${sparkle}" opacity=".4"/>
        <circle class="sparkle" cx="138" cy="38" r="2" fill="#fff" opacity=".6"/>
      </g>
    </g>
  </svg>`;
}
function shade(hex, amt){
  let c = hex.replace('#','');
  if(c.length===3) c = c.split('').map(ch=>ch+ch).join('');
  let [r,g,b]=[0,2,4].map(i=>parseInt(c.substring(i,i+2),16));
  const adj = v => Math.max(0,Math.min(255, Math.round(v + (amt/100)*255)));
  r=adj(r); g=adj(g); b=adj(b);
  return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
}

/* initial draw */
redrawBets();

/* ============== Multiplayer / Firebase ============== */
const firebaseConfig = {
  apiKey: "AIzaSyBN7Y6JcmhMf04ghX2KUoSHbrZMYGtSrDs",
  authDomain: "multiplayer-640ec.firebaseapp.com",
  databaseURL: "https://multiplayer-640ec-default-rtdb.firebaseio.com",
  projectId: "multiplayer-640ec",
  storageBucket: "multiplayer-640ec.firebasestorage.app",
  messagingSenderId: "739760736627",
  appId: "1:739760736627:web:5f7f92ea5af55f3d4dbebb",
  measurementId: "G-S6CYR8YP69"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const rootRef = ref(db);

const CLIENT_STORAGE_KEY = 'ratRaceClientId';
const NAME_STORAGE_KEY = 'ratRacePlayerName';
let playerName = '';
try{
  const stored = localStorage.getItem(NAME_STORAGE_KEY);
  if(stored){
    playerName = stored;
    bettorInput.value = stored;
  }
} catch(err){
  console.debug('Unable to access stored name', err);
}

const clientId = (()=>{
  try{
    const existing = localStorage.getItem(CLIENT_STORAGE_KEY);
    if(existing) return existing;
    const id = generateId();
    localStorage.setItem(CLIENT_STORAGE_KEY, id);
    return id;
  }catch(err){
    return generateId();
  }
})();

let isMultiplayer = false;
let isHost = false;
let roomId = null;
let gamePath = '';
let betsRef = null;
let stateRef = null;
let presenceRef = null;
let playersRef = null;
let unsubscribers = [];
let remoteState = { status:'open', countdownDuration:2100 };

function rememberPlayerName(name){
  try{
    localStorage.setItem(NAME_STORAGE_KEY, name);
  }catch(err){
    console.debug('Unable to persist name', err);
  }
}

function syncPresenceName(name){
  if(!isMultiplayer || !gamePath) return;
  const clean = (name || '').trim() || getLocalPlayerName() || 'Player';
  const now = Date.now();
  const payload = {};
  payload[`${gamePath}/players/${clientId}/name`] = clean;
  payload[`${gamePath}/players/${clientId}/lastSeen`] = now;
  update(rootRef, payload).catch(()=>{});
}

bettorInput.addEventListener('input', ()=>{
  renderSummaries();
});

bettorInput.addEventListener('blur', ()=>{
  const value = bettorInput.value.trim();
  if(value){
    playerName = value;
    rememberPlayerName(value);
  }
  renderSummaries();
  syncPresenceName(value);
});

function sanitizeRoomCode(value){
  const cleaned = String(value || '').replace(/[^a-zA-Z0-9]/g,'').slice(0,12);
  if(!cleaned) return '';
  if(cleaned.length <= 5){
    return cleaned.toUpperCase();
  }
  return cleaned.toLowerCase();
}

function generateRoomCode(){
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for(let i=0;i<5;i++){ code += chars[Math.floor(Math.random()*chars.length)]; }
  return code;
}

function detachListeners(){
  for(const unsub of unsubscribers){
    try{ unsub(); }catch(err){ console.debug('Listener cleanup failed', err); }
  }
  unsubscribers = [];
  if(presenceRef){
    try{ onDisconnect(presenceRef).cancel(); }catch(err){ /* ignore */ }
    presenceRef = null;
  }
  betsRef = null;
  stateRef = null;
  playersRef = null;
  players = {};
  renderSummaries();
}

function attachListeners(){
  if(!gamePath) return;
  betsRef = ref(db, `${gamePath}/bets`);
  stateRef = ref(db, `${gamePath}/state`);
  playersRef = ref(db, `${gamePath}/players`);
  unsubscribers.push(onValue(betsRef, snapshot=>{
    const data = snapshot.val() || {};
    bets = Object.values(data);
    redrawBets();
  }));
  unsubscribers.push(onValue(stateRef, snapshot=>{
    const data = snapshot.val();
    if(data && data.updatedBy === clientId) return;
    remoteState = { status:'open', countdownDuration:2100, ...(data||{}) };
    handleNetworkState(remoteState);
  }));
  unsubscribers.push(onValue(playersRef, snapshot=>{
    const raw = snapshot.val() || {};
    const filtered = Object.fromEntries(Object.entries(raw).filter(([,value])=>value));
    players = filtered;
    renderSummaries();
  }));
}

function handleNetworkState(state){
  const phase = state.status || 'open';
  if(phase === 'open'){
    cancelCountdown();
    statusEl.textContent = 'Place your bets.';
    if(state.resetResults){
      resultRows.innerHTML = `<tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr>`;
    }
    toggleBetUI(false);
    resetRacePositions();
  }else if(phase === 'countdown'){
    toggleBetUI(true);
    const startTime = state.countdownStartedAt || Date.now();
    startCountdown({ startTime, duration: state.countdownDuration || 2100 });
    currentRaceSetup = state.raceSetup || currentRaceSetup;
  }else if(phase === 'running'){
    toggleBetUI(true);
    if(state.raceSetup){ currentRaceSetup = state.raceSetup; }
    if(!racing){
      startRace(currentRaceSetup);
    }
  }else if(phase === 'finished'){
    toggleBetUI(true);
    cancelCountdown();
    if(state.winnerId){
      const rat = rats.find(r=>r.id===state.winnerId);
      if(rat){
        winner = rat;
        finished = true;
        racing = false;
        cancelAnimationFrame(animId);
        endRace({ triggeredByNetwork:true });
      }
    }
  }
}

function updateModeUI(){
  if(!isMultiplayer){
    mpNotice.textContent = 'You are playing solo.';
    roomInfo.hidden = true;
    joinControls.hidden = true;
    closeBetsBtn.textContent = 'Close Bets & Start';
    toggleBetUI(false);
  }else{
    const code = roomId || 'â€”';
    mpNotice.textContent = isHost
      ? `Hosting room ${code}. Share the code with friends.`
      : `Joined room ${code}. Place your bets!`;
    roomInfo.hidden = false;
    roomCodeEl.textContent = code;
    closeBetsBtn.textContent = isHost ? 'Close Bets & Start' : 'Waiting for Host';
    joinControls.hidden = true;
    toggleBetUI(remoteState.status !== 'open');
  }
}

function startSolo(){
  detachListeners();
  isMultiplayer = false;
  isHost = false;
  roomId = null;
  gamePath = '';
  bets = [];
  players = { [clientId]: { name: getLocalPlayerName(), isHost:true } };
  redrawBets();
  resultRows.innerHTML = `<tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr>`;
  statusEl.textContent = 'Place your bets.';
  resetRacePositions();
  toggleBetUI(false);
  window.location.hash = '';
  updateModeUI();
  renderSummaries();
}

async function hostStartRace(){
  if(!isHost || !isMultiplayer || !gamePath) return;
  const now = Date.now();
  const setup = createRaceSetup();
  currentRaceSetup = setup;
  const payload = {};
  payload[`${gamePath}/state`] = {
    status:'countdown',
    countdownStartedAt: now,
    countdownDuration: 2100,
    raceSetup: setup,
    winnerId: null,
    updatedBy: clientId,
    updatedAt: now
  };
  try{
    await update(rootRef, payload);
  }catch(err){
    console.warn('Failed to start countdown', err);
    statusEl.textContent = 'Unable to start race.';
    return;
  }
  toggleBetUI(true);
  await startCountdown({ startTime: now });
  const raceStart = Date.now();
  const runningPayload = {};
  runningPayload[`${gamePath}/state/status`] = 'running';
  runningPayload[`${gamePath}/state/raceSetup`] = setup;
  runningPayload[`${gamePath}/state/raceStartedAt`] = raceStart;
  runningPayload[`${gamePath}/state/updatedBy`] = clientId;
  runningPayload[`${gamePath}/state/updatedAt`] = raceStart;
  try{
    await update(rootRef, runningPayload);
  }catch(err){
    console.warn('Failed to announce race start', err);
  }
  startRace(setup);
}

function postWinnerToNetwork(winnerId, options={}){
  if(options.triggeredByNetwork) return;
  if(!isMultiplayer || !isHost || postedResults || !gamePath) return;
  postedResults = true;
  const now = Date.now();
  const payload = {};
  payload[`${gamePath}/state/status`] = 'finished';
  payload[`${gamePath}/state/winnerId`] = winnerId;
  payload[`${gamePath}/state/updatedBy`] = clientId;
  payload[`${gamePath}/state/updatedAt`] = now;
  update(rootRef, payload).catch(err=>{
    console.warn('Failed to publish winner', err);
    postedResults = false;
  });
}

function hostResetRace(){
  if(!isHost || !gamePath) return;
  bets = [];
  redrawBets();
  resultRows.innerHTML = `<tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr>`;
  resetRacePositions();
  const now = Date.now();
  const payload = {};
  payload[`${gamePath}/bets`] = null;
  payload[`${gamePath}/state`] = {
    status:'open',
    winnerId:null,
    countdownDuration:2100,
    updatedBy: clientId,
    updatedAt: now,
    resetResults:true
  };
  update(rootRef, payload).catch(err=>{
    console.warn('Failed to reset race', err);
  });
}

function joinRoom(code, { host=false }={}){
  const sanitized = sanitizeRoomCode(code);
  if(!sanitized) return;
  detachListeners();
  isMultiplayer = true;
  isHost = host;
  roomId = sanitized;
  gamePath = `ratRaces/${roomId}`;
  bets = [];
  redrawBets();
  resultRows.innerHTML = `<tr><td colspan="5" style="color:var(--muted)">No results yet.</td></tr>`;
  players = { [clientId]: { name: getLocalPlayerName(), isHost: host } };
  renderSummaries();
  remoteState = { status:'open', countdownDuration:2100 };
  window.location.hash = roomId;
  updateModeUI();
  attachListeners();
  const now = Date.now();
  const presencePath = `${gamePath}/players/${clientId}`;
  presenceRef = ref(db, presencePath);
  const presenceData = {
    name: bettorInput.value || playerName || 'Player',
    isHost,
    lastSeen: now
  };
  update(rootRef, { [presencePath]: presenceData }).catch(()=>{});
  try{
    onDisconnect(presenceRef).remove();
  }catch(err){/* ignore */}
  if(host){
    const initPayload = {};
    initPayload[`${gamePath}/bets`] = null;
    initPayload[`${gamePath}/state`] = {
      status:'open',
      countdownDuration:2100,
      winnerId:null,
      updatedBy: clientId,
      updatedAt: now,
      resetResults:true
    };
    update(rootRef, initPayload).catch(err=>console.warn('Failed to prepare room', err));
  }
  toggleBetUI(false);
  syncPresenceName(bettorInput.value);
}

function showJoinControls(show){
  joinControls.hidden = !show;
  if(show){
    joinCodeInput.value = '';
    setTimeout(()=> joinCodeInput.focus(), 50);
  }
}

soloBtn.addEventListener('click', ()=> startSolo());
hostBtn.addEventListener('click', ()=>{
  const code = generateRoomCode();
  joinRoom(code, { host:true });
});
joinBtn.addEventListener('click', ()=>{
  showJoinControls(true);
});

joinConfirmBtn.addEventListener('click', ()=>{
  const code = sanitizeRoomCode(joinCodeInput.value);
  if(!code){
    joinCodeInput.focus();
    return;
  }
  joinRoom(code, { host:false });
});

joinCodeInput.addEventListener('keydown', event=>{
  if(event.key === 'Enter'){
    event.preventDefault();
    joinConfirmBtn.click();
  }
});

joinCodeInput.addEventListener('input', ()=>{
  joinCodeInput.value = sanitizeRoomCode(joinCodeInput.value);
});

if(copyRoomBtn){
  copyRoomBtn.addEventListener('click', async ()=>{
    if(roomInfo.hidden) return;
    const code = roomCodeEl.textContent?.trim();
    if(!code || code === 'â€”') return;
    const success = await copyTextToClipboard(code);
    copyRoomBtn.textContent = success ? 'Copied!' : 'Press Ctrl+C';
    setTimeout(()=>{
      copyRoomBtn.textContent = 'Copy Code';
    }, success ? 1600 : 2600);
  });
}

async function copyTextToClipboard(text){
  if(!navigator.clipboard) {
    try{
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      const success = document.execCommand('copy');
      document.body.removeChild(textarea);
      return success;
    }catch(err){
      console.warn('Clipboard fallback failed', err);
      return false;
    }
  }
  try{
    await navigator.clipboard.writeText(text);
    return true;
  }catch(err){
    console.warn('Clipboard copy failed', err);
    return false;
  }
}

const initialCode = sanitizeRoomCode(window.location.hash.replace('#',''));
if(initialCode){
  joinRoom(initialCode, { host:false });
}else{
  startSolo();
}

isSupported()
  .then((supported)=>{ if(supported){ getAnalytics(app); } })
  .catch(err=>console.warn('Firebase analytics not supported', err));

</script>
</body>
</html>
