<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bass Fret Trainer</title>
<style>
  :root{
    --bg:#0b0f16;
    --panel:#0f1624;
    --wood1:#6b4a2d;
    --wood2:#8b5e36;
    --metal:#cfd8dc;
    --fret:#c0c9d2;
    --string:#e5e7eb;
    --nut:#d6dee6;
    --dot:#1f2937;
    --accent:#38bdf8;
    --good:#22c55e;
    --bad:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 70% -10%, #142032 0%, var(--bg) 50%);
    display:flex; align-items:center; justify-content:center; padding:12px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    color:#e7eefc;
  }
  .app{
    width:min(1600px, 98vw);
    background:linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08);
    border-radius:18px;
    box-shadow: 0 20px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
    overflow:hidden;
  }
  .board{
    position:relative;
    width:100%;
    aspect-ratio: 1246 / 439;
    background:
      radial-gradient(140% 120% at 50% 0%, rgba(56,189,248,.08), transparent 70%),
      linear-gradient(180deg, rgba(12,18,30,.65), rgba(12,18,30,.1)),
      repeating-linear-gradient(90deg, rgba(139,94,54,.62) 0 34px, rgba(107,74,45,.58) 34px 68px),
      linear-gradient(180deg, var(--wood1), var(--wood2));
    background-size: 100% 100%;
    background-position: center;
    background-repeat: no-repeat;
    overflow:hidden;
  }
  .board::before{
    content:"";
    position:absolute;
    inset:0;
    background:
      radial-gradient(130% 140% at 50% 105%, rgba(5,7,13,.72), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.09), transparent 40%);
    mix-blend-mode: soft-light;
    pointer-events:none;
  }
  svg{display:block; width:100%; height:100%; position:absolute; inset:0; pointer-events:none;}
  .controls{
    display:flex; align-items:center; justify-content:center; gap:10px;
    padding:10px; background:linear-gradient(180deg, #0e1523, #0c1320);
    border-top:1px solid rgba(255,255,255,.06);
  }
  .notes{
    display:grid;
    grid-template-columns: repeat(12, minmax(40px, 1fr));
    gap:8px; width:100%; max-width:980px;
  }
  button.note{
    appearance:none; border:none; cursor:pointer;
    padding:.8rem 0; border-radius:12px;
    background:linear-gradient(180deg, #0f1b2d, #0b1422);
    border:1px solid rgba(255,255,255,.08);
    color:#eaf2ff; font-weight:700; font-size:1.05rem; letter-spacing:.5px;
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    transition: transform .06s ease, background .2s ease, border-color .2s ease;
  }
  button.note:active{ transform:translateY(1px) scale(.995) }
  button.note:hover{ border-color: rgba(255,255,255,.18) }
  .bar{
    display:flex; align-items:center; gap:10px; justify-content:space-between;
    padding:12px 14px; border-top:1px solid rgba(255,255,255,.06);
    background:linear-gradient(180deg, #0f1829, #0d1422);
  }
  .left, .right{display:flex; align-items:center; gap:8px}
  .iconbtn{
    width:40px; height:40px; border-radius:12px; display:grid; place-items:center;
    border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg, #0e1727, #0b1220);
    color:#cfe8ff; cursor:pointer; transition:.2s;
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    user-select:none;
  }
  .iconbtn:hover{ border-color: rgba(255,255,255,.18) }
  .pill{
    min-width:40px; height:40px; padding:0 12px; border-radius:999px;
    display:flex; align-items:center; justify-content:center; gap:6px;
    border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg, #0e1727, #0b1220);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    font-weight:700; letter-spacing:.3px;
  }
  .light{ opacity:.75 }
  .flash{
    position:absolute; inset:0; pointer-events:none; opacity:0;
    transition: opacity .18s ease;
  }
  .flash.good{ background: radial-gradient(70% 60% at 50% 50%, rgba(34,197,94,.18), transparent 70%) }
  .flash.bad{  background: radial-gradient(70% 60% at 50% 50%, rgba(239,68,68,.20), transparent 70%) }
  .flash.show{ opacity:1 }
  .highlight-glow{
    filter: drop-shadow(0 0 16px rgba(56,189,248,.85)) drop-shadow(0 0 32px rgba(56,189,248,.55));
  }
  .fret-target{
    fill: rgba(56,189,248,.18);
    stroke: rgba(56,189,248,.45);
    stroke-width:3;
    mix-blend-mode: screen;
  }
  .string-target{
    fill: rgba(56,189,248,.75);
    mix-blend-mode: screen;
  }
  @media (max-width:720px){
    .notes{gap:6px}
    button.note{font-size:1rem; padding:.7rem 0}
    .iconbtn{width:36px; height:36px; border-radius:10px}
    .pill{height:36px; padding:0 10px}
  }
</style>
</head>
<body>
  <div class="app">
    <div class="board" id="board">
      <!-- feedback flashes -->
      <div class="flash" id="flash"></div>
      <!-- SVG fretboard -->
      <svg id="fretSVG" viewBox="0 0 1246 439" aria-label="Bass Fretboard" role="img">
        <!-- wood background handled by CSS -->
        <!-- fret slots group (for layering) -->
        <g id="frets"></g>

        <!-- inlay dots -->
        <g id="inlays"></g>

        <!-- strings -->
        <g id="strings"></g>

        <!-- highlight target (string+fret) -->
        <g id="target"></g>

      </svg>
    </div>

    <div class="bar">
      <div class="left">
        <!-- ‚ôØ / ‚ô≠ toggle -->
        <div class="iconbtn" id="accToggle" title="Toggle sharps/flats" aria-label="Toggle sharps/flats">‚ôØ/‚ô≠</div>
        <!-- reveal helper (shows answer briefly) -->
        <div class="iconbtn" id="reveal" title="Peek" aria-label="Peek">üëÅÔ∏è</div>
      </div>
      <div class="right">
        <!-- streak pill (no words) -->
        <div class="pill" id="streak" aria-label="Streak">‚úÖ√ó0</div>
        <!-- reset -->
        <div class="iconbtn" id="reset" title="Reset" aria-label="Reset">‚ü≤</div>
      </div>
    </div>

    <div class="controls">
      <div class="notes" id="noteButtons"></div>
    </div>
  </div>

<script>
(()=>{
  // ---------- Constants ----------
  const SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
  // Standard 4-string bass tuning, top to bottom visually: G, D, A, E
  const OPEN_STRING_NOTES = { G:7, D:2, A:9, E:4 }; // indices in SHARP
  const STRINGS_ORDER = ["G","D","A","E"]; // render order top->bottom
  const NUM_FRETS = 12; // choose range (0..12). Change if you want more
  // Tuned to the provided photograph ‚Äî tweak these numbers to realign the overlay if you swap imagery
  const FRETBOARD = {
    left: 300,
    right: 1044,
    top: 148,
    bottom: 292
  };
  const SCALE_PX = (FRETBOARD.right - FRETBOARD.left) * 2;
  const FRET_PAD_X = 10;
  const FRET_PAD_Y = 20;

  // ---------- State ----------
  let useSharps = true;
  let current = { stringIndex: 0, fret: 0, answerIdx: 0 };
  let streak = 0;
  let peekTimeout = null;

  // ---------- DOM ----------
  const fretsG   = document.getElementById('frets');
  const stringsG = document.getElementById('strings');
  const inlaysG  = document.getElementById('inlays');
  const targetG  = document.getElementById('target');
  const noteButtons = document.getElementById('noteButtons');
  const flashEl  = document.getElementById('flash');
  const streakEl = document.getElementById('streak');
  const accToggle= document.getElementById('accToggle');
  const revealBtn= document.getElementById('reveal');
  const resetBtn = document.getElementById('reset');

  // ---------- Geometry Helpers ----------
  const fretXs = []; // x of each fret line
  (function computeFrets(){
    for(let i=0;i<=NUM_FRETS;i++){
      const ratio = 1 - Math.pow(2, -i/12);
      const x = FRETBOARD.right - SCALE_PX * ratio;
      fretXs[i] = x;
    }
  })();

  function stringY(i){
    // 4 strings across usable height
    const innerH = FRETBOARD.bottom - FRETBOARD.top;
    return FRETBOARD.top + (innerH)*(i/(STRINGS_ORDER.length-1));
  }

  function midBetween(a,b){ return a + (b-a)/2 }

  // ---------- Build Fretboard ----------
  function svgEl(tag, attrs={}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.entries(attrs).forEach(([key, value])=> el.setAttribute(key, value));
    return el;
  }

  function circle(cx, cy, r, fill, opacity=1){
    const c = svgEl("circle", { cx, cy, r, fill, opacity });
    return c;
  }

  function drawFrets(){
    fretsG.innerHTML = "";
    const frag = document.createDocumentFragment();
    const yStart = FRETBOARD.top - 26;
    const yEnd = FRETBOARD.bottom + 26;

    for(let i=0; i<=NUM_FRETS; i++){
      const x = fretXs[i];
      const isNut = i === 0;
      const stroke = isNut ? "var(--nut)" : "var(--fret)";
      const width = isNut ? 12 : 6;

      const base = svgEl("line", {
        x1: x,
        y1: yStart,
        x2: x,
        y2: yEnd,
        stroke,
        "stroke-width": width,
        "stroke-linecap": "round",
        opacity: isNut ? 0.95 : 0.85
      });
      frag.appendChild(base);

      const shine = svgEl("line", {
        x1: x - (isNut ? 3.2 : 2),
        y1: yStart,
        x2: x - (isNut ? 3.2 : 2),
        y2: yEnd,
        stroke: "rgba(255,255,255,.55)",
        "stroke-width": isNut ? 2.6 : 1.4,
        "stroke-linecap": "round",
        opacity: 0.65
      });
      frag.appendChild(shine);

      if(!isNut){
        const shadow = svgEl("line", {
          x1: x + 2.4,
          y1: yStart,
          x2: x + 2.4,
          y2: yEnd,
          stroke: "rgba(5,10,18,.55)",
          "stroke-width": 2.6,
          "stroke-linecap": "round",
          opacity: 0.45
        });
        frag.appendChild(shadow);
      }
    }

    fretsG.appendChild(frag);
  }

  function drawInlays(){
    inlaysG.innerHTML = "";
    const frag = document.createDocumentFragment();
    const singles = [3,5,7,9];
    const radius = 16;
    const centerY = midBetween(stringY(0), stringY(STRINGS_ORDER.length-1));

    singles.forEach(fretNum => {
      if(fretNum >= NUM_FRETS || fretNum + 1 >= fretXs.length) return;
      const cx = midBetween(fretXs[fretNum], fretXs[fretNum+1]);
      const dot = circle(cx, centerY, radius, "rgba(238,242,248,.94)");
      dot.setAttribute("stroke", "rgba(15,23,42,.28)");
      dot.setAttribute("stroke-width", 4);
      frag.appendChild(dot);

      const gleam = circle(cx, centerY, radius-5, "rgba(255,255,255,.55)", 0.55);
      frag.appendChild(gleam);
    });

    if(NUM_FRETS >= 12){
      const cx = midBetween(fretXs[11], fretXs[12]);
      const offset = 32;
      [centerY - offset/2, centerY + offset/2].forEach(cy => {
        const dot = circle(cx, cy, radius, "rgba(238,242,248,.94)");
        dot.setAttribute("stroke", "rgba(15,23,42,.28)");
        dot.setAttribute("stroke-width", 4);
        frag.appendChild(dot);

        const gleam = circle(cx, cy, radius-5, "rgba(255,255,255,.55)", 0.55);
        frag.appendChild(gleam);
      });
    }

    inlaysG.appendChild(frag);
  }

  function drawStrings(){
    stringsG.innerHTML = "";
    const frag = document.createDocumentFragment();
    const overhang = 60;
    const x = FRETBOARD.left - overhang;
    const width = (FRETBOARD.right - FRETBOARD.left) + overhang * 2;

    STRINGS_ORDER.forEach((_, idx) => {
      const thickness = 5 + (STRINGS_ORDER.length - idx - 1) * 1.4;
      const cy = stringY(idx);
      const y = cy - thickness/2;

      const base = svgEl("rect", {
        x,
        y,
        width,
        height: thickness,
        rx: thickness/2,
        fill: "rgba(229,231,235,.82)",
      });
      frag.appendChild(base);

      const highlight = svgEl("rect", {
        x,
        y: y + 1,
        width,
        height: thickness * 0.45,
        rx: thickness/2,
        fill: "rgba(255,255,255,.6)",
        opacity: 0.65
      });
      frag.appendChild(highlight);

      const shadow = svgEl("rect", {
        x,
        y: cy + thickness * 0.05,
        width,
        height: thickness * 0.42,
        rx: thickness/2,
        fill: "rgba(15,23,42,.35)",
        opacity: 0.45
      });
      frag.appendChild(shadow);
    });

    stringsG.appendChild(frag);
  }
  // ---------- Target Highlight ----------
  function renderTarget(){
    targetG.innerHTML = "";
    const i = current.stringIndex;
    const f = current.fret;

    // glowing puck at the middle of the fret segment on that string
    const startX = Math.min(fretXs[f], fretXs[f+1]);
    const endX = Math.max(fretXs[f], fretXs[f+1]);
    const width = endX - startX;
    const cx = midBetween(startX, endX);
    const cy = stringY(i);

    const fretRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    fretRect.setAttribute("x", startX - FRET_PAD_X);
    fretRect.setAttribute("y", FRETBOARD.top - FRET_PAD_Y);
    fretRect.setAttribute("width", width + FRET_PAD_X*2);
    fretRect.setAttribute("height", (FRETBOARD.bottom - FRETBOARD.top) + FRET_PAD_Y*2);
    fretRect.setAttribute("rx", 18);
    fretRect.setAttribute("ry", 18);
    fretRect.classList.add('fret-target','highlight-glow');

    const stringRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    const stringHeight = 7;
    const innerWidth = Math.max(12, width - 36);
    const stringX = startX + (width - innerWidth)/2;
    stringRect.setAttribute("x", stringX);
    stringRect.setAttribute("y", cy - stringHeight/2);
    stringRect.setAttribute("width", innerWidth);
    stringRect.setAttribute("height", stringHeight);
    stringRect.setAttribute("rx", stringHeight/2);
    stringRect.classList.add('string-target','highlight-glow');

    const core  = circle(cx, cy, 7.5, "var(--accent)", 1);

    targetG.appendChild(fretRect);
    targetG.appendChild(stringRect);
    targetG.appendChild(core);
  }

  // ---------- Notes & Answers ----------
  const enharmonics = {
    "A#":"Bb","Bb":"A#",
    "C#":"Db","Db":"C#",
    "D#":"Eb","Eb":"D#",
    "F#":"Gb","Gb":"F#",
    "G#":"Ab","Ab":"G#"
  };

  function idxFromName(name){
    const i = SHARP.indexOf(name);
    if(i !== -1) return i;
    // maybe it's a flat name
    const j = FLAT.indexOf(name);
    return j;
  }

  function noteAt(stringIndex, fret){
    const openName = STRINGS_ORDER[stringIndex];
    const openIdx = OPEN_STRING_NOTES[openName];
    return (openIdx + fret) % 12;
  }

  function nextQuestion(){
    // random string 0..3, random fret 0..NUM_FRETS (inclusive of 0 exclusive of last segment for target)
    current.stringIndex = Math.floor(Math.random()*STRINGS_ORDER.length);
    current.fret = Math.floor(Math.random()*NUM_FRETS); // 0..11 if NUM_FRETS=12 (uses segment before next line)
    current.answerIdx = noteAt(current.stringIndex, current.fret);
    renderTarget();
  }

  // ---------- Buttons ----------
  function renderButtons(){
    noteButtons.innerHTML = "";
    const labels = useSharps ? SHARP : FLAT;
    labels.forEach(n=>{
      const btn = document.createElement('button');
      btn.className = 'note';
      btn.textContent = n;
      btn.setAttribute('aria-label', n);
      btn.addEventListener('click', ()=> handleGuess(n));
      noteButtons.appendChild(btn);
    });
  }

  function answersMatch(guessName, answerIdx){
    const guessIdx = idxFromName(guessName);
    if(guessIdx === answerIdx) return true;
    // accept enharmonic equivalents (e.g., Bb vs A#)
    const alt = enharmonics[guessName];
    if(alt){
      const altIdx = idxFromName(alt);
      return altIdx === answerIdx;
    }
    return false;
  }

  function flash(type){
    flashEl.className = 'flash ' + (type==='good' ? 'good' : 'bad') + ' show';
    setTimeout(()=> flashEl.classList.remove('show'), 160);
  }

  function handleGuess(name){
    if(answersMatch(name, current.answerIdx)){
      streak++;
      streakEl.textContent = "‚úÖ√ó"+streak;
      flash('good');
      nextQuestion();
    }else{
      streak = 0;
      streakEl.textContent = "‚úÖ√ó0";
      flash('bad');
      // brief wobble animation on target
      wobbleTarget();
    }
  }

  function wobbleTarget(){
    targetG.animate([
      { transform: 'translateX(0px)' },
      { transform: 'translateX(-6px)' },
      { transform: 'translateX(6px)' },
      { transform: 'translateX(0px)' },
    ], { duration: 180, easing: 'ease-out' });
  }

  // ---------- Peek / Reset / Toggle ----------
  accToggle.addEventListener('click', ()=>{
    useSharps = !useSharps;
    renderButtons();
  });

  revealBtn.addEventListener('click', ()=>{
    if(peekTimeout) { clearTimeout(peekTimeout); peekTimeout=null; }
    // show answer as a soft ring that fades
    const cx = midBetween(fretXs[current.fret], fretXs[current.fret+1]);
    const cy = stringY(current.stringIndex);
    const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
    ring.setAttribute("cx", cx); ring.setAttribute("cy", cy);
    ring.setAttribute("r", 52); ring.setAttribute("fill","none");
    ring.setAttribute("stroke","rgba(255,255,255,.28)");
    ring.setAttribute("stroke-width","4");
    targetG.appendChild(ring);
    ring.animate([{opacity:1, r:52},{opacity:0, r:88}], {duration:650, easing:'ease-out'}).onfinish=()=> ring.remove();
  });

  resetBtn.addEventListener('click', ()=>{
    streak = 0; streakEl.textContent = "‚úÖ√ó0";
    nextQuestion();
  });

  // ---------- Init ----------
  function init(){
    drawFrets();
    drawInlays();
    drawStrings();
    renderButtons();
    nextQuestion();
  }
  init();

  // Optional: keyboard input (A..G with optional # or b). No labels shown; just a convenience.
  const keyMap = new Set(["A","B","C","D","E","F","G","#","b"]);
  let lastLetter = null;
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toUpperCase();
    if(!keyMap.has(k) && k !== "ARROWRIGHT" && k!==" "){ return; }
    if(k===" " || k==="ARROWRIGHT"){ e.preventDefault(); nextQuestion(); return; }
    if("ABCDEFG".includes(k)){
      lastLetter = k;
      // if single letter is a complete note (A,B,C,D,E,F,G) it might be enough; wait briefly for accidental
      setTimeout(()=>{ if(lastLetter){ handleGuess(lastLetter); lastLetter=null; } }, 180);
    }else if(k==="#" || e.key==="b"){
      if(lastLetter){
        const name = lastLetter + (k==="#" ? "#" : "b");
        lastLetter = null;
        handleGuess(name);
      }
    }
  });

})();
</script>
</body>
</html>
