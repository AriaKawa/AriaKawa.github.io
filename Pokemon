// Firebase Pokémon Typing Battle — single-file React app
// Instructions:
// 1) Create a new Vite React project or drop this file into a React environment.
// 2) Install deps: npm i firebase
// 3) Replace the firebaseConfig below with your project's config.
// 4) Add the provided Firestore security rules (see bottom comments).
// 5) Run: npm run dev
//
// Features:
// - Create/Join lobby by room code
// - Host can start a 3-second countdown, then 60-second round
// - Players type Pokémon names; no repeats across the room
// - Validates against the full Pokédex fetched from PokéAPI
// - Real-time leaderboard
// - Simple anti-duplicate via Firestore transaction: each Pokémon is stored once per room in entries/{normalizedName}
// - Minimal UI; Tailwind optional (not required)

import React, { useEffect, useMemo, useRef, useState } from 'react'
import { createRoot } from 'react-dom/client'
import {
  initializeApp
} from 'firebase/app'
import {
  getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, serverTimestamp, collection, runTransaction, addDoc, query, orderBy, limit, where, getDocs
} from 'firebase/firestore'
import { v4 as uuidv4 } from 'uuid'

// If your bundler complains about uuid, install: npm i uuid
// Or use a simple fallback:
const fallbackUUID = () => Math.random().toString(36).slice(2) + Date.now().toString(36)

// ======== 1) Firebase config ========
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT.firebaseapp.com",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_PROJECT.appspot.com",
  messagingSenderId: "YOUR_SENDER_ID",
  appId: "YOUR_APP_ID",
}

const app = initializeApp(firebaseConfig)
const db = getFirestore(app)

// ======== 2) Helpers ========
const normalizeName = (s) => s.toLowerCase().replace(/[^a-z0-9]/g, '')

const useLocalId = () => {
  const [id, setId] = useState(() => {
    const existing = localStorage.getItem('ptb_player_id')
    if (existing) return existing
    const id = (uuidv4 ? uuidv4() : fallbackUUID())
    localStorage.setItem('ptb_player_id', id)
    return id
  })
  return id
}

const nowMs = () => Date.now()

const secondsLeft = (endsAtMs) => Math.max(0, Math.ceil((endsAtMs - nowMs()) / 1000))

// Fetch full Pokédex names from PokéAPI once and cache in memory/localStorage
const usePokedex = () => {
  const [names, setNames] = useState(new Set())
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    const cached = localStorage.getItem('ptb_pokedex_v2')
    if (cached) {
      try {
        const arr = JSON.parse(cached)
        setNames(new Set(arr))
        setLoading(false)
        return
      } catch {}
    }

    const fetchAll = async () => {
      try {
        setLoading(true)
        // Large limit to cover all gens
        const url = 'https://pokeapi.co/api/v2/pokemon?limit=2000'
        const res = await fetch(url)
        if (!res.ok) throw new Error('Failed to fetch Pokédex')
        const data = await res.json()
        const raw = data.results?.map((p) => p.name) || []

        // Also fetch forms like "mr-mime", variants are okay; normalize against user inputs later
        const arr = Array.from(new Set(raw))
        localStorage.setItem('ptb_pokedex_v2', JSON.stringify(arr))
        setNames(new Set(arr))
      } catch (e) {
        setError(e.message)
      } finally {
        setLoading(false)
      }
    }

    fetchAll()
  }, [])

  const isValid = (input) => {
    if (!input) return false
    const norm = input.toLowerCase().trim()
    if (names.has(norm)) return true
    // Light aliasing
    const aliases = {
      // Some common punctuation variants
      "nidoran♀": "nidoran-f",
      "nidoran♂": "nidoran-m",
      "farfetch’d": "farfetchd",
      "mr mime": "mr-mime",
      "mime jr": "mime-jr",
      "type null": "type-null",
      "jangmo o": "jangmo-o",
      "hakamo o": "hakamo-o",
      "kommo o": "kommo-o",
      "tapu koko": "tapu-koko",
      "tapu lele": "tapu-lele",
      "tapu bulu": "tapu-bulu",
      "tapu fini": "tapu-fini",
    }
    const alt = aliases[norm]
    return alt ? names.has(alt) : false
  }

  return { loading, error, isValid }
}

// ======== 3) Firestore data model ========
// rooms/{roomCode}
//   status: 'lobby' | 'countdown' | 'playing' | 'ended'
//   createdAt: serverTimestamp
//   hostId: string
//   startedAt: number (ms)
//   endsAt: number (ms)
// rooms/{roomCode}/players/{playerId}
//   name: string
//   score: number
//   joinedAt: serverTimestamp
// rooms/{roomCode}/entries/{normalizedName}
//   name: original user input (for display)
//   playerId: string
//   createdAt: serverTimestamp

async function createRoom(db, roomCode, hostId) {
  const roomRef = doc(db, 'rooms', roomCode)
  const snap = await getDoc(roomRef)
  if (snap.exists()) throw new Error('Room already exists')
  await setDoc(roomRef, {
    status: 'lobby',
    createdAt: serverTimestamp(),
    hostId,
    startedAt: null,
    endsAt: null,
  })
}

async function joinRoom(db, roomCode, playerId, name) {
  const roomRef = doc(db, 'rooms', roomCode)
  const roomSnap = await getDoc(roomRef)
  if (!roomSnap.exists()) throw new Error('Room not found')
  await setDoc(doc(db, 'rooms', roomCode, 'players', playerId), {
    name,
    score: 0,
    joinedAt: serverTimestamp(),
  }, { merge: true })
}

async function startGame(db, roomCode, durationMs = 60000) {
  const roomRef = doc(db, 'rooms', roomCode)
  const startMs = Date.now() + 3000 // 3s countdown
  const endMs = startMs + durationMs
  await updateDoc(roomRef, {
    status: 'countdown',
    startedAt: startMs,
    endsAt: endMs,
  })
  // After 3 seconds, flip to playing (client UIs rely on status+times, but this helps)
  setTimeout(async () => {
    await updateDoc(roomRef, { status: 'playing' })
    setTimeout(async () => {
      await updateDoc(roomRef, { status: 'ended' })
    }, durationMs)
  }, 3000)
}

async function submitEntry(db, roomCode, playerId, inputName) {
  const norm = normalizeName(inputName)
  const roomRef = doc(db, 'rooms', roomCode)
  const entryRef = doc(db, 'rooms', roomCode, 'entries', norm)
  const playerRef = doc(db, 'rooms', roomCode, 'players', playerId)

  return await runTransaction(db, async (tx) => {
    const roomSnap = await tx.get(roomRef)
    if (!roomSnap.exists()) throw new Error('Room missing')
    const { status, endsAt } = roomSnap.data()
    if (status !== 'playing' || !endsAt || Date.now() > endsAt) {
      throw new Error('Round is not active')
    }

    const exists = await tx.get(entryRef)
    if (exists.exists()) {
      throw new Error('That Pokémon was already used!')
    }
    // Create entry
    tx.set(entryRef, {
      name: inputName.trim(),
      playerId,
      createdAt: serverTimestamp(),
    })
    // Increment score
    const playerSnap = await tx.get(playerRef)
    const curr = playerSnap.exists() ? (playerSnap.data().score || 0) : 0
    tx.set(playerRef, { score: curr + 1 }, { merge: true })
  })
}

// ======== 4) UI Components ========
function App() {
  const playerId = useLocalId()
  const { loading: dexLoading, error: dexError, isValid } = usePokedex()

  const [roomCode, setRoomCode] = useState('')
  const [name, setName] = useState('')
  const [me, setMe] = useState(null)
  const [room, setRoom] = useState(null)
  const [players, setPlayers] = useState([])
  const [entries, setEntries] = useState([])
  const [input, setInput] = useState('')
  const [feedback, setFeedback] = useState('')

  const roomRef = useMemo(() => roomCode ? doc(db, 'rooms', roomCode) : null, [roomCode])

  useEffect(() => {
    if (!roomRef) return
    const unsub = onSnapshot(roomRef, (snap) => {
      setRoom(snap.exists() ? { id: snap.id, ...snap.data() } : null)
    })
    return () => unsub()
  }, [roomRef])

  useEffect(() => {
    if (!roomCode) return
    const playersRef = collection(db, 'rooms', roomCode, 'players')
    const unsub = onSnapshot(playersRef, (snap) => {
      const arr = snap.docs.map((d) => ({ id: d.id, ...d.data() }))
      arr.sort((a, b) => (b.score || 0) - (a.score || 0))
      setPlayers(arr)
      const mine = arr.find((p) => p.id === playerId)
      setMe(mine || null)
    })
    return () => unsub()
  }, [roomCode, playerId])

  useEffect(() => {
    if (!roomCode) return
    const entriesRef = collection(db, 'rooms', roomCode, 'entries')
    const q = query(entriesRef, orderBy('createdAt', 'desc'), limit(20))
    const unsub = onSnapshot(q, (snap) => {
      const arr = snap.docs.map((d) => ({ id: d.id, ...d.data() }))
      setEntries(arr)
    })
    return () => unsub()
  }, [roomCode])

  const handleCreateRoom = async () => {
    try {
      const code = (Math.random().toString(36).slice(2, 6) + Math.random().toString(36).slice(2, 6)).slice(0, 6).toUpperCase()
      await createRoom(db, code, playerId)
      setRoomCode(code)
    } catch (e) {
      alert(e.message)
    }
  }

  const handleJoinRoom = async () => {
    try {
      if (!roomCode || !name.trim()) throw new Error('Enter room code and name')
      await joinRoom(db, roomCode.toUpperCase(), playerId, name.trim())
      setRoomCode(roomCode.toUpperCase())
    } catch (e) {
      alert(e.message)
    }
  }

  const handleStart = async () => {
    try {
      if (!room) return
      if (room.hostId !== playerId) throw new Error('Only host can start')
      await startGame(db, room.id, 60000)
    } catch (e) {
      alert(e.message)
    }
  }

  const canType = room?.status === 'playing'

  // Local countdown rendering based on endsAt/startedAt
  const [tick, setTick] = useState(0)
  useEffect(() => {
    const t = setInterval(() => setTick((x) => x + 1), 200)
    return () => clearInterval(t)
  }, [])

  const countdown = useMemo(() => {
    if (!room?.startedAt) return null
    const diff = Math.ceil((room.startedAt - nowMs()) / 1000)
    return diff > 0 ? diff : null
  }, [room?.startedAt, tick])

  const timeLeft = useMemo(() => {
    if (!room?.endsAt) return null
    return secondsLeft(room.endsAt)
  }, [room?.endsAt, tick])

  const onSubmit = async (e) => {
    e.preventDefault()
    const guess = input.trim()
    if (!guess) return
    if (!canType) {
      setFeedback('Wait for the round to start!')
      return
    }
    if (!isValid(guess)) {
      setFeedback('Not a valid Pokémon name!')
      return
    }
    try {
      await submitEntry(db, room.id, playerId, guess)
      setInput('')
      setFeedback('Nice!')
      setTimeout(() => setFeedback(''), 600)
    } catch (e) {
      setFeedback(e.message)
      setTimeout(() => setFeedback(''), 1000)
    }
  }

  const isHost = room?.hostId === playerId

  return (
    <div style={{
      fontFamily: 'ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto',
      maxWidth: 960, margin: '0 auto', padding: 16
    }}>
      <h1 style={{ fontSize: 28, fontWeight: 800, marginBottom: 8 }}>Pokémon Typing Battle</h1>
      <p style={{ opacity: 0.8, marginBottom: 16 }}>Type as many unique Pokémon as you can in 60 seconds. No repeats across the room!</p>

      {dexLoading && <div>Loading Pokédex… (first run can take a few seconds)</div>}
      {dexError && <div style={{color: 'crimson'}}>Pokédex error: {dexError}</div>}

      {!room && (
        <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: 12 }}>
          <div style={{ border: '1px solid #ddd', borderRadius: 12, padding: 16 }}>
            <h2 style={{ fontSize: 20, fontWeight: 700 }}>Create Room</h2>
            <button onClick={handleCreateRoom} style={btnStyle}>Create</button>
          </div>
          <div style={{ border: '1px solid #ddd', borderRadius: 12, padding: 16 }}>
            <h2 style={{ fontSize: 20, fontWeight: 700 }}>Join Room</h2>
            <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
              <input placeholder="Room Code" value={roomCode} onChange={(e)=>setRoomCode(e.target.value.toUpperCase())} style={inputStyle} />
              <input placeholder="Your Name" value={name} onChange={(e)=>setName(e.target.value)} style={inputStyle} />
              <button onClick={handleJoinRoom} style={btnStyle}>Join</button>
            </div>
          </div>
        </div>
      )}

      {room && (
        <div style={{ border: '1px solid #ddd', borderRadius: 12, padding: 16, marginTop: 12 }}>
          <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', gap: 8, flexWrap:'wrap' }}>
            <div>
              <div style={{ fontSize: 12, opacity: 0.7 }}>Room</div>
              <div style={{ fontSize: 20, fontWeight: 800 }}>{room.id}</div>
            </div>
            <div>
              <div style={{ fontSize: 12, opacity: 0.7 }}>Status</div>
              <div style={{ fontSize: 16, fontWeight: 700, textTransform:'capitalize' }}>{room.status}</div>
            </div>
            <div>
              {room.status === 'countdown' && <span style={{ fontSize: 24, fontWeight: 900 }}>Starting in {countdown ?? 0}</span>}
              {room.status === 'playing' && <span style={{ fontSize: 24, fontWeight: 900 }}>Time: {timeLeft}s</span>}
              {room.status === 'ended' && <span style={{ fontSize: 24, fontWeight: 900 }}>Round over</span>}
            </div>
            {isHost && room.status === 'lobby' && (
              <button onClick={handleStart} style={btnPrimary}>Start (60s)</button>
            )}
          </div>

          <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: 12, marginTop: 16 }}>
            <div>
              <form onSubmit={onSubmit} style={{ display: 'flex', gap: 8 }}>
                <input disabled={!canType} value={input} onChange={(e)=>setInput(e.target.value)} placeholder="Type a Pokémon and press Enter…" style={{...inputStyle, flex:1, fontSize:18}} />
                <button disabled={!canType} style={btnStyle}>Submit</button>
              </form>
              {feedback && <div style={{ marginTop: 8, fontWeight: 600 }}>{feedback}</div>}

              <div style={{ marginTop: 16 }}>
                <h3 style={{ fontWeight: 700 }}>Recent Entries</h3>
                <ul>
                  {entries.map((e) => (
                    <li key={e.id} style={{ opacity: 0.9 }}>{e.name} <span style={{ opacity: 0.6 }}>— {players.find(p=>p.id===e.playerId)?.name || 'someone'}</span></li>
                  ))}
                </ul>
              </div>
            </div>

            <div>
              <h3 style={{ fontWeight: 700 }}>Players</h3>
              <ol>
                {players.map((p) => (
                  <li key={p.id} style={{ display:'flex', justifyContent:'space-between' }}>
                    <span>{p.name}{p.id===room.hostId?' (Host)':''}{p.id===playerId?' — You':''}</span>
                    <strong>{p.score || 0}</strong>
                  </li>
                ))}
              </ol>
            </div>
          </div>
        </div>
      )}

      <Footer />
    </div>
  )
}

const inputStyle = {
  padding: '10px 12px',
  border: '1px solid #ccc',
  borderRadius: 10,
}
const btnStyle = {
  padding: '10px 14px',
  border: '1px solid #ccc',
  borderRadius: 10,
  background: '#f8f8f8',
  cursor: 'pointer'
}
const btnPrimary = {
  ...btnStyle,
  background: '#111',
  color: '#fff',
  border: '1px solid #111'
}

function Footer(){
  return (
    <div style={{ marginTop: 24, opacity: 0.7, fontSize: 12 }}>
      Pro tip: If a name like “Mr. Mime” doesn’t validate, try “mr-mime”. The app uses PokéAPI canonical spellings.
    </div>
  )
}

function Root(){
  return <App />
}

createRoot(document.getElementById('root')).render(<Root />)

// ======== 5) Minimal index.html (put in your public root) ========
// <!doctype html>
// <html>
//   <head>
//     <meta charset="UTF-8" />
//     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
//     <title>Pokémon Typing Battle</title>
//   </head>
//   <body>
//     <div id="root"></div>
//     <script type="module" src="/src/main.jsx"></script>
//   </body>
// </html>

// ======== 6) Firestore Security Rules (copy into your project) ========
// These are permissive for rapid prototyping. Tighten for production.
// - Allows anyone to create/join a room and write entries while the room exists.
// - Prevents writing entries after the room is ended by checking endsAt.
//
// rules_version = '2';
// service cloud.firestore {
//   match /databases/{database}/documents {
//     function roomActive(room) {
//       return room.data.status == 'playing' && request.time.toMillis() < room.data.endsAt;
//     }
//
//     match /rooms/{roomId} {
//       allow read: if true;
//       allow create: if true; // create room
//       allow update: if true; // host updates status — simplify for demo
//
//       match /players/{playerId} {
//         allow read: if true;
//         allow create, update: if true; // any player can join/update own score (transaction-controlled client-side)
//       }
//
//       match /entries/{entryId} {
//         allow read: if true;
//         allow create: if get(/databases/$(database)/documents/rooms/$(roomId)).data.status == 'playing'
//           && request.time.toMillis() < get(/databases/$(database)/documents/rooms/$(roomId)).data.endsAt;
//       }
//     }
//   }
// }

// ======== 7) Notes ========
// - This demo trusts client for name validation; Firestore transaction prevents duplicates per room.
// - For production, consider Cloud Functions to enforce host-only start, rate limiting, and stricter rules.
// - You can change round length by editing startGame duration.
